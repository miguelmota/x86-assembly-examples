; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\data\AsmBook5\examples\ch12\VisualCPP\FindArray\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 339  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 340  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 348  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 349  : 		}

	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 418  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 419  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 441  : //		_DEBUG_POINTER(_First);
; 442  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 443  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Copy_s
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Copy_s, COMDAT

; 456  : //		_DEBUG_POINTER(_First1);
; 457  : //		_DEBUG_POINTER(_First2);
; 458  : 		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 459  : 		return _First1;

	mov	eax, esi
	pop	esi

; 460  : 		}

	ret	0
?_Copy_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Copy_s
_TEXT	ENDS
PUBLIC	?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z	; std::char_traits<char>::_Move_s
EXTRN	_memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size_in_bytes$ = 12					; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z PROC	; std::char_traits<char>::_Move_s, COMDAT

; 480  : //		_DEBUG_POINTER(_First1);
; 481  : //		_DEBUG_POINTER(_First2);
; 482  : 		_CRT_SECURE_MEMMOVE(_First1, _Size_in_bytes, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size_in_bytes$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 483  : 		return _First1;

	mov	eax, esi
	pop	esi

; 484  : 		}

	ret	0
?_Move_s@?$char_traits@D@std@@SAPADPADIPBDI@Z ENDP	; std::char_traits<char>::_Move_s
_TEXT	ENDS
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
; Function compile flags: /Ogtpy
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 494  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[esp-4]
	mov	al, BYTE PTR [eax]

; 495  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
; Function compile flags: /Ogtpy
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 499  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[esp-4]
	movzx	eax, BYTE PTR [eax]

; 500  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
; Function compile flags: /Ogtpy
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 505  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	eax, eax
	cmp	ecx, DWORD PTR [edx]
	sete	al

; 506  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
; Function compile flags: /Ogtpy
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 510  : 		return (EOF);

	or	eax, -1

; 511  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 403  : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 404  : 		}

	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
_TEXT	ENDS
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
EXTRN	__Getctype:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T19839 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 114  : 		{	// return ctype stuff

	sub	esp, 16					; 00000010H

; 115  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T19839[esp+16]
	push	eax
	call	__Getctype
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx

; 116  : 		}

	add	esp, 20					; 00000014H
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
EXTRN	__Getcvt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 120  : 		return (::_Getcvt());

	call	__Getcvt
	mov	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 121  : 		}

	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 73   : 			{	// construct with specified stamp value

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 74   : 			}

	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
; Function compile flags: /Ogtpy
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$11228 = -4					; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 77   : 			{	// get stamp, with lazy allocation

	push	ecx
	push	esi
	mov	esi, ecx

; 78   : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator

; 79   : 				{	// still zero, allocate stamp
; 80   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$11228[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 81   : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN1@operator

; 82   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN1@operator:

; 83   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$11228[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator:

; 84   : 				}
; 85   : 			return (_Id);

	mov	eax, DWORD PTR [esi]
	pop	esi

; 86   : 			}

	pop	ecx
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Ogtpy
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$11234 = -4					; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 116  : 			{	// safely increment the reference count

	push	ecx
	push	esi
	mov	esi, ecx

; 117  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$11234[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 118  : 				if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN1@Incref

; 119  : 					++_Refs;

	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN1@Incref:

; 120  : 			_END_LOCK()

	lea	ecx, DWORD PTR __Lock$11234[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	esi

; 121  : 			}

	pop	ecx
	ret	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
; Function compile flags: /Ogtpy
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
__Lock$11239 = -4					; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC		; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 124  : 			{	// safely decrement the reference count, return this when dead

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 125  : 			_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$11239[esp+16]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 126  : 				if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN1@Decref
	cmp	eax, -1
	jae	SHORT $LN1@Decref

; 127  : 					--_Refs;

	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN1@Decref:

; 128  : 				return (_Refs == 0 ? this : 0);

	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$11239[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi

; 129  : 			_END_LOCK()
; 130  : 			}

	pop	ecx
	ret	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
_TEXT	ENDS
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
EXTRN	?facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::facet_Register
; Function compile flags: /Ogtpy
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = ecx

; 134  : 			facet_Register(this);

	push	ecx
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	pop	ecx

; 135  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
_TEXT	ENDS
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@UAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 165  : 			{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@

; 166  : 			}

	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
; Function compile flags: /Ogtpy
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 171  : 			{	// construct with initial reference count

	mov	eax, ecx
	mov	ecx, DWORD PTR __Initrefs$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
	mov	DWORD PTR [eax+4], ecx

; 172  : 			}

	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Ogtpy
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Lock$19867 = 8					; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 318  : 		{	// construct by copying

	mov	eax, DWORD PTR __Right$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 319  : 		_Ptr->_Incref();

	push	0
	lea	ecx, DWORD PTR __Lock$19867[esp+8]
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN3@locale
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN3@locale:
	lea	ecx, DWORD PTR __Lock$19867[esp+4]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 320  : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
; Function compile flags: /Ogtpy
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$19881 = -4					; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 374  : 		{	// destroy the object

	push	ecx
	push	edi

; 375  : 		if (_Ptr != 0)

	mov	edi, DWORD PTR [ecx]
	test	edi, edi
	je	SHORT $LN4@locale@2

; 376  : 			_DELETE_CRT(_Ptr->_Decref());

	push	0
	lea	ecx, DWORD PTR __Lock$19881[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN6@locale@2
	cmp	eax, -1
	jae	SHORT $LN6@locale@2
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN6@locale@2:
	push	esi
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$19881[esp+12]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN9@locale@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN9@locale@2:
	pop	esi
$LN4@locale@2:
	pop	edi

; 377  : 		}

	pop	ecx
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
; Function compile flags: /Ogtpy
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 397  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 398  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Id$[esp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 399  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN1@Getfacet
$LN10@Getfacet:
	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 400  : 			return (_Facptr);	// found facet or not transparent, return pointer
; 401  : 		else
; 402  : 			{	// look in current locale
; 403  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 404  : 			return (_Id < _Ptr->_Facetcount
; 405  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 406  : 				: 0);	// no entry in current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+esi*4]
	pop	esi

; 407  : 			}
; 408  : 		}

	ret	4
$LN6@Getfacet:

; 397  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 398  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	eax, eax

; 399  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	jmp	SHORT $LN10@Getfacet
$LN8@Getfacet:

; 404  : 			return (_Id < _Ptr->_Facetcount
; 405  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 406  : 				: 0);	// no entry in current locale

	xor	eax, eax
$LN1@Getfacet:
	pop	esi

; 407  : 			}
; 408  : 		}

	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 1330 : 		{	// default constructor

	mov	eax, ecx
	mov	ecx, DWORD PTR __Refs$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 1331 : 		}

	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
; Function compile flags: /Ogtpy
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 1335 : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
; Function compile flags: /Ogtpy
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 1632 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	movzx	eax, BYTE PTR __Ch$[esp-4]
	mov	ecx, DWORD PTR [ecx+16]
	mov	ax, WORD PTR [ecx+eax*2]
	and	ax, WORD PTR __Maskval$[esp-4]
	neg	ax
	sbb	eax, eax
	neg	eax

; 1633 : 		}

	ret	8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T19931 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 1774 : 		{	// initialize from _Lobj

	sub	esp, 16					; 00000010H
	push	esi

; 1775 : 		_Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T19931[esp+20]
	push	eax
	mov	esi, ecx
	call	__Getctype
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+16], ecx
	mov	edx, DWORD PTR [eax+12]
	add	esp, 4
	mov	DWORD PTR [esi+20], edx
	pop	esi

; 1776 : 		}

	add	esp, 16					; 00000010H
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_free:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 1780 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 1781 : 			free((void *)_Ctype._Table);

	mov	eax, DWORD PTR [ecx+16]
	push	eax
	call	_free
	add	esp, 4

; 1784 : 		}

	ret	0
$LN6@Tidy:

; 1782 : 		else if (_Ctype._Delfl < 0)

	jge	SHORT $LN1@Tidy

; 1783 : 			delete[] (void *)_Ctype._Table;

	mov	ecx, DWORD PTR [ecx+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN1@Tidy:

; 1784 : 		}

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 299  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+8]

; 300  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
; Function compile flags: /Ogtpy
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 322  : 		return (rdstate() == goodbit);

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al

; 323  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Ogtpy
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 332  : 		return (((int)rdstate()
; 333  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [ecx+8]
	and	al, 6
	neg	al
	sbb	eax, eax
	neg	eax

; 334  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
; Function compile flags: /Ogtpy
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 362  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+16]

; 363  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
PUBLIC	?width@ios_base@std@@QBEHXZ			; std::ios_base::width
; Function compile flags: /Ogtpy
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBEHXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 407  : 		return (_Wide);

	mov	eax, DWORD PTR [ecx+24]

; 408  : 		}

	ret	0
?width@ios_base@std@@QBEHXZ ENDP			; std::ios_base::width
_TEXT	ENDS
PUBLIC	?width@ios_base@std@@QAEHH@Z			; std::ios_base::width
; Function compile flags: /Ogtpy
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 4
?width@ios_base@std@@QAEHH@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 412  : 		streamsize _Oldwidth = _Wide;
; 413  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR __Newwidth$[esp-4]
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [ecx+24], edx

; 414  : 		return (_Oldwidth);
; 415  : 		}

	ret	4
?width@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::width
_TEXT	ENDS
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
; Function compile flags: /Ogtpy
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T19960 = -4						; size = 4
__Lock$19974 = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 418  : 		{	// get locale

	push	ecx

; 419  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+36]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+8]
	push	0
	lea	ecx, DWORD PTR __Lock$19974[esp+12]
	mov	DWORD PTR $T19960[esp+16], 0
	mov	DWORD PTR [edi], esi
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jae	SHORT $LN7@getloc
	add	eax, 1
	mov	DWORD PTR [esi+4], eax
$LN7@getloc:
	lea	ecx, DWORD PTR __Lock$19974[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, edi
	pop	edi
	pop	esi

; 420  : 		}

	pop	ecx
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 135  :     return _time64(_Time);

	push	eax
	call	__time64
	add	esp, 4

; 136  : }

	ret	0
_time	ENDP
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1599 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1600 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 170  : 		_DEBUG_POINTER(_Pfn);
; 171  : 		return ((*_Pfn)(*this));

	push	ecx
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 172  : 		}

	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 85   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+40]

; 86   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 81   : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 82   : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
$LN3@Myptr:

; 2055 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2056 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	mov	eax, ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 106  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+48]

; 107  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 101  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+48]
	jmp	edx
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:PROC		; std::_Mutex::_Unlock
; Function compile flags: /Ogtpy
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 179  : 		_Mylock._Unlock();

	add	ecx, 4
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Ogtpy
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 191  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]

; 192  : 		}

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Ogtpy
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 235  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	add	DWORD PTR [eax], -1

; 236  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 237  : 		}

	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
; Function compile flags: /Ogtpy
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 241  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+48]
	add	DWORD PTR [eax], -1

; 242  : 		return (++(*_IGnext));

	mov	eax, DWORD PTR [ecx+32]
	add	DWORD PTR [eax], 1
	mov	eax, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [eax]

; 243  : 		}

	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
; Function compile flags: /Ogtpy
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 247  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Gnavail
	mov	ecx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [ecx]

; 248  : 		}

	ret	0
$LN3@Gnavail:

; 247  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	xor	eax, eax

; 248  : 		}

	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
; Function compile flags: /Ogtpy
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 278  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	ecx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [ecx]

; 279  : 		}

	ret	0
$LN3@Pnavail:

; 278  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax

; 279  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 114  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 115  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 1
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 880  : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR [edx+32]
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+4]
	push	eax
	mov	eax, DWORD PTR __Iosbase$[esp+8]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR __Dest$[esp+32]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	esi
	call	edx
	mov	eax, esi

; 881  : 		}

	pop	esi
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Ogtpy
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 886  : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR [edx+28]
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+4]
	push	eax
	mov	eax, DWORD PTR __Iosbase$[esp+8]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR __Dest$[esp+32]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+24]
	push	esi
	call	edx
	mov	eax, esi

; 887  : 		}

	pop	esi
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 2210 : 		return (_Failed);

	mov	al, BYTE PTR [ecx+4]

; 2211 : 		}

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
PUBLIC	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get, COMDAT
; _this$ = ecx

; 284  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	push	eax
	mov	eax, DWORD PTR __State$[esp+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR __Iosbase$[esp+8]
	mov	edx, DWORD PTR [edx+32]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Last$[esp+28]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR __Last$[esp+32]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR __First$[esp+24]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __First$[esp+40]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR __First$[esp+44]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	push	esi
	call	edx
	mov	eax, esi

; 285  : 		}

	pop	esi
	ret	40					; 00000028H
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Uinput_iterator_tag@std@@DJPADAADU_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator_with_base@Uinput_iterator_tag@std@@DJPADAADU_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Uinput_iterator_tag@std@@DJPADAADU_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Uinput_iterator_tag@std@@DJPADAADU_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>::_Iterator_with_base<std::input_iterator_tag,char,long,char *,char &,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Uoutput_iterator_tag@std@@XXXXU_Iterator_base@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>::_Iterator_with_base<std::output_iterator_tag,void,void,void,void,std::_Iterator_base>
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN3@Myptr@2
	mov	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
$LN3@Myptr@2:

; 2050 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 2051 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 142  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 73   : 		return (_Tiestr);

	mov	eax, DWORD PTR [ecx+44]

; 74   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:PROC			; std::_Mutex::_Lock
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 174  : 		_Mylock._Lock();

	add	ecx, 4
	jmp	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Ogtpy
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 272  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+52]
	add	DWORD PTR [eax], -1

; 273  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx

; 274  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 73   : 			{	// lock the stream buffer, if there

	mov	eax, DWORD PTR __Ostr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 74   : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN10@Sentry_bas

; 75   : 				_Myostr.rdbuf()->_Lock();

	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN10@Sentry_bas:

; 76   : 			}

	mov	eax, esi
	pop	esi
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 80   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas@2

; 81   : 				_Myostr.rdbuf()->_Unlock();

	lea	ecx, DWORD PTR [eax+4]
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN8@Sentry_bas@2:

; 82   : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2012 : 		{	// test if _Ptr points inside string

	push	esi

; 2013 : 		_DEBUG_POINTER(_Ptr);
; 2014 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	esi, DWORD PTR [ecx+24]
	cmp	esi, 16					; 00000010H
	push	edi
	lea	eax, DWORD PTR [ecx+4]
	jb	SHORT $LN8@Inside
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	edx, eax
$LN9@Inside:
	mov	edi, DWORD PTR __Ptr$[esp+4]
	cmp	edi, edx
	jb	SHORT $LN2@Inside
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN12@Inside
	mov	eax, DWORD PTR [eax]
$LN12@Inside:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $LN2@Inside
	pop	edi

; 2016 : 		else
; 2017 : 			return (true);

	mov	al, 1
	pop	esi

; 2018 : 		}

	ret	4
$LN2@Inside:
	pop	edi

; 2015 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2018 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 167  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 168  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files\microsoft visual studio 8\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T20100 = -12						; size = 12
$T20105 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 38   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 39   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 45   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 1
	jae	SHORT $LN1@Allocate

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T20105[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T20100[esp+16]
	mov	DWORD PTR $T20105[esp+12], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T20100[esp+16]
	push	ecx
	mov	DWORD PTR $T20100[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN8@Allocate:
	int	3
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 169  : 		return (xsputn(_Ptr, _Count));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	jmp	eax
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 853  : 		{	// initialize from _Locinfo object

	push	esi
	mov	esi, ecx

; 854  : 		_Cvt = _Lobj._Getcvt();

	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	pop	esi

; 855  : 		}

	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
PUBLIC	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
; Function compile flags: /Ogtpy
;	COMDAT ?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 235  : 		{	// initialize from _Locinfo object

	push	esi
	mov	esi, ecx

; 236  : 		_Cvt = _Lobj._Getcvt();

	call	__Getcvt
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	pop	esi

; 237  : 		}

	ret	4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
PUBLIC	??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ; std::_Char_traits_cat<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ
_TEXT	SEGMENT
__Secure$ = -1						; size = 1
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ PROC ; std::_Char_traits_cat<std::char_traits<char> >, COMDAT

; 568  : 	{

	push	ecx

; 569  : 		typename _Char_traits_category<_Traits>::_Secure_char_traits _Secure;
; 570  : 		return (_Secure);

	mov	al, BYTE PTR __Secure$[esp+4]

; 571  : 	}

	pop	ecx
	ret	0
??$_Char_traits_cat@U?$char_traits@D@std@@@std@@YA?AU_Secure_char_traits_tag@0@XZ ENDP ; std::_Char_traits_cat<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 590  : 		return _Traits::_Copy_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 591  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
___formal$ = 24						; size = 1
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 617  : 		return _Traits::_Move_s(_First1, _Size, _First2, _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 618  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDIU_Secure_char_traits_tag@1@@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 62   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas@3

; 63   : 				_Myistr.rdbuf()->_Unlock();

	lea	ecx, DWORD PTR [eax+4]
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN8@Sentry_bas@3:

; 64   : 			}

	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 112  : 		return (0 < _Gnavail()
; 113  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sgetc
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sgetc
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]

; 114  : 		}

	ret	0
$LN3@sgetc:

; 112  : 		return (0 < _Gnavail()
; 113  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	jmp	eax
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 471  : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 55   : 			{	// lock the stream buffer, if there

	mov	eax, DWORD PTR __Istr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], eax

; 56   : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN10@Sentry_bas@4

; 57   : 				_Myistr.rdbuf()->_Lock();

	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN10@Sentry_bas@4:

; 58   : 			}

	mov	eax, esi
	pop	esi
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 106  : 		return (0 < _Gnavail()
; 107  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sbumpc
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sbumpc
	mov	eax, edx
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]

; 108  : 		}

	ret	0
$LN3@sbumpc:

; 106  : 		return (0 < _Gnavail()
; 107  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	jmp	edx
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; Function compile flags: /Ogtpy
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 162  : 		return (0 < _Pnavail()
; 163  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 164  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN3@sputc
	mov	eax, edx
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	mov	cl, BYTE PTR __Ch$[esp-4]
	mov	BYTE PTR [eax], cl
	movzx	eax, cl

; 165  : 		}

	ret	4
$LN3@sputc:

; 162  : 		return (0 < _Pnavail()
; 163  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 164  : 			: overflow(_Traits::to_int_type(_Ch)));

	movzx	edx, BYTE PTR __Ch$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Ch$[esp-4], edx
	jmp	eax
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 2059 : 		{	// construct from stream buffer _Sb

	mov	eax, ecx
	mov	ecx, DWORD PTR __Sb$[esp-4]
	test	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	sete	cl
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+8], cl

; 2060 : 		}

	ret	4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ PROC ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Outit_with_base@U_Iterator_base@std@@@std@@QAE@XZ ENDP ; std::_Outit_with_base<std::_Iterator_base>::_Outit_with_base<std::_Iterator_base>
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 1994 : 		}

	ret	4

; 1993 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$LN5@Eos:
	mov	BYTE PTR [ecx+eax+4], 0

; 1994 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1604 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1605 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1606 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 147  : 		}

	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::copy_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::copy_s<std::char_traits<char> >, COMDAT

; 582  : 		return copy_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memcpy_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 583  : 	}

	ret	0
??$copy_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::copy_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ; std::_Traits_helper::move_s<std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Size$ = 12						; size = 4
__First2$ = 16						; size = 4
__Count$ = 20						; size = 4
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z PROC ; std::_Traits_helper::move_s<std::char_traits<char> >, COMDAT

; 609  : 		return move_s<_Traits>(_First1, _Size, _First2, _Count, _Char_traits_cat<_Traits>());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	mov	edx, DWORD PTR __Size$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
	mov	eax, esi
	pop	esi

; 610  : 	}

	ret	0
??$move_s@U?$char_traits@D@std@@@_Traits_helper@std@@YAPADPADIPBDI@Z ENDP ; std::_Traits_helper::move_s<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtpy
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN11@sentry
	lea	ecx, DWORD PTR [eax+4]
	jmp	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN11@sentry:
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 131  : 		{	// point to next character and return it

	push	esi
	mov	esi, ecx

; 132  : 		return (1 < _Gnavail()
; 133  : 			? _Traits::to_int_type(*_Gnpreinc())
; 134  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 135  : 				? _Traits::eof() : sgetc());

	mov	eax, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 1
	jle	SHORT $LN5@snextc
	mov	eax, DWORD PTR [esi+48]
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+32]
	add	DWORD PTR [eax], 1
	mov	edx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	pop	esi

; 136  : 		}

	ret	0
$LN5@snextc:

; 132  : 		return (1 < _Gnavail()
; 133  : 			? _Traits::to_int_type(*_Gnpreinc())
; 134  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 135  : 				? _Traits::eof() : sgetc());

	test	eax, eax
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN17@snextc
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	movzx	eax, BYTE PTR [ecx]
	jmp	SHORT $LN18@snextc
$LN17@snextc:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, esi
	call	edx
$LN18@snextc:
	cmp	eax, -1
	jne	SHORT $LN3@snextc
	or	eax, eax
	pop	esi

; 136  : 		}

	ret	0
$LN3@snextc:

; 132  : 		return (1 < _Gnavail()
; 133  : 			? _Traits::to_int_type(*_Gnpreinc())
; 134  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 135  : 				? _Traits::eof() : sgetc());

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN35@snextc
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN35@snextc
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	pop	esi

; 136  : 		}

	ret	0

; 132  : 		return (1 < _Gnavail()
; 133  : 			? _Traits::to_int_type(*_Gnpreinc())
; 134  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 135  : 				? _Traits::eof() : sgetc());

$LN35@snextc:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	pop	esi
	jmp	edx
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2029 : 		if (!_Built)

	cmp	BYTE PTR __Built$[esp-4], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	je	SHORT $LN15@Tidy@2

; 2030 : 			;
; 2031 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN15@Tidy@2

; 2032 : 			{	// copy any leftovers to small buffer and deallocate
; 2033 : 			_Elem *_Ptr = _Bx._Ptr;
; 2034 : 			if (0 < _Newsize)

	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	jbe	SHORT $LN13@Tidy@2

; 2035 : 				_Traits_helper::copy_s<_Traits>(_Bx._Buf, _BUF_SIZE, _Ptr, _Newsize);

	push	edi
	push	ebx
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN13@Tidy@2:

; 2036 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN15@Tidy@2:

; 2037 : 			}
; 2038 : 		_Myres = _BUF_SIZE - 1;
; 2039 : 		_Eos(_Newsize);

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+edi+4], 0
	pop	edi
	pop	esi

; 2040 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 2176 : 		{	// construct from stream buffer _Sb

	mov	eax, ecx
	mov	ecx, DWORD PTR __Sb$[esp-4]
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax+8], ecx

; 2177 : 		}

	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xran
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1202 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebx

; 1203 : 		if (_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], ebx
	push	edi
	jae	SHORT $LN3@erase

; 1204 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@erase:

; 1205 : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebx
	cmp	eax, edi
	jae	SHORT $LN2@erase

; 1206 : 			_Count = _Mysize - _Off;	// trim _Count

	mov	edi, eax
$LN2@erase:

; 1207 : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $LN30@erase

; 1208 : 			{	// move elements down
; 1209 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off, _Myres - _Off, _Myptr() + _Off + _Count,
; 1210 : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	push	ebp
	lea	ebp, DWORD PTR [esi+4]
	jb	SHORT $LN8@erase
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR tv130[esp+12], edx
	jmp	SHORT $LN9@erase
$LN8@erase:
	mov	DWORD PTR tv130[esp+12], ebp
$LN9@erase:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@erase
	mov	edx, DWORD PTR [ebp]
	jmp	SHORT $LN13@erase
$LN12@erase:
	mov	edx, ebp
$LN13@erase:
	sub	eax, edi
	push	eax
	mov	eax, DWORD PTR tv130[esp+16]
	add	eax, ebx
	add	eax, edi
	push	eax
	sub	ecx, ebx
	push	ecx
	add	edx, ebx
	push	edx
	call	_memmove_s

; 1211 : 			size_type _Newsize = _Mysize - _Count;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, edi
	add	esp, 16					; 00000010H

; 1212 : 			_Eos(_Newsize);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $LN26@erase
	mov	ebp, DWORD PTR [ebp]
$LN26@erase:
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
$LN30@erase:
	pop	edi

; 1213 : 			}
; 1214 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1215 : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1962 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 1963 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH

; 1964 : 		if (max_size() < _Newres)

	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN6@Copy

; 1965 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	esi, eax

; 1966 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $LN4@Copy
$LN6@Copy:

; 1967 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	ebx, DWORD PTR [edi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $LN4@Copy
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN4@Copy

; 1968 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	esi, DWORD PTR [ecx+ebx]
$LN4@Copy:

; 1969 : 		_Elem *_Ptr = 0;
; 1970 : 
; 1971 : 		_TRY_BEGIN
; 1972 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [esi+1]
	push	0
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8
	mov	DWORD PTR __Ptr$[ebp], eax

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	jmp	SHORT $LN16@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 1973 : 		_CATCH_ALL
; 1974 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Newres$[ebp], eax

; 1975 : 			_TRY_BEGIN
; 1976 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	add	eax, 1
	push	0
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	mov	DWORD PTR __Ptr$[ebp], eax
	add	esp, 8

; 1980 : 			_CATCH_END
; 1981 : 		_CATCH_END

	mov	eax, $LN105@Copy
	ret	0
$LN105@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN16@Copy:

; 1982 : 
; 1983 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	jbe	SHORT $LN71@Copy

; 1984 : 			_Traits_helper::copy_s<_Traits>(_Ptr, _Newres + 1, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN63@Copy
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $LN64@Copy
$LN63@Copy:
	lea	eax, DWORD PTR [edi+4]
$LN64@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [esi+1]
	push	edx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN71@Copy:

; 1985 : 		_Tidy(true);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $LN87@Copy
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@Copy:

; 1986 : 		_Bx._Ptr = _Ptr;
; 1987 : 		_Myres = _Newres;
; 1988 : 		_Eos(_Oldlen);

	cmp	esi, 16					; 00000010H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [edi+24], esi
	mov	DWORD PTR [edi+20], ebx
	jb	SHORT $LN101@Copy
	mov	eax, ecx
$LN101@Copy:
	mov	BYTE PTR [eax+ebx], 0

; 1989 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 1977 : 			_CATCH_ALL
; 1978 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN51@Copy
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Copy:

; 1979 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$LN108@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 550  : 		{	// construct empty string

	mov	eax, ecx

; 551  : 		_Tidy();

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+4], cl

; 552  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 866  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 867  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN17@basic_stri
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@basic_stri:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 868  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
EXTRN	?_Xlen@_String_base@std@@SAXXZ:PROC		; std::_String_base::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1998 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebx

; 1999 : 			if (max_size() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[esp]
	cmp	ebx, -2					; fffffffeH
	push	esi
	mov	esi, ecx
	jbe	SHORT $LN6@Grow

; 2000 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN6@Grow:

; 2001 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow

; 2002 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN5@Grow:

; 2003 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	cmp	BYTE PTR __Trim$[esp+4], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
	push	edi

; 2004 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2005 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	edi, DWORD PTR [esi+20]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN33@Grow
	test	edi, edi
	lea	eax, DWORD PTR [esi+4]
	push	ebp
	mov	ebp, DWORD PTR [eax]
	jbe	SHORT $LN31@Grow
	push	edi
	push	ebp
	push	16					; 00000010H
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H
$LN31@Grow:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebp
$LN33@Grow:
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	mov	BYTE PTR [esi+edi+4], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
$LN3@Grow:

; 2006 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN49@Grow

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN47@Grow
	mov	esi, DWORD PTR [esi+4]

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	mov	BYTE PTR [esi], bl
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8

; 2007 : 			_Eos(0);	// new size is zero, just null terminate

$LN47@Grow:
	add	esi, 4
	mov	BYTE PTR [esi], 0
$LN49@Grow:

; 2008 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx

; 2009 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@runtime_error@std@@UBEPBDXZ		; std::runtime_error::what
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
CONST	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 158  : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 159  : 		}

	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN19@runtime_er
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@runtime_er:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1584 : 		return (_Myptr());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN5@c_str
	mov	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0

; 1584 : 		return (_Myptr());

$LN5@c_str:
	lea	eax, DWORD PTR [ecx+4]

; 1585 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@runtime_error@std@@UBEPBDXZ PROC			; std::runtime_error::what, COMDAT
; _this$ = ecx

; 163  : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $LN7@what
	mov	eax, DWORD PTR [ecx+16]

; 164  : 		}

	ret	0

; 163  : 		return (_Str.c_str());

$LN7@what:
	lea	eax, DWORD PTR [ecx+16]

; 164  : 		}

	ret	0
?what@runtime_error@std@@UBEPBDXZ ENDP			; std::runtime_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN22@scalar@4
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@scalar@4:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN32@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1_Locinfo@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1_Locinfo@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 92   :         {

	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+36], esi

; 93   :         _Locinfo_dtor(this);

	push	esi
	mov	DWORD PTR __$EHRec$[esp+48], 4
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 94   :         }

	mov	ebp, 16					; 00000010H
	add	esp, 4
	cmp	DWORD PTR [esi+112], ebp
	jb	SHORT $LN24@Locinfo
	mov	eax, DWORD PTR [esi+92]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Locinfo:
	xor	ebx, ebx
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR [esi+112], edi
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl
	cmp	DWORD PTR [esi+84], ebp
	jb	SHORT $LN50@Locinfo
	mov	eax, DWORD PTR [esi+64]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN50@Locinfo:
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	cmp	DWORD PTR [esi+56], ebp
	jb	SHORT $LN76@Locinfo
	mov	eax, DWORD PTR [esi+36]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN76@Locinfo:
	mov	DWORD PTR [esi+56], edi
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	cmp	DWORD PTR [esi+28], ebp
	jb	SHORT $LN102@Locinfo
	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN102@Locinfo:
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+24], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??1_Locinfo@std@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-20]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1000 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx

; 1001 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Roff$[esp+4]
	cmp	DWORD PTR [ebx+20], ebp
	push	esi
	push	edi
	mov	esi, ecx
	jae	SHORT $LN5@assign

; 1002 : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@assign:

; 1003 : 		size_type _Num = _Right.size() - _Roff;

	mov	edi, DWORD PTR [ebx+20]

; 1004 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	edi, ebp
	cmp	eax, edi
	jae	SHORT $LN4@assign

; 1005 : 			_Num = _Count;	// trim _Num to size

	mov	edi, eax
$LN4@assign:

; 1006 : 
; 1007 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1008 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	edi, ebp
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebp
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
$LN3@assign:

; 1009 : 		else if (_Grow(_Num))

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@assign
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@assign:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@assign
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN87@assign:
	jbe	SHORT $LN86@assign

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $LN64@assign
	mov	edx, DWORD PTR [ebx+4]
	jmp	SHORT $LN65@assign

; 1009 : 		else if (_Grow(_Num))

$LN16@assign:
	test	edi, edi
	jne	SHORT $LN87@assign
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1009 : 		else if (_Grow(_Num))

$LN58@assign:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH

; 1010 : 			{	// make room and assign new stuff
; 1011 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Right._Myptr() + _Roff, _Num);

$LN64@assign:
	lea	edx, DWORD PTR [ebx+4]
$LN65@assign:
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN69@assign
$LN68@assign:
	mov	eax, ebx
$LN69@assign:
	push	edi
	add	edx, ebp
	push	edx
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1012 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@assign
	mov	ebx, DWORD PTR [ebx]
$LN82@assign:
	mov	BYTE PTR [ebx+edi], 0
$LN86@assign:
	pop	edi

; 1013 : 			}
; 1014 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1015 : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1018 : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1019 : 		if (_Inside(_Ptr))

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, ebx
$LN13@assign@2:
	mov	ebp, DWORD PTR __Ptr$[esp+8]
	cmp	ebp, eax
	jb	SHORT $LN2@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, ebx
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+20]
	add	edx, eax
	cmp	edx, ebp
	jbe	SHORT $LN2@assign@2

; 1020 : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN20@assign@2:
	mov	eax, DWORD PTR __Num$[esp+8]
	push	eax
	sub	ebp, ebx
	push	ebp
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
$LN2@assign@2:
	push	edi

; 1021 : 
; 1022 : 		if (_Grow(_Num))

	mov	edi, DWORD PTR __Num$[esp+12]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN93@assign@2:
	jbe	SHORT $LN90@assign@2

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN74@assign@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN75@assign@2

; 1021 : 
; 1022 : 		if (_Grow(_Num))

$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN93@assign@2
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN68@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN68@assign@2:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	mov	BYTE PTR [ebx], 0
	pop	ebx

; 1028 : 		}

	ret	8

; 1023 : 			{	// make room and assign new stuff
; 1024 : 			_Traits_helper::copy_s<_Traits>(_Myptr(), _Myres, _Ptr, _Num);

$LN74@assign@2:
	mov	eax, ebx
$LN75@assign@2:
	push	edi
	push	ebp
	push	ecx
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1025 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN88@assign@2
	mov	ebx, DWORD PTR [ebx]
$LN88@assign@2:
	mov	BYTE PTR [ebx+edi], 0
$LN90@assign@2:
	pop	edi

; 1026 : 			}
; 1027 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1028 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 594  : 		{	// construct by copying _Right

	push	esi

; 595  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 596  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 597  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1031 : 		{	// assign [_Ptr, <null>)

	push	esi

; 1032 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL5@assign@3:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 1033 : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
EXTRN	??0exception@std@@QAE@XZ:PROC			; std::exception::exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 154  : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0exception@std@@QAE@XZ		; std::exception::exception
	xor	eax, eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	DWORD PTR __$EHRec$[esp+40], eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+28]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 155  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::ios_base::failure::failure
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 208  : 			{	// construct with message

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 209  : 			}

	mov	eax, esi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
; Function compile flags: /Ogtpy
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 212  : 			{	// destroy the object

	push	esi
	mov	esi, ecx

; 213  : 			}

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@failure
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@failure:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@5
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@5:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 632  : 		_Tidy();
; 633  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$LL37@basic_stri@2:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL37@basic_stri@2
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 634  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
xdata$x	ENDS
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T23105 = -80						; size = 28
$T23104 = -52						; size = 40
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 75   :         {

	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+96], esi
	xor	ebx, ebx
	push	ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, 15					; 0000000fH
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR __$EHRec$[esp+104], ebx
	mov	BYTE PTR [esi+8], bl
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+52], ebx
	mov	BYTE PTR [esi+36], bl
	mov	DWORD PTR [esi+84], eax
	mov	DWORD PTR [esi+80], ebx
	mov	BYTE PTR [esi+64], bl
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi+108], ebx
	mov	BYTE PTR [esi+92], bl

; 76   :         if (_Pch == 0)

	mov	ecx, DWORD PTR __Pch$[esp+92]
	cmp	ecx, ebx
	mov	BYTE PTR __$EHRec$[esp+104], 4
	jne	SHORT $LN1@Locinfo@2

; 77   :             _THROW_NCEE(runtime_error, "bad locale name");

	push	eax
	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
	lea	ecx, DWORD PTR $T23105[esp+104]
	mov	DWORD PTR $T23105[esp+128], eax
	mov	DWORD PTR $T23105[esp+124], ebx
	mov	BYTE PTR $T23105[esp+108], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T23105[esp+96]
	push	eax
	lea	ecx, DWORD PTR $T23104[esp+100]
	mov	BYTE PTR __$EHRec$[esp+108], 5
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T23104[esp+100]
	push	ecx
	call	__CxxThrowException@8
$LN1@Locinfo@2:

; 78   :         _Locinfo_ctor(this, _Pch);

	push	ecx
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 79   :         }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	add	esp, 84					; 00000054H
	ret	4
$LN175@Locinfo@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
	lea	ecx, DWORD PTR $T23105[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-80]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	edi, DWORD PTR ___that$[esp+24]
	push	edi
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	xor	eax, eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	push	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edi
	mov	DWORD PTR __$EHRec$[esp+48], eax
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??0?$ctype@D@std@@QAE@PBF_NI@Z			; std::ctype<char>::ctype<char>
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z	; std::ctype<char>::_Do_widen_s
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z	; std::ctype<char>::_Do_narrow_s
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
	DD	FLAT:?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@PBF_NI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@PBF_NI@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@PBF_NI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@PBF_NI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT
_this$GSCopy$ = -152					; size = 4
$T23959 = -148						; size = 16
__Lobj$12587 = -132					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Table$ = 8						; size = 4
__Deletetable$ = 12					; size = 1
__Refs$ = 16						; size = 4
??0?$ctype@D@std@@QAE@PBF_NI@Z PROC			; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 1739 : 		{	// construct with specified table and delete flag for table

	push	-1
	push	__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+152], eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Refs$[esp+160]
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$[esp+164], esi
	mov	DWORD PTR [esi+4], eax

; 1740 : 		_BEGIN_LOCINFO(_Lobj)

	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR __Lobj$12587[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 1741 : 			_Init(_Lobj);

	lea	ecx, DWORD PTR $T23959[esp+164]
	push	ecx
	call	__Getctype
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+12], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+16], edx
	mov	eax, DWORD PTR [eax+12]
	add	esp, 4

; 1742 : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$12587[esp+164]
	mov	DWORD PTR [esi+20], eax
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 1743 : 		if (_Table != 0)

	mov	edi, DWORD PTR __Table$[esp+160]
	test	edi, edi
	je	SHORT $LN19@ctype

; 1744 : 			{	// replace existing char to mask table
; 1745 : 			_Tidy();

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jle	SHORT $LN21@ctype
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	_free
	jmp	SHORT $LN22@ctype
$LN21@ctype:
	jge	SHORT $LN14@ctype
	mov	edx, DWORD PTR [esi+16]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
$LN22@ctype:
	add	esp, 4
$LN14@ctype:

; 1746 : 			_Ctype._Table = _Table;
; 1747 : 			_Ctype._Delfl = _Deletetable ? -1 : 0;

	mov	al, BYTE PTR __Deletetable$[esp+160]
	neg	al
	mov	DWORD PTR [esi+16], edi
	sbb	eax, eax
	mov	DWORD PTR [esi+20], eax
$LN19@ctype:

; 1748 : 			}
; 1749 : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+164]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+152]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 152				; 00000098H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ctype@D@std@@QAE@PBF_NI@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-148]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 8
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$ctype@D@std@@QAE@PBF_NI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$ctype@D@std@@QAE@PBF_NI@Z ENDP			; std::ctype<char>::ctype<char>
EXTRN	__Tolower:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1788 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[esp-4]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Tolower
	add	esp, 8

; 1789 : 		}

	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1793 : 		{	// convert [_First, _Last) in place to lower case

	push	ebx

; 1794 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1795 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@do_tolower
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_tolower:

; 1796 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	add	esi, 1
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_tolower
	pop	edi
$LN8@do_tolower:

; 1797 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1798 : 		}

	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
EXTRN	__Toupper:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1802 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	movzx	eax, BYTE PTR __Ch$[esp-4]
	add	ecx, 8
	push	ecx
	push	eax
	call	__Toupper
	add	esp, 8

; 1803 : 		}

	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1807 : 		{	// convert [_First, _Last) in place to upper case

	push	ebx

; 1808 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 1809 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN8@do_toupper
	push	edi
	lea	edi, DWORD PTR [ecx+8]
$LL3@do_toupper:

; 1810 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	edi
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	add	esi, 1
	add	esp, 8
	cmp	esi, ebx
	jne	SHORT $LL3@do_toupper
	pop	edi
$LN8@do_toupper:

; 1811 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1812 : 		}

	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1816 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[esp-4]

; 1817 : 		}

	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1823 : 		// assume there is enough space in _Dest
; 1824 : 		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, eax
	sub	edi, edx
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	push	edi
	push	eax
	mov	eax, DWORD PTR [esi+28]
	push	edx
	call	eax
	pop	edi
	pop	esi

; 1825 : 		}

	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
EXTRN	__invalid_parameter_noinfo:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Dest_size$ = 20					; size = 4
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z PROC	; std::ctype<char>::_Do_widen_s, COMDAT
; _this$ = ecx

; 1829 : 		{	// widen chars in [_First, _Last)

	push	ebx

; 1830 : 		_DEBUG_RANGE(_First, _Last);
; 1831 : 		_DEBUG_POINTER(_Dest);
; 1832 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

	mov	ebx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Dest_size$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	mov	esi, edi
	sub	esi, ebx
	cmp	ebp, esi
	jae	SHORT $LN1@Do_widen_s
	call	__invalid_parameter_noinfo
$LN1@Do_widen_s:

; 1833 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

	mov	eax, DWORD PTR __Dest$[esp+12]
	push	esi
	push	ebx
	push	ebp
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1834 : 		return (_Last);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1835 : 		}

	ret	16					; 00000010H
?_Do_widen_s@?$ctype@D@std@@MBEPBDPBD0PADI@Z ENDP	; std::ctype<char>::_Do_widen_s
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1839 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[esp-4]

; 1840 : 		}

	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1847 : 		// assume there is enough space in _Dest
; 1848 : 		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, eax
	sub	edi, edx
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Dflt$[esp+12]
	push	edi
	push	eax
	mov	eax, DWORD PTR [esi+40]
	push	edx
	call	eax
	pop	edi
	pop	esi

; 1849 : 		}

	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
__Dest_size$ = 24					; size = 4
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z PROC	; std::ctype<char>::_Do_narrow_s, COMDAT
; _this$ = ecx

; 1854 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebx

; 1855 : 		_DEBUG_RANGE(_First, _Last);
; 1856 : 		_DEBUG_POINTER(_Dest);
; 1857 : 		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));

	mov	ebx, DWORD PTR __First$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Dest_size$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	mov	esi, edi
	sub	esi, ebx
	cmp	ebp, esi
	jae	SHORT $LN1@Do_narrow_
	call	__invalid_parameter_noinfo
$LN1@Do_narrow_:

; 1858 : 		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);

	mov	eax, DWORD PTR __Dest$[esp+12]
	push	esi
	push	ebx
	push	ebp
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 1859 : 		return (_Last);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1860 : 		}

	ret	20					; 00000014H
?_Do_narrow_s@?$ctype@D@std@@MBEPBDPBD0DPADI@Z ENDP	; std::ctype<char>::_Do_narrow_s
_TEXT	ENDS
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 1768 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1769 : 		_Tidy();

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	jle	SHORT $LN14@ctype@2
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	add	esp, 4

; 1770 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
$LN14@ctype@2:

; 1769 : 		_Tidy();

	jge	SHORT $LN13@ctype@2
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN13@ctype@2:

; 1770 : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
	jle	SHORT $LN16@scalar@6
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	_free
	jmp	SHORT $LN17@scalar@6
$LN16@scalar@6:
	jge	SHORT $LN6@scalar@6
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
$LN17@scalar@6:
	add	esp, 4
$LN6@scalar@6:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN15@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T24064 = 8						; size = 4
__Ppf$ = 8						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z PROC	; std::ctype<char>::_Getcat, COMDAT

; 1758 : 		{	// construct from specified locale

	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax

; 1759 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[esp+16]
	test	esi, esi
	je	SHORT $LN8@Getcat
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN8@Getcat

; 1760 : 			*_Ppf = _NEW_CRT ctype<_Elem>;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24064[esp+16], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN4@Getcat
	push	0
	push	0
	push	0
	mov	ecx, eax
	call	??0?$ctype@D@std@@QAE@PBF_NI@Z		; std::ctype<char>::ctype<char>
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	eax, eax
$LN5@Getcat:
	mov	DWORD PTR [esi], eax
$LN8@Getcat:

; 1761 : 		return (_X_CTYPE);

	mov	eax, 2

; 1762 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T24064[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP	; std::ctype<char>::_Getcat
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	__TI3?AVfailure@ios_base@std@@
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	__CTA3?AVfailure@ios_base@std@@
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA3?AVfailure@ios_base@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z40
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT __TI3?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI3?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?clear@ios_base@std@@QAEXH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2
__ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?clear@ios_base@std@@QAEXH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T24080 = -148						; size = 40
$T24078 = -148						; size = 40
$T24081 = -108						; size = 28
$T24079 = -108						; size = 28
$T24082 = -80						; size = 40
$T24083 = -40						; size = 28
__$EHRec$ = -12						; size = 12
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 273  :         {	// set state, possibly reraise exception

	push	-1
	push	__ehhandler$?clear@ios_base@std@@QAEXH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, eax

; 274  :         _Mystate = (iostate)(_State & _Statmask);

	mov	eax, DWORD PTR __State$[esp+148]
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+8], eax

; 275  :         if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+12]
	and	ecx, eax
	je	$LN1@clear

; 276  :             ;
; 277  :         else if (_Reraise)

	cmp	BYTE PTR __Reraise$[esp+148], 0
	je	SHORT $LN6@clear

; 278  :             _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN6@clear:

; 279  :         else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN4@clear

; 280  :             _THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	lea	ecx, DWORD PTR $T24079[esp+156]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T24079[esp+152]
	push	eax
	lea	ecx, DWORD PTR $T24078[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], 0
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	ecx, DWORD PTR $T24078[esp+156]
	push	ecx
	mov	DWORD PTR $T24078[esp+160], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN4@clear:

; 281  :         else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN2@clear

; 282  :             _THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	lea	ecx, DWORD PTR $T24081[esp+156]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	edx, DWORD PTR $T24081[esp+152]
	push	edx
	lea	ecx, DWORD PTR $T24080[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], 1
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T24080[esp+156]
	push	eax
	mov	DWORD PTR $T24080[esp+160], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN2@clear:

; 283  :         else
; 284  :             _THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	lea	ecx, DWORD PTR $T24083[esp+156]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T24083[esp+152]
	push	ecx
	lea	ecx, DWORD PTR $T24082[esp+156]
	mov	DWORD PTR __$EHRec$[esp+164], 2
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI3?AVfailure@ios_base@std@@
	lea	edx, DWORD PTR $T24082[esp+156]
	push	edx
	mov	DWORD PTR $T24082[esp+160], OFFSET ??_7failure@ios_base@std@@6B@
	call	__CxxThrowException@8
$LN1@clear:

; 285  :         }

	mov	ecx, DWORD PTR __$EHRec$[esp+152]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	add	esp, 148				; 00000094H
	ret	8
$LN24@clear:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$0:
	lea	ecx, DWORD PTR $T24079[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$1:
	lea	ecx, DWORD PTR $T24081[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?clear@ios_base@std@@QAEXH_N@Z$2:
	lea	ecx, DWORD PTR $T24083[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?clear@ios_base@std@@QAEXH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-136]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@ios_base@std@@QAEXH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
; Function compile flags: /Ogtpy
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0runtime_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 43   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 44   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+40], 0
	mov	eax, DWORD PTR __State$[esp-4]
	jne	SHORT $LN4@clear@2
	or	eax, 4
$LN4@clear@2:
	mov	DWORD PTR __State$[esp-4], eax
	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$18287 = -36					; size = 4
__Lock$24124 = -32					; size = 4
__Lock$18286 = -28					; size = 4
$T24116 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$18286[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __$EHRec$[esp+60], 0
	mov	DWORD PTR __Psave$18287[esp+52], ebx
	jne	SHORT $LN11@use_facet
	push	0
	lea	ecx, DWORD PTR __Lock$24124[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, 0 ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:
	lea	ecx, DWORD PTR __Lock$24124[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+48]
	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	mov	eax, DWORD PTR [eax]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]
	test	esi, esi
	jne	SHORT $LN24@use_facet
$LN26@use_facet:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN27@use_facet
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+edi*4]
$LN16@use_facet:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN24@use_facet
$LN27@use_facet:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN24@use_facet

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

$LN20@use_facet:
	xor	esi, esi
	jmp	SHORT $LN26@use_facet
$LN4@use_facet:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$18287[esp+52]
	push	eax
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T24116[esp+56]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T24116[esp+56]
	push	ecx
	call	__CxxThrowException@8
$LN2@use_facet:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$18287[esp+52]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN24@use_facet:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$18286[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN29@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$18286[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
_this$GSCopy$ = -136					; size = 4
__Lobj$18714 = -132					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 862  : 		{	// construct from current locale

	push	-1
	push	__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Refs$[esp+140]
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$[esp+144], esi
	mov	DWORD PTR [esi+4], eax

; 863  : 		_BEGIN_LOCINFO(_Lobj)

	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR __Lobj$18714[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 864  : 			_Init(_Lobj);

	call	__Getcvt

; 865  : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$18714[esp+144]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 866  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-128]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 488  : //		_DEBUG_POINTER(_First);
; 489  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[esp-4]
	movsx	ecx, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 490  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
EXTRN	_localeconv:PROC
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 125  : 		return (localeconv());

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 163  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 164  : 		}

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 168  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 169  : 		}

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
PUBLIC	?precision@ios_base@std@@QBEHXZ			; std::ios_base::precision
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBEHXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 395  : 		return (_Prec);

	mov	eax, DWORD PTR [ecx+20]

; 396  : 		}

	ret	0
?precision@ios_base@std@@QBEHXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 849  : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; Function compile flags: /Ogtpy
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1095 : 		char *_Ptr = _Fmt;
; 1096 : 		*_Ptr++ = '%';

	mov	eax, DWORD PTR __Fmt$[esp-4]
	push	ebx

; 1097 : 
; 1098 : 		if (_Flags & ios_base::showpos)

	mov	ebx, DWORD PTR __Flags$[esp]
	test	bl, 32					; 00000020H
	mov	BYTE PTR [eax], 37			; 00000025H
	lea	ecx, DWORD PTR [eax+1]
	je	SHORT $LN3@Ffmt

; 1099 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	add	ecx, 1
$LN3@Ffmt:

; 1100 : 		if (_Flags & ios_base::showpoint)

	test	bl, 16					; 00000010H
	je	SHORT $LN2@Ffmt

; 1101 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	add	ecx, 1
$LN2@Ffmt:

; 1102 : 		*_Ptr++ = '.';
; 1103 : 		*_Ptr++ = '*';	// for precision argument
; 1104 : 		if (_Spec != '\0')

	mov	dl, BYTE PTR __Spec$[esp]
	mov	BYTE PTR [ecx], 46			; 0000002eH
	add	ecx, 1
	mov	BYTE PTR [ecx], 42			; 0000002aH
	add	ecx, 1
	test	dl, dl
	je	SHORT $LN1@Ffmt

; 1105 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	BYTE PTR [ecx], dl
	add	ecx, 1
$LN1@Ffmt:

; 1106 : 
; 1107 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	and	ebx, 12288				; 00003000H
	mov	edx, ebx

; 1108 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1109 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 8192				; 00002000H
	pop	ebx
	jne	SHORT $LN6@Ffmt
	mov	dl, 102					; 00000066H
	mov	BYTE PTR [ecx], dl

; 1110 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1111 : 		return (_Fmt);
; 1112 : 		}

	ret	0
$LN6@Ffmt:

; 1108 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1109 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	edx, 4096				; 00001000H
	setne	dl
	lea	edx, DWORD PTR [edx+edx+101]
	mov	BYTE PTR [ecx], dl

; 1110 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0

; 1111 : 		return (_Fmt);
; 1112 : 		}

	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
; Function compile flags: /Ogtpy
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1237 : 		char *_Ptr = _Fmt;
; 1238 : 		*_Ptr++ = '%';

	mov	eax, DWORD PTR __Fmt$[esp-4]

; 1239 : 
; 1240 : 		if (_Flags & ios_base::showpos)

	mov	edx, DWORD PTR __Flags$[esp-4]
	test	dl, 32					; 00000020H
	mov	BYTE PTR [eax], 37			; 00000025H
	lea	ecx, DWORD PTR [eax+1]
	je	SHORT $LN4@Ifmt

; 1241 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	add	ecx, 1
$LN4@Ifmt:

; 1242 : 		if (_Flags & ios_base::showbase)

	test	dl, 8
	je	SHORT $LN3@Ifmt

; 1243 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	add	ecx, 1
$LN3@Ifmt:
	push	ebx
	push	esi
	push	edi

; 1244 : 		if (_Spec[0] != 'L')

	mov	edi, DWORD PTR __Spec$[esp+8]
	mov	bl, BYTE PTR [edi]
	cmp	bl, 76					; 0000004cH
	je	SHORT $LN2@Ifmt

; 1245 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	BYTE PTR [ecx], bl

; 1246 : 		else

	jmp	SHORT $LN11@Ifmt
$LN2@Ifmt:

; 1247 : 			{	/* change L to I64 */
; 1248 : 			*_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H
	add	ecx, 1

; 1249 : 			*_Ptr++ = '6';

	mov	BYTE PTR [ecx], 54			; 00000036H
	add	ecx, 1

; 1250 : 			*_Ptr++ = '4';

	mov	BYTE PTR [ecx], 52			; 00000034H
$LN11@Ifmt:

; 1251 : 			}
; 1252 : 
; 1253 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	esi, edx
	and	esi, 3584				; 00000e00H
	add	ecx, 1

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	pop	edi
	mov	dl, 111					; 0000006fH
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
$LN9@Ifmt:

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	esi, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	dl, BYTE PTR [edi+1]
	pop	edi
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
$LN7@Ifmt:

; 1254 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1255 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1256 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	add	dl, dl
	add	dl, dl
	add	dl, dl
	not	dl
	and	dl, 32					; 00000020H
	pop	edi
	or	dl, 88					; 00000058H
	pop	esi
	mov	BYTE PTR [ecx], dl

; 1257 : 		*_Ptr = '\0';

	mov	BYTE PTR [ecx+1], 0
	pop	ebx

; 1258 : 		return (_Fmt);
; 1259 : 		}

	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1490 : 		{	// subscript mutable sequence

	push	esi
	push	edi

; 1491 : 
; 1492 :  #if _HAS_ITERATOR_DEBUGGING
; 1493 : 		// skip debug checks if the container is initizialed with _IGNORE_MYITERLIST
; 1494 : 		if (this->_Myfirstiter != _IGNORE_MYITERLIST)
; 1495 : 			{
; 1496 : 			if (_Mysize < _Off)
; 1497 : 				{
; 1498 : 				_DEBUG_ERROR("string subscript out of range");
; 1499 : 				_SCL_SECURE_OUT_OF_RANGE;
; 1500 : 				}
; 1501 : 			}
; 1502 :  #else
; 1503 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= _Mysize);

	mov	edi, DWORD PTR __Off$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+20]
	jbe	SHORT $LN1@operator@2
	call	__invalid_parameter_noinfo
$LN1@operator@2:

; 1504 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1505 : 
; 1506 : 		return (_Myptr()[_Off]);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN6@operator@2
	mov	esi, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [esi+edi]
	pop	edi
	pop	esi

; 1507 : 		}

	ret	4

; 1504 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1505 : 
; 1506 : 		return (_Myptr()[_Off]);

$LN6@operator@2:
	lea	eax, DWORD PTR [esi+edi+4]
	pop	edi
	pop	esi

; 1507 : 		}

	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 2194 : 		{	// pretend to get designated element

	mov	eax, ecx

; 2195 : 		return (*this);
; 2196 : 		}

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 2199 : 		{	// pretend to preincrement

	mov	eax, ecx

; 2200 : 		return (*this);
; 2201 : 		}

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 60   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	jmp	edx
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
; Function compile flags: /Ogtpy
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 65   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	jmp	edx
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 171  : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 172  : 		_DELETE_CRT_VEC((void *)_Grouping);

	mov	eax, DWORD PTR [esi+8]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 173  : 		_DELETE_CRT_VEC((void *)_Falsename);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 174  : 		_DELETE_CRT_VEC((void *)_Truename);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	pop	esi

; 175  : 		}

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 1955 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[esp-4]
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 1956 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN7@Chassign
	mov	ecx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __Off$[esp-4]
	mov	BYTE PTR [ecx+edx], al

; 1959 : 		}

	ret	12					; 0000000cH

; 1956 : 			_Traits::assign(*(_Myptr() + _Off), _Ch);

$LN7@Chassign:
	mov	al, BYTE PTR __Ch$[esp-4]
	mov	edx, DWORD PTR __Off$[esp-4]
	add	ecx, 4
	mov	BYTE PTR [ecx+edx], al

; 1959 : 		}

	ret	12					; 0000000cH
$LN2@Chassign:

; 1957 : 		else
; 1958 : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $LN13@Chassign
	mov	ecx, DWORD PTR [ecx+4]
	jmp	SHORT $LN14@Chassign
$LN13@Chassign:
	add	ecx, 4
$LN14@Chassign:
	mov	edx, DWORD PTR __Off$[esp-4]
	push	eax
	movsx	eax, BYTE PTR __Ch$[esp]
	push	eax
	add	ecx, edx
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1959 : 		}

	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 583  : 	return ((_Elem)(unsigned char)_Byte);

	mov	al, BYTE PTR __Byte$[esp-4]

; 584  : 	}

	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtpy
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 604  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	esi
	push	edi

; 605  : 	size_t _Count = ::strlen(_Ptr) + 1;

	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL8@Maklocstr:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL8@Maklocstr
	sub	eax, edx
	lea	esi, DWORD PTR [eax+1]

; 606  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	esi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 607  : 
; 608  : #pragma warning(push)
; 609  : #pragma warning(disable: 6011)
; 610  : 	/* prefast noise */
; 611  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	esi, esi
	mov	ecx, eax
	jbe	SHORT $LN1@Maklocstr
	npad	3
$LL3@Maklocstr:

; 612  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	dl, BYTE PTR [edi]
	mov	BYTE PTR [ecx], dl
	sub	esi, 1
	add	ecx, 1
	add	edi, 1
	test	esi, esi
	ja	SHORT $LL3@Maklocstr
$LN1@Maklocstr:
	pop	edi
	pop	esi

; 613  : 	return (_Ptrdest);
; 614  : #pragma warning(pop)
; 615  : 	}

	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 2185 : 		{	// store element and increment

	push	esi
	mov	esi, ecx

; 2186 : 		if (_Strbuf == 0
; 2187 : 			|| traits_type::eq_int_type(_Traits::eof(),
; 2188 : 				_Strbuf->sputc(_Right)))

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN1@operator@3
	mov	eax, DWORD PTR [ecx+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator@3
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN7@operator@3
	mov	eax, edx
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	mov	cl, BYTE PTR __Right$[esp]
	mov	BYTE PTR [eax], cl
	movzx	eax, cl
	jmp	SHORT $LN8@operator@3
$LN7@operator@3:
	movzx	edx, BYTE PTR __Right$[esp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	push	edx
	call	eax
$LN8@operator@3:
	cmp	eax, -1
	jne	SHORT $LN23@operator@3
$LN1@operator@3:

; 2189 : 			_Failed = true;

	mov	BYTE PTR [esi+4], 1
$LN23@operator@3:

; 2190 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2191 : 		}

	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z	; std::numpunct<char>::_Init
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$0
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T24334 = -24						; size = 8
$T24333 = -24						; size = 8
$T24332 = -24						; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 123  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 124  : 		const lconv *_Ptr = _Lobj._Getlconv();

	call	_localeconv

; 125  : 
; 126  : 		_Grouping = 0;

	xor	ebx, ebx
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebx

; 127  : 		_Falsename = 0;

	mov	DWORD PTR [esi+16], ebx

; 128  : 		_Truename = 0;

	mov	DWORD PTR [esi+20], ebx

; 129  : 
; 130  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 131  : 		_Grouping = _MAKLOCSTR(char, _Ptr->grouping, _Lobj._Getcvt());

	call	__Getcvt
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR $T24332[ebp]
	push	eax
	push	ebx
	push	ecx
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+8], eax

; 132  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Lobj._Getcvt());

	call	__Getcvt
	lea	edx, DWORD PTR $T24333[ebp]
	push	edx
	push	ebx
	push	OFFSET ??_C@_05LAPONLG@false?$AA@
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+16], eax

; 133  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Lobj._Getcvt());

	call	__Getcvt
	lea	eax, DWORD PTR $T24334[ebp]
	push	eax
	push	ebx
	push	OFFSET ??_C@_04LOAJBDKD@true?$AA@
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], eax

; 137  : 		_CATCH_END
; 138  : 
; 139  : 		_Dp = _MAKLOCCHR(_Elem, _Ptr->decimal_point[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	ecx, DWORD PTR [edi]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [esi+12], dl

; 140  : 		_Kseparator =
; 141  : 			_MAKLOCCHR(_Elem, _Ptr->thousands_sep[0], _Lobj._Getcvt());

	call	__Getcvt
	mov	eax, DWORD PTR [edi+4]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [esi+13], cl

; 142  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z$0:

; 134  : 		_CATCH_ALL
; 135  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 136  : 		_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN29@Init:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::numpunct<char>::_Init
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; Function compile flags: /Ogtpy
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Ptr$ = 28						; size = 4
__Count$ = 32						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1314 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp

; 1315 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	ebp, DWORD PTR __Count$[esp]
	test	ebp, ebp
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+12]
	jbe	SHORT $LN1@Put
	push	ebx
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+12]
$LL3@Put:

; 1316 : 			*_Dest = *_Ptr;

	test	esi, esi
	je	SHORT $LN10@Put
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [edi]
	je	SHORT $LN16@Put
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN16@Put
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	ebx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], ebx
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	eax, DWORD PTR [esi]
	movzx	ecx, dl
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	edx
$LN17@Put:
	cmp	eax, -1
	jne	SHORT $LN2@Put
$LN10@Put:
	mov	BYTE PTR __Dest$[esp+16], 1
$LN2@Put:

; 1315 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	sub	ebp, 1
	add	edi, 1
	test	ebp, ebp
	ja	SHORT $LL3@Put
	pop	edi
	pop	ebx
$LN1@Put:

; 1317 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebp

; 1318 : 		}

	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; Function compile flags: /Ogtpy
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Ch$ = 28						; size = 1
__Count$ = 32						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1349 : 		{	// put _Count * _Ch to _Dest

	push	esi

; 1350 : 		for (; 0 < _Count; --_Count, ++_Dest)

	mov	esi, DWORD PTR __Dest$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Count$[esp+4]
	test	edi, edi
	jbe	SHORT $LN1@Rep
	push	ebx
	mov	bl, BYTE PTR __Ch$[esp+8]
$LL6@Rep:

; 1351 : 			*_Dest = _Ch;

	test	esi, esi
	je	SHORT $LN10@Rep
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN16@Rep
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [ecx], bl
	movzx	eax, bl
	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	movzx	ecx, bl
	push	ecx
	mov	ecx, esi
	call	edx
$LN17@Rep:
	cmp	eax, -1
	jne	SHORT $LN2@Rep
$LN10@Rep:
	mov	BYTE PTR __Dest$[esp+12], 1
$LN2@Rep:

; 1350 : 		for (; 0 < _Count; --_Count, ++_Dest)

	sub	edi, 1
	jne	SHORT $LL6@Rep
	pop	ebx
$LN1@Rep:

; 1352 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	edi
	mov	DWORD PTR [eax+8], esi
	pop	esi

; 1353 : 		}

	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
PUBLIC	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
; Function compile flags: /Ogtpy
;	COMDAT ?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Ptr$ = 28						; size = 4
__Count$ = 32						; size = 4
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc, COMDAT

; 1322 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest

	push	ebp

; 1323 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	ebp, DWORD PTR __Count$[esp]
	test	ebp, ebp
	push	esi
	mov	esi, DWORD PTR __Dest$[esp+12]
	jbe	SHORT $LN1@Putc
	push	ebx
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+12]
$LL3@Putc:

; 1324 : 			*_Dest = _MAKLOCCHR(_Elem, *_Ptr, _Cvt);

	test	esi, esi
	je	SHORT $LN12@Putc
	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax], 0
	mov	dl, BYTE PTR [edi]
	je	SHORT $LN18@Putc
	mov	ecx, DWORD PTR [esi+52]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN18@Putc
	mov	eax, ecx
	add	DWORD PTR [eax], -1
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [eax]
	lea	ebx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], ebx
	mov	BYTE PTR [ecx], dl
	movzx	eax, dl
	jmp	SHORT $LN19@Putc
$LN18@Putc:
	mov	eax, DWORD PTR [esi]
	movzx	ecx, dl
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	edx
$LN19@Putc:
	cmp	eax, -1
	jne	SHORT $LN2@Putc
$LN12@Putc:
	mov	BYTE PTR __Dest$[esp+16], 1
$LN2@Putc:

; 1323 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	sub	ebp, 1
	add	edi, 1
	test	ebp, ebp
	ja	SHORT $LL3@Putc
	pop	edi
	pop	ebx
$LN1@Putc:

; 1325 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp+8]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], esi
	pop	esi
	pop	ebp

; 1326 : 		}

	ret	0
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
_TEXT	ENDS
PUBLIC	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
EXTRN	_memchr:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT
$T24648 = -24						; size = 12
$T24649 = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Ptr$ = 28						; size = 4
__Count$ = 32						; size = 4
__Kseparator$ = 36					; size = 1
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped, COMDAT

; 1330 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest with commas

	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp+28]
	push	ebp
	mov	ebp, DWORD PTR __Dest$[esp+28]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+36]
$LL5@Putgrouped:

; 1331 : 		for (; ; ++_Ptr, --_Count)
; 1332 : 			{	// put field with thousands separators for NULs
; 1333 : 			const char *_Pend =
; 1334 : 				(const char *)::memchr(_Ptr, '\0', _Count);

	mov	esi, DWORD PTR __Count$[esp+36]
	push	esi
	push	0
	push	edi
	call	_memchr
	add	esp, 12					; 0000000cH

; 1335 : 			size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

	test	eax, eax
	je	SHORT $LN8@Putgrouped
	sub	eax, edi
	mov	esi, eax
$LN8@Putgrouped:

; 1336 : 
; 1337 : 			_Dest = _Putc(_Dest, _Ptr, _Groupsize);

	mov	ecx, DWORD PTR __Dest$[esp+44]
	push	esi
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
	lea	edx, DWORD PTR $T24648[esp+60]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[esp+56]
	push	edx
	push	eax
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ecx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	add	esp, 28					; 0000001cH

; 1338 : 			_Ptr += _Groupsize, _Count -= _Groupsize;

	add	edi, esi
	sub	DWORD PTR __Count$[esp+36], esi
	mov	DWORD PTR __Dest$[esp+44], ecx

; 1339 : 			if (_Count == 0)

	je	SHORT $LN12@Putgrouped

; 1340 : 				break;
; 1341 : 			if (_Kseparator != (_Elem)0)

	mov	ecx, DWORD PTR __Kseparator$[esp+36]
	test	cl, cl
	je	SHORT $LN4@Putgrouped

; 1342 : 				_Dest = _Rep(_Dest, _Kseparator, 1);

	mov	eax, DWORD PTR [eax+8]
	push	1
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, ebp
	mov	DWORD PTR [ecx], edx
	mov	edx, ebx
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[esp+56]
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T24649[esp+60]
	push	ecx
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[esp+44], eax
$LN4@Putgrouped:
	add	edi, 1
	sub	DWORD PTR __Count$[esp+36], 1
	jmp	$LL5@Putgrouped
$LN12@Putgrouped:

; 1343 : 			}
; 1344 : 		return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	eax, DWORD PTR [eax+8]
	mov	edx, ebp

; 1345 : 		}

	pop	edi
	mov	DWORD PTR [ecx], edx
	mov	edx, ebx
	pop	esi
	mov	DWORD PTR [ecx+4], edx
	pop	ebp
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
_TEXT	ENDS
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
; Function compile flags: /Ogtpy
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T24657 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 74   : 		{	// return name for false

	push	ecx

; 75   : 		return (do_falsename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	DWORD PTR $T24657[esp+12], 0
	call	edx
	mov	eax, esi
	pop	esi

; 76   : 		}

	pop	ecx
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
; Function compile flags: /Ogtpy
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T24662 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 79   : 		{	// return name for true

	push	ecx

; 80   : 		return (do_truename());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	DWORD PTR $T24662[esp+12], 0
	call	edx
	mov	eax, esi
	pop	esi

; 81   : 		}

	pop	ecx
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 952  : 		{	// append _Count * _Ch

	push	ebx

; 953  : 			if (npos - _Mysize <= _Count)

	mov	ebx, DWORD PTR __Count$[esp]
	push	esi
	or	eax, -1
	mov	esi, ecx
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	ja	SHORT $LN2@append

; 954  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@append:

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN63@append
	push	edi
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN10@append
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN10@append:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN9@append
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN66@append:
	jbe	SHORT $LN64@append

; 958  : 			{	// make room and append new stuff using assign
; 959  : 			_Chassign(_Mysize, _Count, _Ch);

	mov	edx, DWORD PTR __Ch$[esp+8]
	mov	eax, DWORD PTR [esi+20]
	push	edx
	push	ebx
	push	eax
	mov	ecx, esi
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 960  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN59@append
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 963  : 		}

	ret	8

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN9@append:
	test	edi, edi
	jne	SHORT $LN66@append
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN51@append
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 963  : 		}

	ret	8

; 955  : 
; 956  : 		size_type _Num;
; 957  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN51@append:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 963  : 		}

	ret	8

; 960  : 			_Eos(_Num);

$LN59@append:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN64@append:
	pop	edi
$LN63@append:

; 961  : 			}
; 962  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 963  : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
tv178 = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1136 : 		{	// insert _Count * _Ch at _Off

	push	ebp
	push	esi
	push	edi

; 1137 : 		if (_Mysize < _Off)

	mov	edi, DWORD PTR __Off$[esp+8]
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN3@insert

; 1138 : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN3@insert:

; 1139 : 		if (npos - _Mysize <= _Count)

	mov	ebp, DWORD PTR __Count$[esp+8]
	or	eax, -1
	sub	eax, DWORD PTR [esi+20]
	cmp	eax, ebp
	ja	SHORT $LN2@insert

; 1140 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN2@insert:

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	$LN80@insert
	push	ebx
	mov	ebx, DWORD PTR [esi+20]
	add	ebx, ebp
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN11@insert
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN11@insert:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	jae	SHORT $LN10@insert
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebx, ebx
$LN83@insert:
	jbe	$LN81@insert

; 1143 : 			{	// make room and insert new stuff
; 1144 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1145 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@insert
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR tv178[esp+12], edx
	jmp	SHORT $LN59@insert

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN10@insert:
	test	ebx, ebx
	jne	SHORT $LN83@insert
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN52@insert
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], bl
	pop	ebx
	pop	edi

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1150 : 		}

	ret	12					; 0000000cH

; 1141 : 		size_type _Num;
; 1142 : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN52@insert:
	lea	eax, DWORD PTR [esi+4]
	pop	ebx
	pop	edi
	mov	BYTE PTR [eax], 0

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1150 : 		}

	ret	12					; 0000000cH

; 1143 : 			{	// make room and insert new stuff
; 1144 : 			_Traits_helper::move_s<_Traits>(_Myptr() + _Off + _Count, _Myres - _Off - _Count,
; 1145 : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

$LN58@insert:
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR tv178[esp+12], ecx
$LN59@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN62@insert
	mov	ecx, DWORD PTR [esi+4]
	jmp	SHORT $LN63@insert
$LN62@insert:
	lea	ecx, DWORD PTR [esi+4]
$LN63@insert:
	mov	edx, DWORD PTR [esi+20]
	sub	edx, edi
	push	edx
	mov	edx, DWORD PTR tv178[esp+16]
	add	edx, edi
	sub	eax, edi
	push	edx
	sub	eax, ebp
	add	ecx, edi
	push	eax
	add	ecx, ebp
	push	ecx
	call	_memmove_s

; 1146 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

	mov	eax, DWORD PTR __Ch$[esp+28]
	add	esp, 16					; 00000010H
	push	eax
	push	ebp
	push	edi
	mov	ecx, esi
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1147 : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], ebx
	jb	SHORT $LN76@insert
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebx], 0
	pop	ebx
	pop	edi

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1150 : 		}

	ret	12					; 0000000cH

; 1147 : 			_Eos(_Num);

$LN76@insert:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebx], 0
$LN81@insert:
	pop	ebx
$LN80@insert:
	pop	edi

; 1148 : 			}
; 1149 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 1150 : 		}

	ret	12					; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T25126 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 69   : 		{	// return grouping string

	push	ecx

; 70   : 		return (do_grouping());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	DWORD PTR $T25126[esp+12], 0
	call	edx
	mov	eax, esi
	pop	esi

; 71   : 		}

	pop	ecx
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 912  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebx
	push	ebp

; 913  : 		if (_Right.size() < _Roff)

	mov	ebp, DWORD PTR __Right$[esp+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Roff$[esp+12]
	cmp	DWORD PTR [ebp+20], edi
	mov	esi, ecx
	jae	SHORT $LN5@append@2

; 914  : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@SAXXZ		; std::_String_base::_Xran
$LN5@append@2:

; 915  : 		size_type _Num = _Right.size() - _Roff;

	mov	eax, DWORD PTR [ebp+20]

; 916  : 		if (_Num < _Count)

	mov	ebx, DWORD PTR __Count$[esp+12]
	sub	eax, edi
	cmp	eax, ebx
	jae	SHORT $LN4@append@2

; 917  : 			_Count = _Num;	// trim _Count to size

	mov	ebx, eax
$LN4@append@2:

; 918  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	ecx, -1
	sub	ecx, eax
	cmp	ecx, ebx
	jbe	SHORT $LN2@append@2
	lea	edx, DWORD PTR [eax+ebx]
	cmp	edx, eax
	jae	SHORT $LN3@append@2
$LN2@append@2:

; 919  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append@2:

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebx, ebx
	jbe	$LN87@append@2
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN17@append@2
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN17@append@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN16@append@2
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN88@append@2:
	jbe	$LN87@append@2

; 922  : 			{	// make room and append new stuff
; 923  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 924  : 				_Right._Myptr() + _Roff, _Count);

	cmp	DWORD PTR [ebp+24], 16			; 00000010H
	jb	SHORT $LN64@append@2
	mov	ebp, DWORD PTR [ebp+4]
	jmp	SHORT $LN65@append@2

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN16@append@2:
	test	edi, edi
	jne	SHORT $LN88@append@2
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN58@append@2
	mov	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 928  : 		}

	ret	12					; 0000000cH

; 920  : 
; 921  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN58@append@2:
	lea	eax, DWORD PTR [esi+4]
	pop	edi
	mov	BYTE PTR [eax], 0

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 928  : 		}

	ret	12					; 0000000cH

; 922  : 			{	// make room and append new stuff
; 923  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize,
; 924  : 				_Right._Myptr() + _Roff, _Count);

$LN64@append@2:
	add	ebp, 4
$LN65@append@2:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@append@2
	mov	edx, DWORD PTR [esi+4]
	jmp	SHORT $LN69@append@2
$LN68@append@2:
	lea	edx, DWORD PTR [esi+4]
$LN69@append@2:
	mov	ecx, DWORD PTR [esi+20]
	push	ebx
	mov	ebx, DWORD PTR __Roff$[esp+16]
	add	ebp, ebx
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 925  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN82@append@2
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 928  : 		}

	ret	12					; 0000000cH

; 925  : 			_Eos(_Num);

$LN82@append@2:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN87@append@2:
	pop	edi

; 926  : 			}
; 927  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 928  : 		}

	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 995  : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR __Right$[esp-4]
	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 996  : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 931  : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebx
	push	esi
	mov	esi, ecx

; 932  : 		if (_Inside(_Ptr))

	mov	edx, DWORD PTR [esi+24]
	cmp	edx, 16					; 00000010H
	push	edi
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $LN14@append@3
	mov	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN15@append@3
$LN14@append@3:
	mov	ecx, ebx
$LN15@append@3:
	mov	eax, DWORD PTR __Ptr$[esp+8]
	cmp	eax, ecx
	jb	SHORT $LN4@append@3
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN18@append@3
	mov	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN19@append@3
$LN18@append@3:
	mov	ecx, ebx
$LN19@append@3:
	mov	edi, DWORD PTR [esi+20]
	add	edi, ecx
	cmp	edi, eax
	jbe	SHORT $LN4@append@3

; 933  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN22@append@3
	mov	ebx, DWORD PTR [ebx]
$LN22@append@3:
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	ecx
	sub	eax, ebx
	push	eax
	push	esi
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
	pop	ebx

; 944  : 		}

	ret	8
$LN4@append@3:

; 934  : 		if (npos - _Mysize <= _Count || _Mysize + _Count < _Mysize)

	mov	eax, DWORD PTR [esi+20]
	or	edx, -1
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+12]
	sub	edx, eax
	cmp	edx, ebp
	jbe	SHORT $LN2@append@3
	lea	ecx, DWORD PTR [eax+ebp]
	cmp	ecx, eax
	jae	SHORT $LN3@append@3
$LN2@append@3:

; 935  : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN3@append@3:

; 936  : 
; 937  : 		size_type _Num;
; 938  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	ebp, ebp
	jbe	SHORT $LN92@append@3
	mov	edi, DWORD PTR [esi+20]
	add	edi, ebp
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN29@append@3
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN29@append@3:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN28@append@3
	mov	edx, DWORD PTR [esi+20]
	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN95@append@3:
	jbe	SHORT $LN92@append@3

; 939  : 			{	// make room and append new stuff
; 940  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN76@append@3
	mov	edx, DWORD PTR [ebx]
	jmp	SHORT $LN77@append@3

; 936  : 
; 937  : 		size_type _Num;
; 938  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$LN28@append@3:
	test	edi, edi
	jne	SHORT $LN95@append@3
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN70@append@3
	mov	ebx, DWORD PTR [ebx]
$LN70@append@3:
	pop	ebp
	pop	edi

; 942  : 			}
; 943  : 		return (*this);

	mov	eax, esi
	pop	esi
	mov	BYTE PTR [ebx], 0
	pop	ebx

; 944  : 		}

	ret	8

; 939  : 			{	// make room and append new stuff
; 940  : 			_Traits_helper::copy_s<_Traits>(_Myptr() + _Mysize, _Myres - _Mysize, _Ptr, _Count);

$LN76@append@3:
	mov	edx, ebx
$LN77@append@3:
	mov	ecx, DWORD PTR [esi+20]
	push	ebp
	mov	ebp, DWORD PTR __Ptr$[esp+16]
	sub	eax, ecx
	push	ebp
	push	eax
	add	ecx, edx
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 941  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN90@append@3
	mov	ebx, DWORD PTR [ebx]
$LN90@append@3:
	mov	BYTE PTR [ebx+edi], 0
$LN92@append@3:
	pop	ebp
	pop	edi

; 942  : 			}
; 943  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 944  : 		}

	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\xlocinfo
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0
__ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
_this$GSCopy$ = -136					; size = 4
__Lobj$18717 = -132					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 244  : 		{	// construct from current locale

	push	-1
	push	__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Refs$[esp+140]
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$[esp+144], esi
	mov	DWORD PTR [esi+4], eax

; 245  : 		_BEGIN_LOCINFO(_Lobj)

	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR __Lobj$18717[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 246  : 			_Init(_Lobj);

	call	__Getcvt

; 247  : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$18717[esp+144]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 248  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-128]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 231  : 		}

	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN8@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z	; std::_Maklocbyte<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Char$ = 8						; size = 1
___formal$ = 12						; size = 4
??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z PROC		; std::_Maklocbyte<char>, COMDAT

; 561  : 	return ((char)(unsigned char)_Char);

	mov	al, BYTE PTR __Char$[esp-4]

; 562  : 	}

	ret	0
??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z ENDP		; std::_Maklocbyte<char>
_TEXT	ENDS
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xutility
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT
; _this$ = ecx

; 2113 : 		{	// skip to next input element

	push	esi
	mov	esi, ecx

; 2114 : 		if (_Strbuf == 0
; 2115 : 			|| traits_type::eq_int_type(traits_type::eof(),
; 2116 : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN2@Inc
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Inc
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN8@Inc
	mov	eax, edx
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN9@Inc
$LN8@Inc:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN9@Inc:
	cmp	eax, -1
	je	SHORT $LN2@Inc

; 2118 : 		else
; 2119 : 			_Got = false;

	mov	BYTE PTR [esi+8], 0
	pop	esi

; 2120 : 		}

	ret	0
$LN2@Inc:

; 2117 : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 1
	pop	esi

; 2120 : 		}

	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
; Function compile flags: /Ogtpy
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT
; _this$ = ecx

; 2123 : 		{	// peek at next input element

	push	esi
	mov	esi, ecx

; 2124 : 		int_type _Meta;
; 2125 : 		if (_Strbuf == 0
; 2126 : 			|| traits_type::eq_int_type(traits_type::eof(),
; 2127 : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN2@Peek
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Peek
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN8@Peek
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN9@Peek
$LN8@Peek:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN9@Peek:
	cmp	eax, -1
	je	SHORT $LN2@Peek

; 2128 : 			_Strbuf = 0;
; 2129 : 		else
; 2130 : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+9], al

; 2131 : 		_Got = true;

	mov	BYTE PTR [esi+8], 1
	pop	esi

; 2133 : 		}

	ret	0
$LN2@Peek:

; 2132 : 		return (_Val);

	mov	al, BYTE PTR [esi+9]
	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 1
	pop	esi

; 2133 : 		}

	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; Function compile flags: /Ogtpy
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT
; _this$ = ecx

; 2102 : 		{	// test for equality

	push	esi
	mov	esi, ecx

; 2103 : 		if (!_Got)

	cmp	BYTE PTR [esi+8], 0
	push	edi
	jne	SHORT $LN2@equal

; 2104 : 			((_Myt *)this)->_Peek();

	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN2@equal:

; 2105 : 		if (!_Right._Got)

	mov	edi, DWORD PTR __Right$[esp+4]
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN1@equal

; 2106 : 			((_Myt *)&_Right)->_Peek();

	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN1@equal:

; 2107 : 		return (_Strbuf == 0 && _Right._Strbuf == 0
; 2108 : 			|| _Strbuf != 0 && _Right._Strbuf != 0);

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN10@equal
	cmp	DWORD PTR [edi+4], eax
	je	SHORT $LN7@equal
	test	eax, eax
	je	SHORT $LN6@equal
$LN10@equal:
	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN6@equal
$LN7@equal:
	pop	edi
	mov	eax, 1
	pop	esi

; 2109 : 		}

	ret	4
$LN6@equal:
	pop	edi

; 2107 : 		return (_Strbuf == 0 && _Right._Strbuf == 0
; 2108 : 			|| _Strbuf != 0 && _Right._Strbuf != 0);

	xor	eax, eax
	pop	esi

; 2109 : 		}

	ret	4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 2068 : 		{	// return designated value

	push	esi
	mov	esi, ecx

; 2069 : 		if (!_Got)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN4@operator@4

; 2070 : 			((_Myt *)this)->_Peek();

	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN4@operator@4:

; 2071 : 
; 2072 :  #if _HAS_ITERATOR_DEBUGGING
; 2073 : 		if (_Strbuf == 0)
; 2074 : 			_DEBUG_ERROR("istreambuf_iterator is not dereferencable");
; 2075 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2076 : 
; 2077 : 		return (_Val);

	mov	al, BYTE PTR [esi+9]
	pop	esi

; 2078 : 		}

	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 2081 : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 2082 : 
; 2083 :  #if _HAS_ITERATOR_DEBUGGING
; 2084 : 		if (_Strbuf == 0)
; 2085 : 			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
; 2086 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2087 : 
; 2088 : 		_Inc();

	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc

; 2089 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2090 : 		}

	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 2146 : 	{	// test for istreambuf_iterator equality

	push	esi
	push	edi

; 2147 : 	return (_Left.equal(_Right));

	mov	edi, DWORD PTR __Left$[esp+4]
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN4@operator@5
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN4@operator@5:
	mov	esi, DWORD PTR __Right$[esp+4]
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN3@operator@5
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN3@operator@5:
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN12@operator@5
	cmp	DWORD PTR [esi+4], eax
	je	SHORT $LN9@operator@5
	test	eax, eax
	je	SHORT $LN8@operator@5
$LN12@operator@5:
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN8@operator@5
$LN9@operator@5:
	pop	edi
	mov	eax, 1
	pop	esi

; 2148 : 	}

	ret	0

; 2147 : 	return (_Left.equal(_Right));

$LN8@operator@5:
	pop	edi
	xor	eax, eax
	pop	esi

; 2148 : 	}

	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 2155 : 	{	// test for istreambuf_iterator inequality

	push	esi
	push	edi

; 2156 : 	return (!(_Left == _Right));

	mov	edi, DWORD PTR __Left$[esp+4]
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN6@operator@6
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN6@operator@6:
	mov	esi, DWORD PTR __Right$[esp+4]
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN5@operator@6
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN5@operator@6:
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN14@operator@6
	cmp	DWORD PTR [esi+4], eax
	je	SHORT $LN11@operator@6
	test	eax, eax
	je	SHORT $LN10@operator@6
$LN14@operator@6:
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN10@operator@6
$LN11@operator@6:
	mov	eax, 1
	xor	ecx, ecx
	test	al, al
	sete	cl
	pop	edi
	mov	al, cl
	pop	esi

; 2157 : 	}

	ret	0

; 2156 : 	return (!(_Left == _Right));

$LN10@operator@6:
	xor	eax, eax
	xor	ecx, ecx
	test	al, al
	sete	cl
	pop	edi
	mov	al, cl
	pop	esi

; 2157 : 	}

	ret	0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1036 : 		{	// assign _Count * _Ch

	push	esi
	push	edi

; 1037 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[esp+4]
	cmp	edi, -1
	mov	esi, ecx
	jne	SHORT $LN2@assign@4

; 1038 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen

; 1039 : 
; 1040 : 		if (_Grow(_Count))

	jmp	SHORT $LN63@assign@4
$LN2@assign@4:
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN10@assign@4
$LN63@assign@4:
	call	?_Xlen@_String_base@std@@SAXXZ		; std::_String_base::_Xlen
$LN10@assign@4:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	jae	SHORT $LN9@assign@4
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
$LN65@assign@4:
	jbe	SHORT $LN64@assign@4

; 1041 : 			{	// make room and assign new stuff
; 1042 : 			_Chassign(0, _Count, _Ch);

	mov	ecx, DWORD PTR __Ch$[esp+4]
	push	ecx
	push	edi
	push	0
	mov	ecx, esi
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 1043 : 			_Eos(_Count);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN59@assign@4
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
	pop	edi

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1046 : 		}

	ret	8

; 1039 : 
; 1040 : 		if (_Grow(_Count))

$LN9@assign@4:
	test	edi, edi
	jne	SHORT $LN65@assign@4
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $LN51@assign@4
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	pop	edi

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1046 : 		}

	ret	8

; 1039 : 
; 1040 : 		if (_Grow(_Count))

$LN51@assign@4:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	pop	edi

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1046 : 		}

	ret	8

; 1043 : 			_Eos(_Count);

$LN59@assign@4:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+edi], 0
$LN64@assign@4:
	pop	edi

; 1044 : 			}
; 1045 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1046 : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 645  : 		{	// construct from _Count * _Ch

	push	esi
	mov	esi, ecx

; 646  : 		_Tidy();
; 647  : 		assign(_Count, _Ch);

	mov	ecx, DWORD PTR __Count$[esp]
	xor	eax, eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Ch$[esp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 648  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 902  : 		return (append((size_type)1, _Ch));

	mov	eax, DWORD PTR __Ch$[esp-4]
	push	eax
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 903  : 		}

	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 907  : 		return (append(_Right, 0, npos));

	mov	eax, DWORD PTR __Right$[esp-4]
	push	-1
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 908  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	__Last$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0
__ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
xdata$x	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT
__Prefix$18611 = -57					; size = 1
__Column$18607 = -56					; size = 4
__Last$GSCopy$ = -52					; size = 4
__Ans$ = -48						; size = 4
__Str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z PROC ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 513  : 	{	// find field at _Ptr that matches longest in [_First, _Last)

	push	-1
	push	__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+60], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, eax

; 514  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	ecx, DWORD PTR __Ptr$[esp+76]
	mov	dl, BYTE PTR [ecx]
	test	dl, dl

; 518  : 
; 519  : 	int _Ans = -2;	// no candidates so far

	mov	eax, DWORD PTR __Last$[esp+76]
	mov	ebp, DWORD PTR __First$[esp+76]
	mov	esi, DWORD PTR __Numfields$[esp+76]
	mov	DWORD PTR __Last$GSCopy$[esp+80], eax
	je	SHORT $LN21@Getloctxt

; 517  : 	string _Str(_Numfields, '\0');	// one column counter for each field

	mov	al, dl
	npad	2
$LL23@Getloctxt:

; 515  : 		if (_Ptr[_Off] == _Ptr[0])

	cmp	al, dl
	jne	SHORT $LN22@Getloctxt

; 516  : 			++_Numfields;	// add fields with leading mark to initial count

	add	esi, 1
$LN22@Getloctxt:

; 514  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	al, BYTE PTR [ecx+1]
	add	ecx, 1
	test	al, al
	jne	SHORT $LL23@Getloctxt

; 516  : 			++_Numfields;	// add fields with leading mark to initial count

	mov	DWORD PTR __Numfields$[esp+76], esi
$LN21@Getloctxt:

; 517  : 	string _Str(_Numfields, '\0');	// one column counter for each field

	xor	ebx, ebx
	push	ebx
	push	esi
	lea	ecx, DWORD PTR __Str$[esp+88]
	mov	DWORD PTR __Str$[esp+112], 15		; 0000000fH
	mov	DWORD PTR __Str$[esp+108], ebx
	mov	BYTE PTR __Str$[esp+92], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+88], ebx

; 518  : 
; 519  : 	int _Ans = -2;	// no candidates so far

	mov	DWORD PTR __Ans$[esp+80], -2		; fffffffeH

; 520  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	mov	DWORD PTR __Column$18607[esp+80], 1
$LL19@Getloctxt:

; 521  : 		{	// test each element against all viable fields
; 522  : 		bool  _Prefix = false;	// seen at least one valid prefix
; 523  : 		size_t _Off = 0;	// offset into fields

	xor	edi, edi

; 524  : 		size_t _Field = 0;	// current field number

	xor	esi, esi

; 525  : 
; 526  : 		for (; _Field < _Numfields; ++_Field)

	cmp	DWORD PTR __Numfields$[esp+76], ebx
	mov	BYTE PTR __Prefix$18611[esp+80], 0
	jbe	$LN204@Getloctxt
	npad	7
$LL16@Getloctxt:

; 527  : 			{	// test element at _Column in field _Field
; 528  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)

	mov	edx, DWORD PTR __Ptr$[esp+76]
	mov	al, BYTE PTR [edi+edx]
	test	al, al
	je	SHORT $LN11@Getloctxt
	mov	cl, BYTE PTR [edx]
	npad	3
$LL13@Getloctxt:
	cmp	al, cl
	je	SHORT $LN11@Getloctxt
	mov	al, BYTE PTR [edi+edx+1]
	add	edi, 1
	test	al, al
	jne	SHORT $LL13@Getloctxt
$LN11@Getloctxt:

; 529  : 				;	// find beginning of field
; 530  : 
; 531  : 			if (_Str[_Field] != '\0')

	cmp	esi, DWORD PTR __Str$[esp+100]
	jbe	SHORT $LN86@Getloctxt
	call	__invalid_parameter_noinfo
$LN86@Getloctxt:
	cmp	DWORD PTR __Str$[esp+104], 16		; 00000010H
	mov	eax, DWORD PTR __Str$[esp+84]
	jae	SHORT $LN92@Getloctxt
	lea	eax, DWORD PTR __Str$[esp+84]
$LN92@Getloctxt:
	cmp	BYTE PTR [eax+esi], 0
	je	SHORT $LN10@Getloctxt

; 532  : 				_Off += _Str[_Field];	// skip tested columns in field

	cmp	esi, DWORD PTR __Str$[esp+100]
	jbe	SHORT $LN93@Getloctxt
	call	__invalid_parameter_noinfo
$LN93@Getloctxt:
	cmp	DWORD PTR __Str$[esp+104], 16		; 00000010H
	mov	eax, DWORD PTR __Str$[esp+84]
	jae	SHORT $LN99@Getloctxt
	lea	eax, DWORD PTR __Str$[esp+84]
$LN99@Getloctxt:
	movsx	ecx, BYTE PTR [eax+esi]
	add	edi, ecx

; 533  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]

	jmp	$LN15@Getloctxt
$LN10@Getloctxt:

; 534  : 				|| _Ptr[_Off] == (_Elem)0)

	mov	edx, DWORD PTR __Column$18607[esp+80]
	mov	ecx, DWORD PTR __Ptr$[esp+76]
	add	edi, edx
	mov	al, BYTE PTR [edi+ecx]
	cmp	al, BYTE PTR [ecx]
	je	$LN7@Getloctxt
	test	al, al
	je	$LN7@Getloctxt

; 539  : 				}
; 540  : 			else if (_First == _Last || _Ptr[_Off] != *_First)

	cmp	BYTE PTR [ebp+8], 0
	jne	SHORT $LN120@Getloctxt
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	SHORT $LN118@Getloctxt
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN124@Getloctxt
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN124@Getloctxt
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN125@Getloctxt
$LN124@Getloctxt:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN125@Getloctxt:
	cmp	eax, -1
	je	SHORT $LN118@Getloctxt
	mov	BYTE PTR [ebp+9], al
	jmp	SHORT $LN117@Getloctxt
$LN118@Getloctxt:
	mov	DWORD PTR [ebp+4], ebx
$LN117@Getloctxt:
	mov	BYTE PTR [ebp+8], 1
$LN120@Getloctxt:
	mov	edx, DWORD PTR __Last$GSCopy$[esp+80]
	cmp	BYTE PTR [edx+8], 0
	jne	SHORT $LN143@Getloctxt
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, ebx
	je	SHORT $LN141@Getloctxt
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN147@Getloctxt
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN147@Getloctxt
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN148@Getloctxt
$LN147@Getloctxt:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN148@Getloctxt:
	cmp	eax, -1
	je	SHORT $LN141@Getloctxt
	mov	edx, DWORD PTR __Last$GSCopy$[esp+80]
	mov	BYTE PTR [edx+9], al
	jmp	SHORT $LN140@Getloctxt
$LN141@Getloctxt:
	mov	edx, DWORD PTR __Last$GSCopy$[esp+80]
	mov	DWORD PTR [edx+4], ebx
$LN140@Getloctxt:
	mov	BYTE PTR [edx+8], 1
$LN143@Getloctxt:
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	jne	SHORT $LN298@Getloctxt
	cmp	DWORD PTR [edx+4], ebx
	je	SHORT $LN4@Getloctxt
	cmp	ecx, ebx
	je	SHORT $LN114@Getloctxt
$LN298@Getloctxt:
	cmp	DWORD PTR [edx+4], ebx
	jne	SHORT $LN4@Getloctxt
$LN114@Getloctxt:
	cmp	BYTE PTR [ebp+8], 0
	jne	SHORT $LN169@Getloctxt
	cmp	ecx, ebx
	je	SHORT $LN167@Getloctxt
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN173@Getloctxt
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN173@Getloctxt
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN174@Getloctxt
$LN173@Getloctxt:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN174@Getloctxt:
	cmp	eax, -1
	je	SHORT $LN167@Getloctxt
	mov	BYTE PTR [ebp+9], al
	jmp	SHORT $LN166@Getloctxt
$LN167@Getloctxt:
	mov	DWORD PTR [ebp+4], ebx
$LN166@Getloctxt:
	mov	BYTE PTR [ebp+8], 1
$LN169@Getloctxt:
	mov	ecx, DWORD PTR __Ptr$[esp+76]
	mov	dl, BYTE PTR [edi+ecx]
	cmp	dl, BYTE PTR [ebp+9]
	jne	SHORT $LN4@Getloctxt

; 544  : 				_Prefix = true;	// still a valid prefix

	mov	BYTE PTR __Prefix$18611[esp+80], 1
	jmp	SHORT $LN15@Getloctxt
$LN4@Getloctxt:

; 541  : 				_Str[_Field] = (char)(_Column < 127
; 542  : 					? _Column : 127);	// no match, just save skip count

	cmp	DWORD PTR __Column$18607[esp+80], 127	; 0000007fH
	mov	ebx, DWORD PTR __Column$18607[esp+80]
	jb	SHORT $LN29@Getloctxt
	mov	ebx, 127				; 0000007fH
$LN29@Getloctxt:
	cmp	esi, DWORD PTR __Str$[esp+100]
	jbe	SHORT $LN189@Getloctxt
	call	__invalid_parameter_noinfo
$LN189@Getloctxt:
	cmp	DWORD PTR __Str$[esp+104], 16		; 00000010H
	mov	eax, DWORD PTR __Str$[esp+84]
	jae	SHORT $LN195@Getloctxt
	lea	eax, DWORD PTR __Str$[esp+84]

; 543  : 			else

	jmp	SHORT $LN195@Getloctxt
$LN7@Getloctxt:

; 535  : 				{	// matched all of field, save as possible answer
; 536  : 				_Str[_Field] = (char)(_Column < 127
; 537  : 					? _Column : 127);	// save skip count if small enough

	cmp	edx, 127				; 0000007fH
	mov	ebx, DWORD PTR __Column$18607[esp+80]
	jb	SHORT $LN27@Getloctxt
	mov	ebx, 127				; 0000007fH
$LN27@Getloctxt:
	cmp	esi, DWORD PTR __Str$[esp+100]
	jbe	SHORT $LN100@Getloctxt
	call	__invalid_parameter_noinfo
$LN100@Getloctxt:
	cmp	DWORD PTR __Str$[esp+104], 16		; 00000010H
	mov	eax, DWORD PTR __Str$[esp+84]
	jae	SHORT $LN106@Getloctxt
	lea	eax, DWORD PTR __Str$[esp+84]
$LN106@Getloctxt:

; 538  : 				_Ans = (int)_Field;	// save answer

	mov	DWORD PTR __Ans$[esp+80], esi

; 541  : 				_Str[_Field] = (char)(_Column < 127
; 542  : 					? _Column : 127);	// no match, just save skip count

$LN195@Getloctxt:
	mov	BYTE PTR [eax+esi], bl
	xor	ebx, ebx
$LN15@Getloctxt:
	add	esi, 1
	cmp	esi, DWORD PTR __Numfields$[esp+76]
	jb	$LL16@Getloctxt

; 545  : 			}
; 546  : 
; 547  : 		if (!_Prefix || _First == _Last)

	cmp	BYTE PTR __Prefix$18611[esp+80], 0
	je	$LN204@Getloctxt
	cmp	BYTE PTR [ebp+8], 0
	jne	SHORT $LN209@Getloctxt
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	SHORT $LN207@Getloctxt
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN213@Getloctxt
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN213@Getloctxt
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN214@Getloctxt
$LN213@Getloctxt:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN214@Getloctxt:
	cmp	eax, -1
	je	SHORT $LN207@Getloctxt
	mov	BYTE PTR [ebp+9], al
	jmp	SHORT $LN206@Getloctxt
$LN207@Getloctxt:
	mov	DWORD PTR [ebp+4], ebx
$LN206@Getloctxt:
	mov	BYTE PTR [ebp+8], 1
$LN209@Getloctxt:
	mov	edx, DWORD PTR __Last$GSCopy$[esp+80]
	cmp	BYTE PTR [edx+8], 0
	jne	SHORT $LN232@Getloctxt
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, ebx
	je	SHORT $LN230@Getloctxt
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN236@Getloctxt
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN236@Getloctxt
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN237@Getloctxt
$LN236@Getloctxt:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN237@Getloctxt:
	cmp	eax, -1
	mov	edx, DWORD PTR __Last$GSCopy$[esp+80]
	je	SHORT $LN230@Getloctxt
	mov	BYTE PTR [edx+9], al
	jmp	SHORT $LN229@Getloctxt
$LN230@Getloctxt:
	mov	DWORD PTR [edx+4], ebx
$LN229@Getloctxt:
	mov	BYTE PTR [edx+8], 1
$LN232@Getloctxt:
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	jne	SHORT $LN300@Getloctxt
	cmp	DWORD PTR [edx+4], ebx
	je	SHORT $LN204@Getloctxt
	cmp	ecx, ebx
	je	SHORT $LN203@Getloctxt
$LN300@Getloctxt:
	cmp	DWORD PTR [edx+4], ebx
	jne	SHORT $LN204@Getloctxt
$LN203@Getloctxt:
	add	DWORD PTR __Column$18607[esp+80], 1
	cmp	ecx, ebx
	je	SHORT $LN66@Getloctxt
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN72@Getloctxt
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN72@Getloctxt
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN73@Getloctxt

; 520  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

$LN72@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN73@Getloctxt:
	cmp	eax, -1
	je	SHORT $LN66@Getloctxt
	mov	BYTE PTR [ebp+8], 0
	mov	DWORD PTR __Ans$[esp+80], -1
	jmp	$LL19@Getloctxt
$LN66@Getloctxt:
	mov	DWORD PTR [ebp+4], ebx
	mov	BYTE PTR [ebp+8], 1
	mov	DWORD PTR __Ans$[esp+80], -1
	jmp	$LL19@Getloctxt

; 545  : 			}
; 546  : 
; 547  : 		if (!_Prefix || _First == _Last)

$LN204@Getloctxt:

; 548  : 			break;	// no pending prefixes or no input, give up
; 549  : 		}
; 550  : 	return (_Ans);	// return field number or negative value on failure

	cmp	DWORD PTR __Str$[esp+104], 16		; 00000010H
	jb	SHORT $LN288@Getloctxt
	mov	eax, DWORD PTR __Str$[esp+84]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN288@Getloctxt:
	mov	eax, DWORD PTR __Ans$[esp+80]

; 551  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-64]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ENDP ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 892  : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[esp-4]
	push	-1
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 893  : 		}

	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??0?$numpunct@D@std@@QAE@I@Z			; std::numpunct<char>::numpunct<char>
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$1
__ehfuncinfo$??0?$numpunct@D@std@@QAE@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT
_this$GSCopy$ = -136					; size = 4
__Lobj$18720 = -132					; size = 116
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$numpunct@D@std@@QAE@I@Z PROC			; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 85   : 		{	// construct from current locale

	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Refs$[esp+140]
	mov	esi, ecx
	mov	DWORD PTR _this$GSCopy$[esp+144], esi
	mov	DWORD PTR [esi+4], eax

; 86   : 		_BEGIN_LOCINFO(_Lobj)

	push	OFFSET ??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR __Lobj$18720[esp+148]
	mov	DWORD PTR __$EHRec$[esp+156], 0
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo

; 87   : 			_Init(_Lobj);

	lea	ecx, DWORD PTR __Lobj$18720[esp+144]
	push	ecx
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[esp+156], 1
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ; std::numpunct<char>::_Init

; 88   : 			if (_Kseparator == 0)

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN1@numpunct

; 89   : 				_Kseparator =	// NB: differs from "C" locale
; 90   : 					_MAKLOCCHR(_Elem, ',', _Lobj._Getcvt());

	call	__Getcvt
	mov	BYTE PTR [esi+13], 44			; 0000002cH
$LN1@numpunct:

; 91   : 		_END_LOCINFO()

	lea	ecx, DWORD PTR __Lobj$18720[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 0
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 92   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__unwindfunclet$??0?$numpunct@D@std@@QAE@I@Z$1:
	lea	ecx, DWORD PTR __Lobj$18720[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
__ehhandler$??0?$numpunct@D@std@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-128]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@I@Z ENDP			; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtpy
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 146  : 		return (_Dp);

	mov	al, BYTE PTR [ecx+12]

; 147  : 		}

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 151  : 		return (_Kseparator);

	mov	al, BYTE PTR [ecx+13]

; 152  : 		}

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		_Tidy();

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 111  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	pop	esi
	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi], OFFSET ??_7facet@locale@std@@6B@
	je	SHORT $LN10@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@9:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T27269 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 155  : 		{	// return grouping string

	push	ecx

; 156  : 		return (string(_Grouping));

	mov	ecx, DWORD PTR [ecx+8]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T27269[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_groupin:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_groupin
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 157  : 		}

	pop	ecx
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T27419 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 160  : 		{	// return name for false

	push	ecx

; 161  : 		return (string_type(_Falsename));

	mov	ecx, DWORD PTR [ecx+16]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T27419[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_falsena:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_falsena
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 162  : 		}

	pop	ecx
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T27569 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 165  : 		{	// return name for true

	push	ecx

; 166  : 		return (string_type(_Truename));

	mov	ecx, DWORD PTR [ecx+20]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR $T27569[esp+12], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL41@do_truenam:
	mov	dl, BYTE PTR [eax]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL41@do_truenam
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	mov	eax, esi
	pop	esi

; 167  : 		}

	pop	ecx
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 54   : 		if (_State != goodbit)

	mov	edx, DWORD PTR __State$[esp-4]
	test	edx, edx
	je	SHORT $LN6@setstate

; 55   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN8@setstate
	or	eax, 4
$LN8@setstate:
	mov	DWORD PTR __State$[esp-4], eax
	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN6@setstate:

; 56   : 		}

	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T27734 = 8						; size = 4
__Ppf$ = 8						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 838  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax

; 839  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[esp+16]
	test	esi, esi
	je	SHORT $LN8@Getcat@2
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN8@Getcat@2

; 840  : 			*_Ppf = _NEW_CRT num_put<_Elem, _OutIt>;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27734[esp+16], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN4@Getcat@2
	push	0
	mov	ecx, eax
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	jmp	SHORT $LN5@Getcat@2
$LN4@Getcat@2:
	xor	eax, eax
$LN5@Getcat@2:
	mov	DWORD PTR [esi], eax
$LN8@Getcat@2:

; 841  : 		return (_X_NUMERIC);

	mov	eax, 4

; 842  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T27734[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T27749 = 8						; size = 4
__Ppf$ = 8						; size = 4
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 220  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax

; 221  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[esp+16]
	test	esi, esi
	je	SHORT $LN8@Getcat@3
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN8@Getcat@3

; 222  : 			*_Ppf = _NEW_CRT num_get<_Elem, _InIt>;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27749[esp+16], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN4@Getcat@3
	push	0
	mov	ecx, eax
	call	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	jmp	SHORT $LN5@Getcat@3
$LN4@Getcat@3:
	xor	eax, eax
$LN5@Getcat@3:
	mov	DWORD PTR [esi], eax
$LN8@Getcat@3:

; 223  : 		return (_X_NUMERIC);

	mov	eax, 4

; 224  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T27749[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z$0
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T27764 = 8						; size = 4
__Ppf$ = 8						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 101  : 		{	// return locale category mask and construct standard facet

	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, eax

; 102  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[esp+16]
	test	esi, esi
	je	SHORT $LN8@Getcat@4
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN8@Getcat@4

; 103  : 			*_Ppf = _NEW_CRT numpunct<_Elem>;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27764[esp+16], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	je	SHORT $LN4@Getcat@4
	push	0
	mov	ecx, eax
	call	??0?$numpunct@D@std@@QAE@I@Z		; std::numpunct<char>::numpunct<char>
	jmp	SHORT $LN5@Getcat@4
$LN4@Getcat@4:
	xor	eax, eax
$LN5@Getcat@4:
	mov	DWORD PTR [esi], eax
$LN8@Getcat@4:

; 104  : 		return (_X_NUMERIC);

	mov	eax, 4

; 105  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z$0:
	mov	eax, DWORD PTR $T27764[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-4]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::numpunct<char>::_Getcat
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 547  : 		{	// flush output stream

	push	esi
	mov	esi, ecx

; 548  : 		ios_base::iostate _State = ios_base::goodbit;
; 549  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	lea	eax, DWORD PTR [ecx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN1@flush
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN1@flush

; 550  : 			_State |= ios_base::badbit;	// sync failed

	mov	edi, 4
$LN1@flush:

; 551  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN21@flush
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN19@flush
	or	eax, 4
$LN19@flush:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN21@flush:
	pop	edi

; 552  : 		return (*this);

	mov	eax, esi
	pop	esi

; 553  : 		}

	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$9
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
xdata$x	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T27820 = 8						; size = 4
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 92   : 		{	// test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 93   : 		if (ios_base::good())

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+8]
	add	ecx, esi
	test	eax, eax
	jne	$LN1@Ipfx

; 94   : 			{	// state okay, flush tied stream and skip whitespace
; 95   : 			if (_Myios::tie() != 0)

	mov	ecx, DWORD PTR [ecx+44]
	test	ecx, ecx
	je	SHORT $LN10@Ipfx

; 96   : 				_Myios::tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN10@Ipfx:

; 97   : 
; 98   : 			if (!_Noskip && ios_base::flags() & ios_base::skipws)

	cmp	BYTE PTR __Noskip$[ebp], 0
	jne	$LN17@Ipfx
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edx+esi+16]
	test	cl, 1
	je	$LN17@Ipfx

; 99   : 				{	// skip whitespace
; 100  : 				const _Ctype& _Ctype_fac = _USE(ios_base::getloc(), _Ctype);

	lea	ecx, DWORD PTR $T27820[ebp]
	push	ecx
	mov	ecx, edx
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	lea	ecx, DWORD PTR $T27820[ebp]
	mov	edi, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 101  : 
; 102  : 				_TRY_IO_BEGIN
; 103  : 				int_type _Meta = _Myios::rdbuf()->sgetc();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+40]
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	je	SHORT $LN33@Ipfx
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN33@Ipfx
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LL110@Ipfx
$LN33@Ipfx:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	call	edx
$LL110@Ipfx:

; 106  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	cmp	eax, -1
	jne	SHORT $LN4@Ipfx

; 107  : 						{	// end of file, quit
; 108  : 						_Myios::setstate(ios_base::eofbit);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+8]
	add	ecx, esi
	or	eax, 1
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN56@Ipfx
	or	eax, 4
$LN56@Ipfx:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 109  : 						break;

	jmp	SHORT $LN5@Ipfx
$LN4@Ipfx:

; 110  : 						}
; 111  : 					else if (!_Ctype_fac.is(_Ctype::space,
; 112  : 						_Traits::to_char_type(_Meta)))

	mov	edx, DWORD PTR [edi+16]
	movzx	ecx, al
	test	BYTE PTR [edx+ecx*2], 72		; 00000048H
	jne	SHORT $LN6@Ipfx
$LN5@Ipfx:

; 113  : 						break;	// not whitespace, quit
; 114  : 				_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 115  : 				}
; 116  : 
; 117  : 			if (ios_base::good())

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN1@Ipfx

; 118  : 				return (true);

	mov	al, 1

; 122  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@Ipfx:

; 104  : 
; 105  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi+40]
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	jmp	SHORT $LL110@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 113  : 						break;	// not whitespace, quit
; 114  : 				_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN69@Ipfx
	or	ecx, 4
$LN69@Ipfx:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN78@Ipfx
	mov	eax, $LN18@Ipfx
	ret	0
$LN18@Ipfx:
	mov	esi, DWORD PTR _this$[ebp]
	jmp	SHORT $LN17@Ipfx
$LN78@Ipfx:
	push	0
	push	0
	call	__CxxThrowException@8
$LN1@Ipfx:

; 119  : 			}
; 120  : 		_Myios::setstate(ios_base::failbit);

	mov	eax, DWORD PTR [ecx+8]
	or	eax, 2
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN107@Ipfx
	or	eax, 4
$LN107@Ipfx:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 121  : 		return (false);

	xor	al, al

; 122  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN116@Ipfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
	lea	ecx, DWORD PTR $T27820[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 93   : 			{	// construct locking and testing stream

	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[esp+28], edi
	mov	esi, DWORD PTR __Ostr$[esp+24]
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+40]
	test	eax, eax
	je	SHORT $LN12@sentry@2
	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN12@sentry@2:

; 94   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	cmp	DWORD PTR [eax+8], 0
	mov	DWORD PTR __$EHRec$[esp+36], 0
	jne	SHORT $LN1@sentry@2
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN1@sentry@2

; 95   : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1@sentry@2:

; 96   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+esi+8], 0
	sete	al
	mov	BYTE PTR [edi+4], al

; 97   : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 137  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 138  : 		_TRY_BEGIN
; 139  : 		if (ios_base::flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	test	BYTE PTR [edx+ecx+16], 2
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	je	SHORT $LN8@Osfx

; 140  : 			flush();	// flush stream as needed

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN8@Osfx:

; 142  : 		_CATCH_END
; 143  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 141  : 		_CATCH_ALL

	mov	eax, $LN8@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$18381 = -36					; size = 4
__Lock$28164 = -32					; size = 4
__Lock$18380 = -28					; size = 4
$T28156 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$18380[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __$EHRec$[esp+60], 0
	mov	DWORD PTR __Psave$18381[esp+52], ebx
	jne	SHORT $LN11@use_facet@2
	push	0
	lea	ecx, DWORD PTR __Lock$28164[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet@2
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet@2:
	lea	ecx, DWORD PTR __Lock$28164[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@2:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+48]
	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	mov	eax, DWORD PTR [eax]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@2
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]
	test	esi, esi
	jne	SHORT $LN24@use_facet@2
$LN26@use_facet@2:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@2
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN27@use_facet@2
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+edi*4]
$LN16@use_facet@2:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN24@use_facet@2
$LN27@use_facet@2:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@2

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN24@use_facet@2

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

$LN20@use_facet@2:
	xor	esi, esi
	jmp	SHORT $LN26@use_facet@2
$LN4@use_facet@2:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$18381[esp+52]
	push	eax
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@2

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T28156[esp+56]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T28156[esp+56]
	push	ecx
	call	__CxxThrowException@8
$LN2@use_facet@2:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$18381[esp+52]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN24@use_facet@2:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$18380[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN29@use_facet@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$18380[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$18411 = -36					; size = 4
__Lock$28206 = -32					; size = 4
__Lock$18410 = -28					; size = 4
$T28198 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$18410[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __$EHRec$[esp+60], 0
	mov	DWORD PTR __Psave$18411[esp+52], ebx
	jne	SHORT $LN11@use_facet@3
	push	0
	lea	ecx, DWORD PTR __Lock$28206[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet@3
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet@3:
	lea	ecx, DWORD PTR __Lock$28206[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@3:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+48]
	mov	edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	mov	eax, DWORD PTR [eax]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@3
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]
	test	esi, esi
	jne	SHORT $LN24@use_facet@3
$LN26@use_facet@3:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@3
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN27@use_facet@3
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+edi*4]
$LN16@use_facet@3:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN24@use_facet@3
$LN27@use_facet@3:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@3

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN24@use_facet@3

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

$LN20@use_facet@3:
	xor	esi, esi
	jmp	SHORT $LN26@use_facet@3
$LN4@use_facet@3:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$18411[esp+52]
	push	eax
	call	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@3

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T28198[esp+56]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T28198[esp+56]
	push	ecx
	call	__CxxThrowException@8
$LN2@use_facet@3:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$18411[esp+52]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN24@use_facet@3:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$18410[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN29@use_facet@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$18410[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$18570 = -36					; size = 4
__Lock$28248 = -32					; size = 4
__Lock$18569 = -28					; size = 4
$T28240 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 466  : 	{	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, eax

; 467  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$18569[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 468  : 		const locale::facet *_Psave =
; 469  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 470  : 
; 471  : 		size_t _Id = _Facet::id;

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __$EHRec$[esp+60], 0
	mov	DWORD PTR __Psave$18570[esp+52], ebx
	jne	SHORT $LN11@use_facet@4
	push	0
	lea	ecx, DWORD PTR __Lock$28248[esp+56]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, 0 ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet@4
	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	eax, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet@4:
	lea	ecx, DWORD PTR __Lock$28248[esp+52]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN11@use_facet@4:

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	eax, DWORD PTR __Loc$[esp+48]
	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	mov	eax, DWORD PTR [eax]
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN20@use_facet@4
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [ecx+edi*4]
	test	esi, esi
	jne	SHORT $LN24@use_facet@4
$LN26@use_facet@4:
	cmp	BYTE PTR [eax+20], 0
	je	SHORT $LN16@use_facet@4
	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN27@use_facet@4
	mov	edx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [edx+edi*4]
$LN16@use_facet@4:

; 473  : 
; 474  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN24@use_facet@4
$LN27@use_facet@4:

; 475  : 			;	// got facet from locale
; 476  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet@4

; 477  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN24@use_facet@4

; 472  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

$LN20@use_facet@4:
	xor	esi, esi
	jmp	SHORT $LN26@use_facet@4
$LN4@use_facet@4:

; 478  : 		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	lea	eax, DWORD PTR __Psave$18570[esp+52]
	push	eax
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $LN2@use_facet@4

; 479  : 
; 480  :  #if _HAS_EXCEPTIONS
; 481  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T28240[esp+56]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	ecx, DWORD PTR $T28240[esp+56]
	push	ecx
	call	__CxxThrowException@8
$LN2@use_facet@4:

; 482  : 
; 483  : 	#else /* _HAS_EXCEPTIONS */
; 484  : 			abort();	// lazy disallowed
; 485  : 	#endif /* _HAS_EXCEPTIONS */
; 486  : 
; 487  : 		else
; 488  : 			{	// queue up lazy facet for destruction
; 489  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$18570[esp+52]

; 490  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 491  : 
; 492  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 493  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 494  : 			_Pfmod->_Register();

	push	esi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN24@use_facet@4:

; 495  : 			}
; 496  : 
; 497  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$18569[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 498  : 	_END_LOCK()
; 499  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
$LN29@use_facet@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$18569[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-36]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 75   : 			{	// construct locking and calling _Ipfx

	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	eax, DWORD PTR __Istr$[esp+20]
	mov	DWORD PTR [esi], eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN11@sentry@3
	lea	ecx, DWORD PTR [eax+4]
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock
$LN11@sentry@3:

; 76   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	mov	eax, DWORD PTR __Noskip$[esp+20]
	mov	ecx, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR [esi+4], al

; 77   : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 100  : 			{	// destroy the object

	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 101  : 
; 102  :  #if _HAS_EXCEPTIONS
; 103  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN1@sentry@4

; 104  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN1@sentry@4:

; 105  : 			}

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], -1
	je	SHORT $LN12@sentry@4
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN12@sentry@4:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-8]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
tv307 = -92						; size = 4
$T28343 = -92						; size = 4
___$ReturnUdt$GSCopy$ = -88				; size = 4
$T28345 = -84						; size = 28
$T28344 = -84						; size = 28
$T28349 = -56						; size = 12
$T28348 = -56						; size = 12
__Str$17345 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 930  : 		{	// put formatted bool to _Dest

	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+112]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Iosbase$[esp+108]

; 931  : 		_DEBUG_POINTER(_Dest);
; 932  : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	test	DWORD PTR [ebx+16], 16384		; 00004000H
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	esi, ecx

; 951  : 				}
; 952  : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+112], edi
	jne	SHORT $LN5@do_put
	movzx	eax, BYTE PTR __Val$[esp+108]
	mov	ecx, DWORD PTR __Fill$[esp+108]
	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+28]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+116]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __Dest$[esp+140]
	mov	DWORD PTR [eax+8], ecx
	push	edi
	mov	ecx, esi
	call	edx
	jmp	$LN142@do_put
$LN5@do_put:

; 933  : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
; 934  : 		else
; 935  : 			{	// put "false" or "true"
; 936  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T28343[esp+112]
	push	eax
	mov	ecx, ebx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	xor	edi, edi
	push	eax
	mov	DWORD PTR __$EHRec$[esp+124], edi
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	lea	ecx, DWORD PTR $T28343[esp+112]
	mov	ebp, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 937  : 			_Mystr _Str;

	mov	DWORD PTR __Str$17345[esp+136], 15	; 0000000fH
	mov	DWORD PTR __Str$17345[esp+132], edi
	mov	BYTE PTR __Str$17345[esp+116], 0

; 938  : 			if (_Val)

	cmp	BYTE PTR __Val$[esp+108], 0
	mov	DWORD PTR __$EHRec$[esp+120], 1
	je	SHORT $LN3@do_put

; 939  : 				_Str.assign(_Punct_fac.truename());

	lea	ecx, DWORD PTR $T28344[esp+112]
	push	ecx
	mov	ecx, ebp
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	push	-1
	push	edi
	push	eax
	lea	ecx, DWORD PTR __Str$17345[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 2
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T28344[esp+136], 16		; 00000010H
	mov	BYTE PTR __$EHRec$[esp+120], 1
	jb	SHORT $LN94@do_put
	mov	edx, DWORD PTR $T28344[esp+116]
	push	edx

; 940  : 			else

	jmp	SHORT $LN154@do_put
$LN3@do_put:

; 941  : 				_Str.assign(_Punct_fac.falsename());

	lea	eax, DWORD PTR $T28345[esp+112]
	push	eax
	mov	ecx, ebp
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	push	-1
	push	edi
	push	eax
	lea	ecx, DWORD PTR __Str$17345[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 3
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T28345[esp+136], 16		; 00000010H
	mov	BYTE PTR __$EHRec$[esp+120], 1
	jb	SHORT $LN94@do_put
	mov	ecx, DWORD PTR $T28345[esp+116]
	push	ecx
$LN154@do_put:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN94@do_put:

; 942  : 
; 943  : 			size_t _Fillcount = _Iosbase.width() <= 0
; 944  : 				|| (size_t)_Iosbase.width() <= _Str.size()
; 945  : 					? 0 : (size_t)_Iosbase.width() - _Str.size();

	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, edi
	mov	ecx, DWORD PTR __Str$17345[esp+132]
	jle	SHORT $LN8@do_put
	cmp	eax, ecx
	jbe	SHORT $LN8@do_put
	sub	eax, ecx
	mov	edi, eax
$LN8@do_put:

; 946  : 
; 947  : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [ebx+16]
	and	edx, 448				; 000001c0H
	cmp	edx, 64					; 00000040H

; 948  : 				{	// put leading fill
; 949  : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Dest$[esp+112]
	je	SHORT $LN152@do_put
	mov	eax, DWORD PTR __Fill$[esp+108]
	mov	ecx, DWORD PTR __Dest$[esp+108]
	push	edi
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+136]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T28348[esp+132]
	push	edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ebp, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	add	esp, 28					; 0000001cH

; 950  : 				_Fillcount = 0;

	xor	edi, edi
	jmp	SHORT $LN1@do_put
$LN152@do_put:
	mov	ecx, DWORD PTR __Dest$[esp+116]
	mov	ebp, DWORD PTR __Dest$[esp+108]
$LN1@do_put:

; 951  : 				}
; 952  : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	cmp	DWORD PTR __Str$17345[esp+136], 16	; 00000010H
	mov	eax, DWORD PTR __Str$17345[esp+116]
	jae	SHORT $LN155@do_put
	lea	eax, DWORD PTR __Str$17345[esp+116]
$LN155@do_put:
	mov	DWORD PTR tv307[esp+112], eax
	mov	eax, DWORD PTR __Str$17345[esp+132]
	push	eax
	mov	eax, DWORD PTR tv307[esp+116]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR $T28349[esp+132]
	push	ecx
	push	esi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 953  : 			_Iosbase.width(0);
; 954  : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	ecx, DWORD PTR __Fill$[esp+136]
	mov	edx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	add	esp, 28					; 0000001cH
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+116]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	push	edi
	mov	DWORD PTR [ecx+4], ebp
	push	esi
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ecx+8], eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR __Str$17345[esp+136], 16	; 00000010H
	jb	SHORT $LN142@do_put
	mov	edx, DWORD PTR __Str$17345[esp+116]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN142@do_put:
	mov	eax, edi

; 955  : 			}
; 956  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+92]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T28343[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$17345[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$2:
	lea	ecx, DWORD PTR $T28344[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$3:
	lea	ecx, DWORD PTR $T28345[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-96]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	__Iosbase$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
EXTRN	_strcspn:PROC
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT
__Enders$ = -116					; size = 3
__Fillcount$ = -112					; size = 4
__Kseparator$ = -108					; size = 1
__Lock$28934 = -108					; size = 4
$T29167 = -104						; size = 1
__Expoffset$17850 = -104				; size = 4
__Punct_fac$ = -104					; size = 4
__Fracoffset$17843 = -100				; size = 4
__Prefix$ = -100					; size = 4
__Iosbase$GSCopy$ = -96					; size = 4
$T28906 = -92						; size = 12
$T28905 = -92						; size = 12
$T28904 = -92						; size = 12
$T28901 = -92						; size = 12
$T28900 = -92						; size = 12
$T28899 = -92						; size = 12
$T28898 = -92						; size = 12
$T28897 = -92						; size = 12
$T28896 = -92						; size = 12
$T28895 = -92						; size = 12
$T28894 = -92						; size = 12
$T28893 = -92						; size = 12
$T28888 = -80						; size = 4
___$ReturnUdt$GSCopy$ = -76				; size = 4
__Groupstring$ = -72					; size = 28
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Iosbase$ = 28						; size = 4
__Fill$ = 32						; size = 1
__Buf$ = 36						; size = 4
__Beforepoint$ = 40					; size = 4
__Afterpoint$ = 44					; size = 4
__Trailing$ = 48					; size = 4
__Count$ = 52						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1118 : 		{	// put formatted floating-point to _Dest

	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+116], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+132]
	mov	ecx, DWORD PTR __Iosbase$[esp+132]
	mov	edi, DWORD PTR __Buf$[esp+132]

; 1119 : 		_DEBUG_POINTER(_Dest);
; 1120 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	edx, DWORD PTR $T28888[esp+136]
	push	edx
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+140], eax
	mov	DWORD PTR __Iosbase$GSCopy$[esp+140], ecx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+148], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebp, DWORD PTR $T28888[esp+140]
	add	esp, 4
	test	ebp, ebp
	mov	ebx, eax
	mov	DWORD PTR __Punct_fac$[esp+136], ebx
	mov	DWORD PTR __$EHRec$[esp+144], -1
	je	SHORT $LN31@Fput
	push	0
	lea	ecx, DWORD PTR __Lock$28934[esp+140]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebp+4]
	test	eax, eax
	jbe	SHORT $LN33@Fput
	cmp	eax, -1
	jae	SHORT $LN33@Fput
	add	eax, -1
	mov	DWORD PTR [ebp+4], eax
$LN33@Fput:
	mov	esi, DWORD PTR [ebp+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$28934[esp+136]
	and	esi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN31@Fput
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, esi
	call	edx
$LN31@Fput:

; 1121 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[esp+136]
	push	eax
	mov	ecx, ebx
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1122 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+8]
	mov	esi, 1
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+144], esi
	call	eax

; 1123 : 		string _Groupstring;

	xor	ecx, ecx
	mov	BYTE PTR __Kseparator$[esp+136], al
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], ecx
	mov	BYTE PTR __Groupstring$[esp+140], cl

; 1124 : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);
; 1125 : 		size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;

	mov	al, BYTE PTR [edi]
	cmp	al, 43					; 0000002bH
	mov	BYTE PTR __$EHRec$[esp+144], 2
	je	SHORT $LN19@Fput
	cmp	al, 45					; 0000002dH
	mov	DWORD PTR __Prefix$[esp+136], ecx
	jne	SHORT $LN20@Fput
$LN19@Fput:
	mov	DWORD PTR __Prefix$[esp+136], esi
$LN20@Fput:

; 1126 : 
; 1127 : 		char _Enders[3];
; 1128 : 		_Enders[0] = ::localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, DWORD PTR [eax]

; 1129 : 		_Enders[1] = 'e';
; 1130 : 		_Enders[2] = '\0';
; 1131 : 
; 1132 : 		const char *_Eptr = (const char *)::memchr(_Buf,
; 1133 : 			'e', _Count);	// find exponent

	mov	ebp, DWORD PTR __Count$[esp+132]
	mov	dl, BYTE PTR [ecx]
	push	ebp
	push	101					; 00000065H
	push	edi
	mov	BYTE PTR __Enders$[esp+148], dl
	mov	BYTE PTR __Enders$[esp+149], 101	; 00000065H
	mov	BYTE PTR __Enders$[esp+150], 0
	call	_memchr
	mov	esi, eax

; 1134 : 		const char *_Pointptr = (const char *)::memchr(_Buf,
; 1135 : 			_Enders[0], _Count);	// find decimal point

	movsx	eax, BYTE PTR __Enders$[esp+148]
	push	ebp
	push	eax
	push	edi
	call	_memchr
	mov	ebx, eax
	add	esp, 24					; 00000018H

; 1136 : 		if (_Pointptr == 0)

	test	ebx, ebx
	jne	SHORT $LN16@Fput

; 1137 : 			_Trailing = 0;

	mov	DWORD PTR __Trailing$[esp+132], eax
$LN16@Fput:

; 1138 : 
; 1139 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+160]
	cmp	ecx, 16					; 00000010H
	mov	edx, DWORD PTR __Grouping$[esp+140]
	mov	eax, edx
	jae	SHORT $LN78@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN78@Fput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	$LN105@Fput
	cmp	ecx, 16					; 00000010H
	mov	eax, edx
	jae	SHORT $LN84@Fput
	lea	eax, DWORD PTR __Grouping$[esp+140]
$LN84@Fput:
	cmp	BYTE PTR [eax], 0
	jle	$LN105@Fput

; 1140 : 			{	// grouping specified, add thousands separators
; 1141 : 			_Groupstring.append(_Buf, _Count);	// assemble field into string

	push	ebp
	push	edi
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1142 : 			if (_Eptr == 0)

	test	esi, esi
	jne	SHORT $LN14@Fput

; 1143 : 				_Groupstring.append(_Trailing, '0');

	mov	ecx, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1144 : 			else

	mov	ebp, DWORD PTR __Beforepoint$[esp+132]
	jmp	SHORT $LN13@Fput
$LN14@Fput:

; 1145 : 				{	/* dispose of any zeros before exponent */
; 1146 : 				if (_Pointptr == 0)

	test	ebx, ebx
	jne	SHORT $LN177@Fput

; 1147 : 					{	/* no point but exponent, put scaling zeros */
; 1148 : 					_Groupstring.append(_Beforepoint, '0');

	mov	edx, DWORD PTR __Beforepoint$[esp+132]
	push	48					; 00000030H
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1149 : 					_Beforepoint = 0;

	xor	ebp, ebp
	jmp	SHORT $LN12@Fput
$LN177@Fput:
	mov	ebp, DWORD PTR __Beforepoint$[esp+132]
$LN12@Fput:

; 1150 : 					}
; 1151 : 				_Groupstring.insert(_Eptr - _Buf, _Trailing, '0');

	mov	eax, DWORD PTR __Trailing$[esp+132]
	push	48					; 00000030H
	push	eax
	sub	esi, edi
	push	esi
	lea	ecx, DWORD PTR __Groupstring$[esp+148]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$LN13@Fput:

; 1152 : 				}
; 1153 : 			_Trailing = 0;
; 1154 : 
; 1155 : 			if (_Pointptr == 0)

	test	ebx, ebx

; 1156 : 				_Groupstring.append(_Beforepoint, '0');

	push	48					; 00000030H
	jne	SHORT $LN11@Fput
	push	ebp
	lea	ecx, DWORD PTR __Groupstring$[esp+144]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1157 : 			else

	jmp	SHORT $LN10@Fput
$LN11@Fput:

; 1158 : 				{	// fill in zeros around decimal point
; 1159 : 				_Groupstring.insert(_Pointptr - _Buf + 1, _Afterpoint, '0');

	mov	ecx, DWORD PTR __Afterpoint$[esp+136]
	mov	esi, ebx
	sub	esi, edi
	push	ecx
	lea	edx, DWORD PTR [esi+1]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[esp+148]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1160 : 				_Groupstring.insert(_Pointptr - _Buf, _Beforepoint, '0');

	push	48					; 00000030H
	push	ebp
	push	esi
	lea	ecx, DWORD PTR __Groupstring$[esp+148]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1161 : 				_Afterpoint = 0;

	mov	DWORD PTR __Afterpoint$[esp+132], 0
$LN10@Fput:

; 1162 : 				}
; 1163 : 			_Beforepoint = 0;
; 1164 : 
; 1165 : 			const char *_Pg = _Grouping.c_str();

	mov	edi, DWORD PTR __Grouping$[esp+140]
	mov	ebx, 16					; 00000010H
	cmp	DWORD PTR __Grouping$[esp+160], ebx
	mov	DWORD PTR __Beforepoint$[esp+132], 0
	jae	SHORT $LN90@Fput
	lea	edi, DWORD PTR __Grouping$[esp+140]
$LN90@Fput:

; 1166 : 			size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);

	cmp	DWORD PTR __Groupstring$[esp+160], ebx
	mov	eax, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN97@Fput
	lea	eax, DWORD PTR __Groupstring$[esp+140]
$LN97@Fput:
	lea	ecx, DWORD PTR __Enders$[esp+136]
	push	ecx
	push	eax
	call	_strcspn
	mov	esi, eax

; 1167 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1168 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [edi]
	add	esp, 8
	cmp	al, 127					; 0000007fH
	je	SHORT $LN8@Fput
$LL9@Fput:
	test	al, al
	jle	SHORT $LN8@Fput
	mov	edx, esi
	sub	edx, DWORD PTR __Prefix$[esp+136]
	movsx	eax, al
	cmp	eax, edx
	jae	SHORT $LN8@Fput

; 1169 : 				{	// add a NUL to mark thousands separator
; 1170 : 				_Groupstring.insert(_Off -= *_Pg, (size_t)1, '\0');

	push	0
	sub	esi, eax
	push	1
	push	esi
	lea	ecx, DWORD PTR __Groupstring$[esp+148]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1171 : 				if ('\0' < _Pg[1])

	cmp	BYTE PTR [edi+1], 0
	jle	SHORT $LN7@Fput

; 1167 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1168 : 				&& (size_t)*_Pg < _Off - _Prefix)

	add	edi, 1
$LN7@Fput:
	mov	al, BYTE PTR [edi]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LL9@Fput
$LN8@Fput:

; 1172 : 					++_Pg;	// not last group, advance
; 1173 : 				}
; 1174 : 
; 1175 : 			_Buf = &_Groupstring[0];

	cmp	DWORD PTR __Groupstring$[esp+160], ebx
	mov	edi, DWORD PTR __Groupstring$[esp+140]
	jae	SHORT $LN104@Fput
	lea	edi, DWORD PTR __Groupstring$[esp+140]
$LN104@Fput:

; 1176 : 			_Trailing = 0;
; 1177 : 			_Count = _Groupstring.size();

	mov	eax, DWORD PTR __Groupstring$[esp+156]
	mov	DWORD PTR __Trailing$[esp+132], 0
	mov	DWORD PTR __Count$[esp+132], eax
	mov	ebp, eax
$LN105@Fput:

; 1178 : 			}
; 1179 : 
; 1180 : 		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;

	mov	ecx, DWORD PTR __Beforepoint$[esp+132]
	mov	edx, DWORD PTR __Afterpoint$[esp+132]
	lea	eax, DWORD PTR [ecx+edx]
	add	eax, DWORD PTR __Trailing$[esp+132]

; 1181 : 		_Fillcount = _Iosbase.width() <= 0
; 1182 : 			|| (size_t)_Iosbase.width() <= _Fillcount
; 1183 : 				? 0 : (size_t)_Iosbase.width() - _Fillcount;

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+136]
	mov	ecx, DWORD PTR [edx+24]
	add	eax, ebp
	test	ecx, ecx
	jle	SHORT $LN21@Fput
	cmp	ecx, eax
	jbe	SHORT $LN21@Fput
	sub	ecx, eax
	mov	DWORD PTR __Fillcount$[esp+136], ecx
	jmp	SHORT $LN22@Fput
$LN21@Fput:
	mov	DWORD PTR __Fillcount$[esp+136], 0
$LN22@Fput:

; 1184 : 		ios_base::fmtflags _Adjustfield =
; 1185 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [edx+16]

; 1186 : 		if (_Adjustfield != ios_base::left
; 1187 : 			&& _Adjustfield != ios_base::internal)

	mov	esi, DWORD PTR _this$[esp+132]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN180@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN174@Fput

; 1188 : 			{	// put leading fill
; 1189 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[esp+136]
	mov	ecx, DWORD PTR __Fill$[esp+132]
	mov	edx, DWORD PTR __Dest$[esp+132]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+144]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+160]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	lea	eax, DWORD PTR $T28893[esp+156]
	push	eax
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[esp+140], ecx

; 1190 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[esp+136], 0
	jmp	$LN4@Fput
$LN174@Fput:

; 1191 : 			}
; 1192 : 		else if (_Adjustfield == ios_base::internal)
; 1193 : 			{	// put internal fill
; 1194 : 			if (0 < _Prefix)

	cmp	DWORD PTR __Prefix$[esp+136], 0
	jbe	SHORT $LN179@Fput

; 1195 : 				{	// but first put sign
; 1196 : 				_Dest = _Putc(_Dest, _Buf, 1);

	mov	edx, DWORD PTR __Dest$[esp+132]
	mov	ecx, DWORD PTR __Dest$[esp+136]
	push	1
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+160]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	lea	eax, DWORD PTR $T28894[esp+156]
	push	eax
	push	esi
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ebx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	add	esp, 28					; 0000001cH

; 1197 : 				++_Buf, --_Count;

	add	edi, 1
	sub	ebp, 1
	mov	DWORD PTR __Count$[esp+132], ebp
	jmp	SHORT $LN3@Fput
$LN179@Fput:
	mov	ecx, DWORD PTR __Dest$[esp+140]
	mov	edx, DWORD PTR __Dest$[esp+136]
	mov	ebx, DWORD PTR __Dest$[esp+132]
$LN3@Fput:

; 1198 : 				}
; 1199 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[esp+136]
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+136]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR $T28895[esp+156]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[esp+140], edx

; 1200 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[esp+136], 0
	jmp	SHORT $LN4@Fput
$LN180@Fput:
	mov	ebx, DWORD PTR __Dest$[esp+136]
	mov	ebp, DWORD PTR __Dest$[esp+132]
$LN4@Fput:

; 1201 : 			}
; 1202 : 
; 1203 : 		_Pointptr = (const char *)::memchr(_Buf,
; 1204 : 			_Enders[0], _Count);	// find decimal point again

	mov	eax, DWORD PTR __Count$[esp+132]
	movsx	ecx, BYTE PTR __Enders$[esp+136]
	push	eax
	push	ecx
	push	edi
	call	_memchr
	add	esp, 12					; 0000000cH

; 1205 : 		if (_Pointptr != 0)

	test	eax, eax
	je	$LN2@Fput

; 1206 : 			{	// has decimal point, put pieces and zero fills
; 1207 : 			size_t _Fracoffset = _Pointptr - _Buf + 1;
; 1208 : 			_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);

	mov	edx, DWORD PTR __Kseparator$[esp+136]
	mov	ecx, DWORD PTR __Dest$[esp+140]
	sub	eax, edi
	add	eax, 1
	push	edx
	mov	DWORD PTR __Fracoffset$17843[esp+140], eax
	add	eax, -1
	push	eax
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	lea	edx, DWORD PTR $T28896[esp+160]
	mov	DWORD PTR [eax], ebp
	push	edx
	mov	DWORD PTR [eax+4], ebx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1209 : 			_Dest = _Rep(_Dest, _E0, _Beforepoint);

	mov	ecx, DWORD PTR __Beforepoint$[esp+164]
	mov	edx, DWORD PTR [eax]
	add	esp, 32					; 00000020H
	push	ecx
	push	48					; 00000030H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T28897[esp+156]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax+8]

; 1210 : 			_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);

	mov	ecx, DWORD PTR __Punct_fac$[esp+164]
	mov	ebx, DWORD PTR [eax]
	mov	ebp, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[esp+168], edx
	mov	edx, DWORD PTR [eax+4]
	add	esp, 28					; 0000001cH
	call	edx
	mov	ecx, DWORD PTR __Dest$[esp+140]
	mov	BYTE PTR $T29167[esp+136], al
	mov	eax, DWORD PTR $T29167[esp+136]
	push	1
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	lea	edx, DWORD PTR $T28898[esp+156]
	mov	DWORD PTR [eax], ebx
	push	edx
	mov	DWORD PTR [eax+4], ebp
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1211 : 			_Dest = _Rep(_Dest, _E0, _Afterpoint);

	mov	ecx, DWORD PTR __Afterpoint$[esp+160]
	mov	edx, DWORD PTR [eax]
	add	esp, 28					; 0000001cH
	push	ecx
	push	48					; 00000030H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T28899[esp+156]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]

; 1212 : 			_Buf += _Fracoffset, _Count -= _Fracoffset;

	mov	eax, DWORD PTR __Fracoffset$17843[esp+164]
	add	esp, 28					; 0000001cH
	add	edi, eax
	sub	DWORD PTR __Count$[esp+132], eax
	mov	DWORD PTR __Dest$[esp+140], edx
$LN2@Fput:

; 1213 : 			}
; 1214 : 
; 1215 : 		_Eptr = (const char *)::memchr(_Buf,
; 1216 : 			'e', _Count);	// find exponent again

	mov	eax, DWORD PTR __Count$[esp+132]
	push	eax
	push	101					; 00000065H
	push	edi
	call	_memchr
	add	esp, 12					; 0000000cH

; 1217 : 		if (_Eptr != 0)

	test	eax, eax
	je	$LN183@Fput

; 1218 : 			{	// has exponent field, put it out
; 1219 : 			size_t _Expoffset = _Eptr - _Buf + 1;
; 1220 : 			_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);

	mov	ecx, DWORD PTR __Kseparator$[esp+136]
	mov	edx, DWORD PTR __Dest$[esp+140]
	sub	eax, edi
	add	eax, 1
	push	ecx
	mov	DWORD PTR __Expoffset$17850[esp+140], eax
	add	eax, -1
	push	eax
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], edx
	lea	eax, DWORD PTR $T28900[esp+160]
	push	eax
	push	esi
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1221 : 			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;

	mov	ecx, DWORD PTR __Trailing$[esp+164]
	mov	edx, DWORD PTR [eax]
	add	esp, 32					; 00000020H
	push	ecx
	push	48					; 00000030H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T28901[esp+156]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1222 : 			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
; 1223 : 				? "E" : "e", 1);

	mov	edx, DWORD PTR __Iosbase$GSCopy$[esp+164]
	add	esp, 28					; 0000001cH
	test	BYTE PTR [edx+16], 4
	mov	DWORD PTR __Trailing$[esp+132], 0
	mov	ecx, OFFSET ??_C@_01DDCIFGEA@E?$AA@
	jne	SHORT $LN24@Fput
	mov	ecx, OFFSET ??_C@_01KGKMHCOC@e?$AA@
$LN24@Fput:
	mov	edx, DWORD PTR [eax]
	push	1
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T28904[esp+156]
	push	ecx
	push	esi
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]

; 1224 : 			_Buf += _Expoffset, _Count -= _Expoffset;

	mov	eax, DWORD PTR __Expoffset$17850[esp+164]
	add	esp, 28					; 0000001cH
	add	edi, eax
	sub	DWORD PTR __Count$[esp+132], eax
	jmp	SHORT $LN1@Fput
$LN183@Fput:
	mov	ecx, DWORD PTR __Dest$[esp+140]
$LN1@Fput:

; 1225 : 			}
; 1226 : 
; 1227 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1228 : 			_Kseparator);	// put leftover field

	mov	edx, DWORD PTR __Kseparator$[esp+136]
	mov	eax, DWORD PTR __Count$[esp+132]
	push	edx
	push	eax
	push	edi
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR $T28905[esp+160]
	push	ecx
	push	esi
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped

; 1229 : 		_Dest = _Rep(_Dest, _E0, _Trailing);	// put trailing zeros

	mov	edx, DWORD PTR __Trailing$[esp+164]
	add	esp, 32					; 00000020H
	push	edx
	mov	edx, DWORD PTR [eax]
	push	48					; 00000030H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T28906[esp+156]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]

; 1230 : 		_Iosbase.width(0);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+164]
	add	esp, 28					; 0000001cH
	xor	ebx, ebx
	mov	DWORD PTR [ecx+24], ebx

; 1231 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	ecx, DWORD PTR __Fillcount$[esp+136]
	push	ecx
	mov	ecx, DWORD PTR __Fill$[esp+136]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+156]
	push	edi
	push	esi
	mov	DWORD PTR [ecx+8], eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	esi, 16					; 00000010H
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR __Groupstring$[esp+160], esi
	jb	SHORT $LN137@Fput
	mov	edx, DWORD PTR __Groupstring$[esp+140]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN137@Fput:
	cmp	DWORD PTR __Grouping$[esp+160], esi
	mov	DWORD PTR __Groupstring$[esp+160], 15	; 0000000fH
	mov	DWORD PTR __Groupstring$[esp+156], ebx
	mov	BYTE PTR __Groupstring$[esp+140], 0
	jb	SHORT $LN175@Fput
	mov	eax, DWORD PTR __Grouping$[esp+140]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN175@Fput:
	mov	eax, edi

; 1232 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 116				; 00000074H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0:
	lea	ecx, DWORD PTR $T28888[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-120]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	__Iosbase$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Lock$29459 = -80					; size = 4
__Prefix$ = -80						; size = 4
__Pg$17877 = -76					; size = 4
__Iosbase$GSCopy$ = -72					; size = 4
$T29522 = -68						; size = 1
__Punct_fac$ = -68					; size = 4
$T29421 = -64						; size = 4
___$ReturnUdt$GSCopy$ = -60				; size = 4
$T29432 = -56						; size = 12
$T29431 = -56						; size = 12
$T29430 = -56						; size = 12
$T29429 = -56						; size = 12
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 12
__Iosbase$ = 28						; size = 4
__Fill$ = 32						; size = 1
__Buf$ = 36						; size = 4
__Count$ = 40						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1263 : 		{	// put formatted integer to _Dest

	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+96]
	mov	ecx, DWORD PTR __Iosbase$[esp+96]
	mov	ebx, DWORD PTR __Buf$[esp+96]

; 1264 : 		_DEBUG_POINTER(_Dest);
; 1265 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	edx, DWORD PTR $T29421[esp+100]
	push	edx
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+104], eax
	mov	DWORD PTR __Iosbase$GSCopy$[esp+104], ecx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+112], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebp, DWORD PTR $T29421[esp+104]
	add	esp, 4
	test	ebp, ebp
	mov	esi, eax
	mov	DWORD PTR __Punct_fac$[esp+100], esi
	mov	DWORD PTR __$EHRec$[esp+108], -1
	je	SHORT $LN22@Iput
	push	0
	lea	ecx, DWORD PTR __Lock$29459[esp+104]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [ebp+4]
	test	eax, eax
	jbe	SHORT $LN24@Iput
	cmp	eax, -1
	jae	SHORT $LN24@Iput
	add	eax, -1
	mov	DWORD PTR [ebp+4], eax
$LN24@Iput:
	mov	edi, DWORD PTR [ebp+4]
	neg	edi
	sbb	edi, edi
	not	edi
	lea	ecx, DWORD PTR __Lock$29459[esp+100]
	and	edi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	edi, edi
	je	SHORT $LN22@Iput
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax]
	push	1
	mov	ecx, edi
	call	edx
$LN22@Iput:

; 1266 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[esp+100]
	push	eax
	mov	ecx, esi
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 1267 : 		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
; 1268 : 			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
; 1269 : 			: 0;

	mov	al, BYTE PTR [ebx]
	cmp	al, 43					; 0000002bH
	mov	ecx, 1
	mov	DWORD PTR __$EHRec$[esp+108], ecx
	je	SHORT $LN10@Iput
	cmp	al, 45					; 0000002dH
	je	SHORT $LN10@Iput
	cmp	al, 48					; 00000030H
	jne	SHORT $LN12@Iput
	mov	al, BYTE PTR [ebx+1]
	cmp	al, 120					; 00000078H
	je	SHORT $LN11@Iput
	cmp	al, 88					; 00000058H
	jne	SHORT $LN12@Iput
$LN11@Iput:
	mov	DWORD PTR __Prefix$[esp+100], 2
	jmp	SHORT $LN14@Iput
$LN12@Iput:
	mov	DWORD PTR __Prefix$[esp+100], 0
	jmp	SHORT $LN14@Iput
$LN10@Iput:
	mov	DWORD PTR __Prefix$[esp+100], ecx
$LN14@Iput:

; 1270 : 
; 1271 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	mov	ecx, DWORD PTR __Grouping$[esp+124]
	cmp	ecx, 16					; 00000010H
	mov	edx, DWORD PTR __Grouping$[esp+104]
	mov	eax, edx
	jae	SHORT $LN33@Iput
	lea	eax, DWORD PTR __Grouping$[esp+104]
$LN33@Iput:
	cmp	BYTE PTR [eax], 127			; 0000007fH
	je	$LN87@Iput
	cmp	ecx, 16					; 00000010H
	mov	eax, edx
	jae	SHORT $LN39@Iput
	lea	eax, DWORD PTR __Grouping$[esp+104]
$LN39@Iput:
	cmp	BYTE PTR [eax], 0
	jle	SHORT $LN87@Iput

; 1272 : 			{	// grouping specified, add thousands separators
; 1273 : 			const char *_Pg = _Grouping.c_str();

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN44@Iput
	mov	DWORD PTR __Pg$17877[esp+100], edx
	jmp	SHORT $LN45@Iput
$LN44@Iput:
	lea	ecx, DWORD PTR __Grouping$[esp+104]
	mov	DWORD PTR __Pg$17877[esp+100], ecx
$LN45@Iput:

; 1274 : 			size_t _Off = _Count;
; 1275 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1276 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	edx, DWORD PTR __Pg$17877[esp+100]
	mov	al, BYTE PTR [edx]
	cmp	al, 127					; 0000007fH
	mov	ebp, DWORD PTR __Count$[esp+96]
	mov	esi, ebp
	je	SHORT $LN5@Iput
$LN6@Iput:
	test	al, al
	jle	SHORT $LN5@Iput
	mov	ecx, esi
	sub	ecx, DWORD PTR __Prefix$[esp+100]
	movsx	eax, al
	cmp	eax, ecx
	jae	SHORT $LN5@Iput

; 1277 : 				{	// add a NUL to mark thousands separator
; 1278 : 				_Off -= *_Pg;

	sub	esi, eax

; 1279 : 				_CRT_SECURE_MEMMOVE(&_Buf[_Off + 1], _Count + 1 - _Off,

	mov	edx, ebp
	sub	edx, esi
	lea	eax, DWORD PTR [edx+1]
	push	eax
	lea	edi, DWORD PTR [ebx+esi]
	push	edi
	push	eax
	lea	eax, DWORD PTR [ebx+esi+1]
	push	eax
	call	_memmove_s

; 1280 : 					&_Buf[_Off],	 _Count + 1 - _Off);
; 1281 : 				_Buf[_Off] = '\0', ++_Count;
; 1282 : 				if ('\0' < _Pg[1])

	mov	eax, DWORD PTR __Pg$17877[esp+116]
	add	esp, 16					; 00000010H
	mov	BYTE PTR [edi], 0
	add	ebp, 1
	cmp	BYTE PTR [eax+1], 0
	jle	SHORT $LN4@Iput
	add	eax, 1
	mov	DWORD PTR __Pg$17877[esp+100], eax
$LN4@Iput:
	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LN6@Iput

; 1274 : 			size_t _Off = _Count;
; 1275 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1276 : 				&& (size_t)*_Pg < _Off - _Prefix)

	jmp	SHORT $LN5@Iput
$LN87@Iput:
	mov	ebp, DWORD PTR __Count$[esp+96]
$LN5@Iput:

; 1283 : 					++_Pg;	// not last group, advance
; 1284 : 				}
; 1285 : 			}
; 1286 : 
; 1287 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1288 : 			|| (size_t)_Iosbase.width() <= _Count
; 1289 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+100]
	mov	edi, DWORD PTR [ecx+24]
	test	edi, edi
	jle	SHORT $LN15@Iput
	cmp	edi, ebp
	jbe	SHORT $LN15@Iput
	sub	edi, ebp
	jmp	SHORT $LN16@Iput
$LN15@Iput:
	xor	edi, edi
$LN16@Iput:

; 1290 : 
; 1291 : 		ios_base::fmtflags _Adjustfield =
; 1292 : 			_Iosbase.flags() & ios_base::adjustfield;
; 1293 : 		if (_Adjustfield != ios_base::left
; 1294 : 			&& _Adjustfield != ios_base::internal)

	mov	esi, DWORD PTR _this$[esp+96]
	mov	edx, ecx
	mov	eax, DWORD PTR [edx+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN1@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN85@Iput

; 1295 : 			{	// put leading fill
; 1296 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fill$[esp+96]
	mov	ecx, DWORD PTR __Dest$[esp+96]
	mov	edx, DWORD PTR __Dest$[esp+100]
	push	edi
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+124]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T29429[esp+120]
	push	edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Dest$[esp+124], ecx
	mov	DWORD PTR __Dest$[esp+128], edx
	mov	DWORD PTR __Dest$[esp+132], eax

; 1297 : 			_Fillcount = 0;

	jmp	SHORT $LN95@Iput
$LN85@Iput:

; 1298 : 			}
; 1299 : 		else if (_Adjustfield == ios_base::internal)
; 1300 : 			{	// put internal fill
; 1301 : 			_Dest = _Putc(_Dest, _Buf, _Prefix);	// put prefix

	mov	ecx, DWORD PTR __Prefix$[esp+100]
	mov	edx, DWORD PTR __Dest$[esp+96]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+104]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+124]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	lea	eax, DWORD PTR $T29430[esp+120]
	push	eax
	push	esi
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc

; 1302 : 			_Buf += _Prefix, _Count -= _Prefix;

	mov	ecx, DWORD PTR __Prefix$[esp+128]

; 1303 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;

	mov	edx, DWORD PTR [eax]
	add	esp, 28					; 0000001cH
	add	ebx, ecx
	sub	ebp, ecx
	mov	ecx, DWORD PTR __Fill$[esp+96]
	push	edi
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	lea	ecx, DWORD PTR $T29431[esp+120]
	push	ecx
	push	esi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+124], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR __Dest$[esp+128], ecx
	mov	DWORD PTR __Dest$[esp+132], edx
$LN95@Iput:
	add	esp, 28					; 0000001cH
	xor	edi, edi
$LN1@Iput:

; 1304 : 			}
; 1305 : 
; 1306 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1307 : 			_Punct_fac.thousands_sep());	// put field

	mov	ecx, DWORD PTR __Punct_fac$[esp+100]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	ecx, DWORD PTR __Dest$[esp+96]
	mov	edx, DWORD PTR __Dest$[esp+100]
	mov	BYTE PTR $T29522[esp+100], al
	mov	eax, DWORD PTR $T29522[esp+100]
	push	eax
	push	ebp
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+128]
	mov	DWORD PTR [eax+4], edx
	lea	edx, DWORD PTR $T29432[esp+124]
	push	edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1308 : 		_Iosbase.width(0);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$[esp+132]
	add	esp, 32					; 00000020H

; 1309 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+104]
	mov	DWORD PTR [ecx+24], 0
	mov	ecx, DWORD PTR __Fill$[esp+100]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	push	edi
	mov	DWORD PTR [ecx+4], ebx
	push	esi
	mov	DWORD PTR [ecx+8], eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR __Grouping$[esp+124], 16	; 00000010H
	jb	SHORT $LN86@Iput
	mov	edx, DWORD PTR __Grouping$[esp+104]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN86@Iput:
	mov	eax, edi

; 1310 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T29421[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-84]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@	; `string'
PUBLIC	__Ac$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
CONST	SEGMENT
??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@ DB '0123456789abcdefABCDEF'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1
__ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT
__Seendigit$ = -87					; size = 1
__Nonzero$ = -86					; size = 1
__Kseparator$ = -85					; size = 1
__Ptr$ = -84						; size = 4
__Base$ = -80						; size = 4
__Ac$GSCopy$ = -76					; size = 4
__Groups$ = -72						; size = 28
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Basefield$ = 24					; size = 4
__Loc$ = 28						; size = 4
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld, COMDAT

; 598  : 		{	// get integer field from [_First, _Last) into _Ac

	push	-1
	push	__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+88], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Loc$[esp+104]
	mov	ebp, DWORD PTR __Ac$[esp+104]
	mov	edi, DWORD PTR __First$[esp+104]
	mov	ebx, DWORD PTR __Last$[esp+104]

; 599  : 		const _Mypunct& _Punct_fac = _USE(_Loc, _Mypunct);

	push	eax

; 600  : 		const string _Grouping = _Punct_fac.grouping();
; 601  : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	DWORD PTR __Ac$GSCopy$[esp+112], ebp
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	esi, eax
	add	esp, 4
	lea	eax, DWORD PTR __Grouping$[esp+108]
	push	eax
	mov	ecx, esi
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+116], 0
	call	eax

; 602  : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);
; 603  : 		char *_Ptr = _Ac;
; 604  : 
; 605  : 		if (_First == _Last)

	cmp	BYTE PTR [edi+8], 0
	mov	BYTE PTR __Kseparator$[esp+108], al
	mov	DWORD PTR __Ptr$[esp+108], ebp
	jne	SHORT $LN56@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN56@Getifld:
	cmp	BYTE PTR [ebx+8], 0
	jne	SHORT $LN55@Getifld
	mov	ecx, ebx
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN55@Getifld:
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN441@Getifld
	cmp	DWORD PTR [ebx+4], eax
	je	SHORT $LN75@Getifld
	test	eax, eax
	je	SHORT $LN60@Getifld
$LN441@Getifld:
	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN75@Getifld
$LN60@Getifld:

; 606  : 			;	// empty field
; 607  : 		else if (*_First == _MAKLOCCHR(_Elem, '+', _Cvt))

	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN63@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN63@Getifld:
	mov	al, BYTE PTR [edi+9]
	cmp	al, 43					; 0000002bH
	jne	SHORT $LN36@Getifld

; 608  : 			*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	BYTE PTR [ebp], al
	jmp	SHORT $LN442@Getifld
$LN36@Getifld:

; 609  : 		else if (*_First == _MAKLOCCHR(_Elem, '-', _Cvt))

	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN70@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN70@Getifld:
	mov	al, BYTE PTR [edi+9]
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN75@Getifld

; 610  : 			*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [ebp], al
$LN442@Getifld:
	add	ebp, 1
	mov	ecx, edi
	mov	DWORD PTR __Ptr$[esp+108], ebp
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
$LN75@Getifld:

; 611  : 
; 612  : 		_Basefield &= ios_base::basefield;

	mov	eax, DWORD PTR __Basefield$[esp+104]
	and	eax, 3584				; 00000e00H

; 613  : 		int _Base = _Basefield == ios_base::oct ? 8
; 614  : 			: _Basefield == ios_base::hex ? 16
; 615  : 			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

	cmp	eax, 1024				; 00000400H
	jne	SHORT $LN43@Getifld
	mov	esi, 8
	mov	DWORD PTR __Base$[esp+108], esi
	jmp	SHORT $LN42@Getifld
$LN43@Getifld:
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN41@Getifld
	mov	esi, 16					; 00000010H
	mov	DWORD PTR __Base$[esp+108], esi
	jmp	SHORT $LN42@Getifld
$LN41@Getifld:
	neg	eax
	sbb	eax, eax
	and	eax, 10					; 0000000aH
	mov	esi, eax
	mov	DWORD PTR __Base$[esp+108], eax
$LN42@Getifld:

; 616  : 
; 617  : 		bool _Seendigit = false;	// seen a digit in input
; 618  : 		bool _Nonzero = false;	// seen a nonzero digit in input
; 619  : 
; 620  : 		if (_First != _Last && *_First == _E0)

	push	ebx
	push	edi
	mov	BYTE PTR __Seendigit$[esp+116], 0
	mov	BYTE PTR __Nonzero$[esp+116], 0
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	je	$LN28@Getifld
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN77@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN77@Getifld:
	cmp	BYTE PTR [edi+9], 48			; 00000030H
	jne	$LN28@Getifld

; 621  : 			{	// leading zero, look for 0x, 0X
; 622  : 			_Seendigit = true, ++_First;

	mov	ecx, edi
	mov	BYTE PTR __Seendigit$[esp+108], 1
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc

; 623  : 			if (_First != _Last && (*_First == _MAKLOCCHR(_Elem, 'x', _Cvt)
; 624  : 					|| *_First == _MAKLOCCHR(_Elem, 'X', _Cvt))
; 625  : 				&& (_Base == 0 || _Base == 16))

	push	ebx
	push	edi
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	je	SHORT $LN32@Getifld
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN82@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN82@Getifld:
	cmp	BYTE PTR [edi+9], 120			; 00000078H
	je	SHORT $LN31@Getifld
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN87@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN87@Getifld:
	cmp	BYTE PTR [edi+9], 88			; 00000058H
	jne	SHORT $LN32@Getifld
$LN31@Getifld:
	test	esi, esi
	je	SHORT $LN30@Getifld
	cmp	esi, 16					; 00000010H
	jne	SHORT $LN32@Getifld
$LN30@Getifld:

; 626  : 				_Base = 16, _Seendigit = false, ++_First;

	mov	esi, 16					; 00000010H
	mov	ecx, edi
	mov	DWORD PTR __Base$[esp+108], esi
	mov	BYTE PTR __Seendigit$[esp+108], 0
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc

; 629  : 			}
; 630  : 
; 631  : 		int _Dlen = _Base == 0 || _Base == 10 ? 10
; 632  : 			: _Base == 8 ? 8 : 16 + 6;

	sub	esi, 8
	neg	esi
	sbb	esi, esi
	and	esi, 14					; 0000000eH
	add	esi, 8
	jmp	SHORT $LN46@Getifld
$LN32@Getifld:

; 627  : 			else if (_Base == 0)

	test	esi, esi
	jne	SHORT $LN421@Getifld

; 628  : 				_Base = 8;

	mov	esi, 8
	mov	DWORD PTR __Base$[esp+108], esi

; 629  : 			}
; 630  : 
; 631  : 		int _Dlen = _Base == 0 || _Base == 10 ? 10
; 632  : 			: _Base == 8 ? 8 : 16 + 6;

	sub	esi, esi
	neg	esi
	sbb	esi, esi
	and	esi, 14					; 0000000eH
	add	esi, 8
	jmp	SHORT $LN46@Getifld
$LN28@Getifld:
	test	esi, esi
	je	SHORT $LN45@Getifld
$LN421@Getifld:
	cmp	esi, 10					; 0000000aH
	je	SHORT $LN45@Getifld
	sub	esi, 8
	neg	esi
	sbb	esi, esi
	and	esi, 14					; 0000000eH
	add	esi, 8
	jmp	SHORT $LN46@Getifld
$LN45@Getifld:
	mov	esi, 10					; 0000000aH
$LN46@Getifld:

; 633  : 		string _Groups((size_t)1, (char)_Seendigit);

	mov	cl, BYTE PTR __Seendigit$[esp+108]
	mov	DWORD PTR __Groups$[esp+132], 15	; 0000000fH
	mov	BYTE PTR __Groups$[esp+112], cl
	mov	DWORD PTR __Groups$[esp+128], 1
	mov	BYTE PTR __Groups$[esp+113], 0
	mov	BYTE PTR __$EHRec$[esp+116], 1

; 634  : 		size_t _Group = 0;

	xor	ebp, ebp

; 635  : 
; 636  : 		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];
; 637  : 			_First != _Last; ++_First)

$LL206@Getifld:
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN242@Getifld
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN240@Getifld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN246@Getifld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN246@Getifld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN247@Getifld
$LN246@Getifld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN247@Getifld:
	cmp	eax, -1
	je	SHORT $LN240@Getifld
	mov	BYTE PTR [edi+9], al
	jmp	SHORT $LN239@Getifld
$LN240@Getifld:
	mov	DWORD PTR [edi+4], 0
$LN239@Getifld:
	mov	BYTE PTR [edi+8], 1
$LN242@Getifld:
	cmp	BYTE PTR [ebx+8], 0
	jne	SHORT $LN265@Getifld
	mov	ecx, DWORD PTR [ebx+4]
	test	ecx, ecx
	je	SHORT $LN263@Getifld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN269@Getifld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN269@Getifld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN270@Getifld
$LN269@Getifld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN270@Getifld:
	cmp	eax, -1
	je	SHORT $LN263@Getifld
	mov	BYTE PTR [ebx+9], al
	jmp	SHORT $LN262@Getifld
$LN263@Getifld:
	mov	DWORD PTR [ebx+4], 0
$LN262@Getifld:
	mov	BYTE PTR [ebx+8], 1
$LN265@Getifld:
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	jne	SHORT $LN426@Getifld
	cmp	DWORD PTR [ebx+4], ecx
	jne	SHORT $LN236@Getifld
$LN237@Getifld:

; 655  : 				}
; 656  : 
; 657  : 		if (_Group == 0)

	test	ebp, ebp
	je	$LN435@Getifld

; 658  : 			;	// no thousands separators seen
; 659  : 		else if ('\0' < _Groups[_Group])

	cmp	ebp, DWORD PTR __Groups$[esp+128]
	jbe	SHORT $LN337@Getifld
	call	__invalid_parameter_noinfo
$LN337@Getifld:
	mov	eax, DWORD PTR __Groups$[esp+112]
	mov	ecx, 16					; 00000010H
	cmp	DWORD PTR __Groups$[esp+132], ecx
	jae	SHORT $LN343@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN343@Getifld:
	cmp	BYTE PTR [eax+ebp], 0
	jle	$LN14@Getifld

; 660  : 			++_Group;	// add trailing group to group count

	add	ebp, 1

; 661  : 		else

	jmp	$LN13@Getifld
$LN426@Getifld:

; 635  : 
; 636  : 		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];
; 637  : 			_First != _Last; ++_First)

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN237@Getifld
$LN236@Getifld:

; 638  : 			if (::memchr("0123456789abcdefABCDEF",
; 639  : 				*_Ptr = _MAKLOCBYTE(_Elem, *_First, _Cvt), _Dlen) != 0)

	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN291@Getifld
	test	ecx, ecx
	je	SHORT $LN289@Getifld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN295@Getifld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN295@Getifld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN296@Getifld
$LN295@Getifld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN296@Getifld:
	cmp	eax, -1
	je	SHORT $LN289@Getifld
	mov	BYTE PTR [edi+9], al
	jmp	SHORT $LN288@Getifld
$LN289@Getifld:
	mov	DWORD PTR [edi+4], 0
$LN288@Getifld:
	mov	BYTE PTR [edi+8], 1
$LN291@Getifld:
	mov	al, BYTE PTR [edi+9]
	mov	ecx, DWORD PTR __Ptr$[esp+108]
	movsx	edx, al
	push	esi
	push	edx
	push	OFFSET ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
	mov	BYTE PTR [ecx], al
	call	_memchr
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN24@Getifld

; 640  : 				{	// got a digit, characterize it and add to group size
; 641  : 				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)

	cmp	BYTE PTR __Nonzero$[esp+108], 0
	jne	SHORT $LN22@Getifld
	mov	eax, DWORD PTR __Ptr$[esp+108]
	cmp	BYTE PTR [eax], 48			; 00000030H
	je	SHORT $LN23@Getifld
$LN22@Getifld:
	mov	eax, DWORD PTR __Ac$GSCopy$[esp+108]
	add	eax, 31					; 0000001fH
	cmp	DWORD PTR __Ptr$[esp+108], eax
	jae	SHORT $LN23@Getifld

; 642  : 					++_Ptr, _Nonzero = true;

	add	DWORD PTR __Ptr$[esp+108], 1
	mov	BYTE PTR __Nonzero$[esp+108], 1
$LN23@Getifld:

; 643  : 				_Seendigit = true;
; 644  : 				if (_Groups[_Group] != CHAR_MAX)

	cmp	ebp, DWORD PTR __Groups$[esp+128]
	mov	BYTE PTR __Seendigit$[esp+108], 1
	jbe	SHORT $LN313@Getifld
	call	__invalid_parameter_noinfo
$LN313@Getifld:
	cmp	DWORD PTR __Groups$[esp+132], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$[esp+112]
	jae	SHORT $LN319@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN319@Getifld:
	cmp	BYTE PTR [eax+ebp], 127			; 0000007fH
	je	SHORT $LN26@Getifld

; 645  : 					++_Groups[_Group];

	cmp	ebp, DWORD PTR __Groups$[esp+128]
	jbe	SHORT $LN320@Getifld
	call	__invalid_parameter_noinfo
$LN320@Getifld:
	cmp	DWORD PTR __Groups$[esp+132], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$[esp+112]
	jae	SHORT $LN326@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN326@Getifld:
	add	BYTE PTR [eax+ebp], 1

; 646  : 				}
; 647  : 			else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN26@Getifld
$LN24@Getifld:

; 648  : 				|| _Kseparator == (_Elem)0
; 649  : 				|| *_First != _Kseparator)

	cmp	ebp, DWORD PTR __Groups$[esp+128]
	jbe	SHORT $LN327@Getifld
	call	__invalid_parameter_noinfo
$LN327@Getifld:
	cmp	DWORD PTR __Groups$[esp+132], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$[esp+112]
	jae	SHORT $LN333@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN333@Getifld:
	cmp	BYTE PTR [eax+ebp], 0
	je	$LN237@Getifld
	cmp	BYTE PTR __Kseparator$[esp+108], 0
	je	$LN237@Getifld
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN334@Getifld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN334@Getifld:
	mov	cl, BYTE PTR __Kseparator$[esp+108]
	cmp	BYTE PTR [edi+9], cl
	jne	$LN237@Getifld

; 650  : 				break;	// not a group separator, done
; 651  : 			else
; 652  : 				{	// add a new group to _Groups string
; 653  : 				_Groups.append((string::size_type)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$[esp+116]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 654  : 				++_Group;

	add	ebp, 1
$LN26@Getifld:
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN207@Getifld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN213@Getifld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN213@Getifld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN214@Getifld

; 635  : 
; 636  : 		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];
; 637  : 			_First != _Last; ++_First)

$LN213@Getifld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN214@Getifld:
	cmp	eax, -1
	je	SHORT $LN207@Getifld
	mov	BYTE PTR [edi+8], 0
	jmp	$LL206@Getifld
$LN207@Getifld:
	mov	DWORD PTR [edi+4], 0
	mov	BYTE PTR [edi+8], 1
	jmp	$LL206@Getifld
$LN14@Getifld:

; 662  : 			_Seendigit = false;	// trailing separator, fail

	mov	BYTE PTR __Seendigit$[esp+108], 0
	jmp	SHORT $LN13@Getifld
$LN435@Getifld:

; 661  : 		else

	mov	ecx, 16					; 00000010H
$LN13@Getifld:

; 663  : 
; 664  : 		for (const char *_Pg = _Grouping.c_str(); _Seendigit && 0 < _Group; )

	cmp	DWORD PTR __Grouping$[esp+132], ecx
	mov	esi, DWORD PTR __Grouping$[esp+112]
	jae	SHORT $LN349@Getifld
	lea	esi, DWORD PTR __Grouping$[esp+112]
$LN349@Getifld:
	cmp	BYTE PTR __Seendigit$[esp+108], 0
	je	$LN420@Getifld
	npad	2
$LL12@Getifld:
	test	ebp, ebp
	jbe	SHORT $LN419@Getifld

; 665  : 			if (*_Pg == CHAR_MAX)

	cmp	BYTE PTR [esi], 127			; 0000007fH
	je	SHORT $LN419@Getifld

; 666  : 				break;	// end of grouping constraints to check
; 667  : 			else if (0 < --_Group && *_Pg != _Groups[_Group]
; 668  : 				|| 0 == _Group && *_Pg < _Groups[_Group])

	sub	ebp, 1
	je	SHORT $LN6@Getifld
	cmp	ebp, DWORD PTR __Groups$[esp+128]
	jbe	SHORT $LN350@Getifld
	call	__invalid_parameter_noinfo
	mov	ecx, 16					; 00000010H
$LN350@Getifld:
	cmp	DWORD PTR __Groups$[esp+132], ecx
	mov	eax, DWORD PTR __Groups$[esp+112]
	jae	SHORT $LN356@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN356@Getifld:
	mov	dl, BYTE PTR [esi]
	cmp	dl, BYTE PTR [eax+ebp]
	jne	SHORT $LN420@Getifld
$LN6@Getifld:
	test	ebp, ebp
	jne	SHORT $LN8@Getifld
	cmp	ebp, DWORD PTR __Groups$[esp+128]
	jbe	SHORT $LN357@Getifld
	call	__invalid_parameter_noinfo
	mov	ecx, 16					; 00000010H
$LN357@Getifld:
	cmp	DWORD PTR __Groups$[esp+132], ecx
	mov	eax, DWORD PTR __Groups$[esp+112]
	jae	SHORT $LN363@Getifld
	lea	eax, DWORD PTR __Groups$[esp+112]
$LN363@Getifld:
	mov	dl, BYTE PTR [esi]
	cmp	dl, BYTE PTR [eax+ebp]
	jl	SHORT $LN420@Getifld
$LN8@Getifld:

; 669  : 				_Seendigit = false;	// bad group size, fail
; 670  : 			else if ('\0' < _Pg[1])

	cmp	BYTE PTR [esi+1], 0
	jle	SHORT $LL12@Getifld

; 663  : 
; 664  : 		for (const char *_Pg = _Grouping.c_str(); _Seendigit && 0 < _Group; )

	add	esi, 1
	jmp	SHORT $LL12@Getifld
$LN419@Getifld:

; 671  : 				++_Pg;	// group size okay, advance to next test
; 672  : 
; 673  : 		if (_Seendigit && !_Nonzero)

	cmp	BYTE PTR __Nonzero$[esp+108], 0

; 674  : 			*_Ptr++ = '0';	// zero field, replace stripped zero(s)

	mov	eax, DWORD PTR __Ptr$[esp+108]
	jne	SHORT $LN1@Getifld
	mov	BYTE PTR [eax], 48			; 00000030H
	add	eax, 1
	jmp	SHORT $LN1@Getifld
$LN420@Getifld:

; 675  : 		else if (!_Seendigit)
; 676  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$GSCopy$[esp+108]
$LN1@Getifld:

; 677  : 		*_Ptr = '\0';
; 678  : 		return (_Base);

	cmp	DWORD PTR __Groups$[esp+132], ecx
	mov	BYTE PTR [eax], 0
	jb	SHORT $LN380@Getifld
	mov	eax, DWORD PTR __Groups$[esp+112]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	ecx, 16					; 00000010H
$LN380@Getifld:
	cmp	DWORD PTR __Grouping$[esp+132], ecx
	mov	DWORD PTR __Groups$[esp+132], 15	; 0000000fH
	mov	DWORD PTR __Groups$[esp+128], 0
	mov	BYTE PTR __Groups$[esp+112], 0
	jb	SHORT $LN427@Getifld
	mov	ecx, DWORD PTR __Grouping$[esp+112]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN427@Getifld:
	mov	eax, DWORD PTR __Base$[esp+108]

; 679  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+88]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 88					; 00000058H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1:
	lea	ecx, DWORD PTR __Groups$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-92]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
PUBLIC	__Last$GSCopy$
PUBLIC	__Ac$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z$1
__ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
_TEXT	SEGMENT
__Seendigit$ = -101					; size = 1
__Ptr$ = -100						; size = 4
__Bad$ = -93						; size = 1
__Last$GSCopy$ = -92					; size = 4
__Kseparator$18028 = -85				; size = 1
__Pten$ = -84						; size = 4
__Significant$ = -80					; size = 4
__Ac$GSCopy$ = -76					; size = 4
__Groups$18030 = -72					; size = 28
__Grouping$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Loc$ = 24						; size = 4
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld, COMDAT

; 683  : 		{	// get floating-point field from [_First, _Last) into _Ac

	push	-1
	push	__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+104], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Loc$[esp+120]
	mov	ebx, DWORD PTR __Ac$[esp+120]
	mov	edi, DWORD PTR __Last$[esp+120]
	mov	esi, DWORD PTR __First$[esp+120]

; 684  : 		const _Mypunct& _Punct_fac = _USE(_Loc, _Mypunct);

	push	eax

; 685  : 		const string _Grouping = _Punct_fac.grouping();
; 686  : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);
; 687  : 		char *_Ptr = _Ac;

	mov	DWORD PTR __Ac$GSCopy$[esp+128], ebx
	mov	DWORD PTR __Last$GSCopy$[esp+128], edi
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebp, eax
	add	esp, 4
	lea	eax, DWORD PTR __Grouping$[esp+124]
	push	eax
	mov	ecx, ebp
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 688  : 		bool _Bad = false;
; 689  : 
; 690  : 		if (_First == _Last)

	cmp	BYTE PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[esp+132], 0
	mov	DWORD PTR __Ptr$[esp+124], ebx
	mov	BYTE PTR __Bad$[esp+124], 0
	jne	SHORT $LN78@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN78@Getffld:
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN77@Getffld
	mov	ecx, edi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN77@Getffld:
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN1425@Getffld
	cmp	DWORD PTR [edi+4], eax
	je	SHORT $LN97@Getffld
	test	eax, eax
	je	SHORT $LN82@Getffld
$LN1425@Getffld:
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN97@Getffld
$LN82@Getffld:

; 691  : 			;	// empty field
; 692  : 		else if (*_First == _MAKLOCCHR(_Elem, '+', _Cvt))

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN85@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN85@Getffld:
	cmp	BYTE PTR [esi+9], 43			; 0000002bH
	jne	SHORT $LN66@Getffld

; 693  : 			*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	BYTE PTR [ebx], 43			; 0000002bH
	jmp	SHORT $LN1426@Getffld
$LN66@Getffld:

; 694  : 		else if (*_First == _MAKLOCCHR(_Elem, '-', _Cvt))

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN92@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN92@Getffld:
	cmp	BYTE PTR [esi+9], 45			; 0000002dH
	jne	SHORT $LN97@Getffld

; 695  : 			*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [ebx], 45			; 0000002dH
$LN1426@Getffld:
	add	ebx, 1
	mov	ecx, esi
	mov	DWORD PTR __Ptr$[esp+124], ebx
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
$LN97@Getffld:

; 696  : 
; 697  : 		bool _Seendigit = false;	// seen a digit in input
; 698  : 		int _Significant = 0;	// number of significant digits
; 699  : 		int _Pten = 0;	// power of 10 multiplier
; 700  : 
; 701  : 		if (*_Grouping.c_str() == CHAR_MAX || *_Grouping.c_str() <= '\0')

	mov	eax, DWORD PTR __Grouping$[esp+148]
	mov	edx, DWORD PTR __Grouping$[esp+128]
	xor	edi, edi
	cmp	eax, 16					; 00000010H
	mov	BYTE PTR __Seendigit$[esp+124], 0
	mov	DWORD PTR __Significant$[esp+124], edi
	mov	DWORD PTR __Pten$[esp+124], edi
	mov	ecx, edx
	jae	SHORT $LN104@Getffld
	lea	ecx, DWORD PTR __Grouping$[esp+128]
$LN104@Getffld:
	cmp	BYTE PTR [ecx], 127			; 0000007fH
	je	$LN1355@Getffld
	cmp	eax, 16					; 00000010H
	mov	eax, edx
	jae	SHORT $LN110@Getffld
	lea	eax, DWORD PTR __Grouping$[esp+128]
$LN110@Getffld:
	cmp	BYTE PTR [eax], 0
	jle	$LN1355@Getffld

; 713  : 					}
; 714  : 		else
; 715  : 			{	// grouping specified, gather digits and group sizes
; 716  : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, ebp
	call	eax
	mov	BYTE PTR __Kseparator$18028[esp+124], al

; 717  : 			string _Groups((size_t)1, '\0');

	mov	DWORD PTR __Groups$18030[esp+148], 15	; 0000000fH
	mov	BYTE PTR __Groups$18030[esp+128], 0
	mov	DWORD PTR __Groups$18030[esp+144], 1
	mov	BYTE PTR __Groups$18030[esp+129], 0

; 718  : 			size_t _Group = 0;
; 719  : 
; 720  : 			for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __Last$GSCopy$[esp+124]
	push	ecx
	push	esi
	mov	BYTE PTR __$EHRec$[esp+140], 1
	xor	ebx, ebx
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	je	$LN37@Getffld
$LL341@Getffld:

; 721  : 				if (_E0 <= *_First && *_First <= _E0 + 9)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN349@Getffld
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN347@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN353@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN353@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN354@Getffld
$LN353@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+16]
	call	edx
$LN354@Getffld:
	cmp	eax, -1
	je	SHORT $LN347@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN346@Getffld
$LN347@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN346@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN349@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jl	$LN50@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN369@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN369@Getffld:
	cmp	BYTE PTR [esi+9], 57			; 00000039H
	jg	$LN50@Getffld

; 722  : 					{	// got a digit, add to group size
; 723  : 					_Seendigit = true;
; 724  : 					if (_MAX_SIG_DIG <= _Significant)

	cmp	edi, 36					; 00000024H
	mov	BYTE PTR __Seendigit$[esp+124], 1
	jl	SHORT $LN49@Getffld

; 725  : 						++_Pten;	// just scale by 10

	add	DWORD PTR __Pten$[esp+124], 1
	jmp	SHORT $LN46@Getffld
$LN49@Getffld:

; 726  : 					else if (*_First == _E0 && _Significant == 0)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN372@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN372@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jne	SHORT $LN47@Getffld
	test	edi, edi
	je	SHORT $LN46@Getffld
$LN47@Getffld:

; 727  : 						;	// drop leading zeros
; 728  : 					else
; 729  : 						{	// save a significant digit
; 730  : 						*_Ptr++ = (char)((*_First - _E0) + '0');

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN375@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN375@Getffld:
	mov	ecx, DWORD PTR __Ptr$[esp+124]
	mov	al, BYTE PTR [esi+9]
	mov	BYTE PTR [ecx], al
	add	ecx, 1

; 731  : 						++_Significant;

	add	edi, 1
	mov	DWORD PTR __Ptr$[esp+124], ecx
	mov	DWORD PTR __Significant$[esp+124], edi
$LN46@Getffld:

; 732  : 						}
; 733  : 					if (_Groups[_Group] != CHAR_MAX)

	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN378@Getffld
	call	__invalid_parameter_noinfo
$LN378@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN384@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN384@Getffld:
	cmp	BYTE PTR [eax+ebx], 127			; 0000007fH
	je	SHORT $LN52@Getffld

; 734  : 						++_Groups[_Group];

	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN385@Getffld
	call	__invalid_parameter_noinfo
$LN385@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN391@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN391@Getffld:
	add	BYTE PTR [eax+ebx], 1

; 735  : 					}
; 736  : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN52@Getffld
$LN50@Getffld:

; 737  : 					|| _Kseparator == (_Elem)0
; 738  : 					|| *_First != _Kseparator)

	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN392@Getffld
	call	__invalid_parameter_noinfo
$LN392@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN398@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN398@Getffld:
	cmp	BYTE PTR [eax+ebx], 0
	je	SHORT $LN1324@Getffld
	cmp	BYTE PTR __Kseparator$18028[esp+124], 0
	je	SHORT $LN1324@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN399@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN399@Getffld:
	mov	al, BYTE PTR __Kseparator$18028[esp+124]
	cmp	BYTE PTR [esi+9], al
	jne	SHORT $LN1324@Getffld

; 739  : 					break;	// not a group separator, done
; 740  : 				else
; 741  : 					{	// add a new group to _Groups string
; 742  : 					_Groups.append((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$18030[esp+132]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 743  : 					++_Group;

	add	ebx, 1
$LN52@Getffld:
	mov	ecx, esi
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
	mov	ecx, DWORD PTR __Last$GSCopy$[esp+124]
	push	ecx
	push	esi
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	jne	$LL341@Getffld
$LN1324@Getffld:

; 744  : 					}
; 745  : 			if (_Group == 0)

	test	ebx, ebx
	je	SHORT $LN37@Getffld

; 746  : 				;	// no thousands separators seen
; 747  : 			else if ('\0' < _Groups[_Group])

	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN402@Getffld
	call	__invalid_parameter_noinfo
$LN402@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN408@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN408@Getffld:
	cmp	BYTE PTR [eax+ebx], 0
	jle	SHORT $LN38@Getffld

; 748  : 				++_Group;	// add trailing group to group count

	add	ebx, 1

; 749  : 			else

	jmp	SHORT $LN37@Getffld
$LN38@Getffld:

; 750  : 				_Bad = true;	// trailing separator, fail

	mov	BYTE PTR __Bad$[esp+124], 1
$LN37@Getffld:

; 751  : 
; 752  : 			for (const char *_Pg = _Grouping.c_str();

	cmp	DWORD PTR __Grouping$[esp+148], 16	; 00000010H
	mov	edi, DWORD PTR __Grouping$[esp+128]
	jae	SHORT $LN414@Getffld
	lea	edi, DWORD PTR __Grouping$[esp+128]
$LN414@Getffld:

; 753  : 				!_Bad && 0 < _Group; )

	cmp	BYTE PTR __Bad$[esp+124], 0
	jne	SHORT $LN1325@Getffld
	npad	4
$LL36@Getffld:
	test	ebx, ebx
	jbe	SHORT $LN1325@Getffld

; 754  : 				if (*_Pg == CHAR_MAX)

	cmp	BYTE PTR [edi], 127			; 0000007fH
	je	SHORT $LN1325@Getffld

; 755  : 					break;	// end of grouping constraints to check
; 756  : 				else if (0 < --_Group && *_Pg != _Groups[_Group]
; 757  : 					|| 0 == _Group && *_Pg < _Groups[_Group])

	sub	ebx, 1
	je	SHORT $LN30@Getffld
	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN415@Getffld
	call	__invalid_parameter_noinfo
$LN415@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN421@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN421@Getffld:
	mov	dl, BYTE PTR [edi]
	cmp	dl, BYTE PTR [eax+ebx]
	jne	SHORT $LN31@Getffld
$LN30@Getffld:
	test	ebx, ebx
	jne	SHORT $LN32@Getffld
	cmp	ebx, DWORD PTR __Groups$18030[esp+144]
	jbe	SHORT $LN422@Getffld
	call	__invalid_parameter_noinfo
$LN422@Getffld:
	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	eax, DWORD PTR __Groups$18030[esp+128]
	jae	SHORT $LN428@Getffld
	lea	eax, DWORD PTR __Groups$18030[esp+128]
$LN428@Getffld:
	mov	cl, BYTE PTR [edi]
	cmp	cl, BYTE PTR [eax+ebx]
	jl	SHORT $LN31@Getffld
$LN32@Getffld:

; 759  : 				else if ('\0' < _Pg[1])

	cmp	BYTE PTR [edi+1], 0
	jle	SHORT $LL36@Getffld

; 753  : 				!_Bad && 0 < _Group; )

	add	edi, 1
	jmp	SHORT $LL36@Getffld
$LN31@Getffld:

; 758  : 					_Bad = true;	// bad group size, fail

	mov	BYTE PTR __Bad$[esp+124], 1
$LN1325@Getffld:

; 760  : 					++_Pg;	// group size okay, advance to next test
; 761  : 			}

	cmp	DWORD PTR __Groups$18030[esp+148], 16	; 00000010H
	mov	BYTE PTR __$EHRec$[esp+132], 0
	jb	SHORT $LN123@Getffld
	mov	edx, DWORD PTR __Groups$18030[esp+128]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN123@Getffld:

; 762  : 
; 763  : 		if (_Seendigit && _Significant == 0)

	cmp	BYTE PTR __Seendigit$[esp+124], 0
	je	SHORT $LN27@Getffld
	cmp	DWORD PTR __Significant$[esp+124], 0
	jne	SHORT $LN27@Getffld

; 764  : 			*_Ptr++ = '0';	// save at least one leading digit

	mov	eax, DWORD PTR __Ptr$[esp+124]
	mov	BYTE PTR [eax], 48			; 00000030H
	add	eax, 1
	mov	DWORD PTR __Ptr$[esp+124], eax
$LN27@Getffld:

; 765  : 
; 766  : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	cmp	BYTE PTR [esi+8], 0
	jne	$LN470@Getffld
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	$LN468@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	$LN474@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	$LN474@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	$LN475@Getffld
$LN1355@Getffld:

; 702  : 			for (; _First != _Last
; 703  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 704  : 					_Seendigit = true, ++_First)

	cmp	BYTE PTR [esi+8], 0

; 760  : 					++_Pg;	// group size okay, advance to next test
; 761  : 			}

	mov	ebx, DWORD PTR __Last$GSCopy$[esp+124]
	jne	SHORT $LN128@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, edi
	je	SHORT $LN126@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN132@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], edi
	jle	SHORT $LN132@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN133@Getffld

; 702  : 			for (; _First != _Last
; 703  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 704  : 					_Seendigit = true, ++_First)

$LN132@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN133@Getffld:
	cmp	eax, -1
	je	SHORT $LN126@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN125@Getffld
$LN126@Getffld:
	mov	DWORD PTR [esi+4], edi
$LN125@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN128@Getffld:
	cmp	BYTE PTR [ebx+8], 0
	jne	SHORT $LN151@Getffld
	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, edi
	je	SHORT $LN149@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN155@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], edi
	jle	SHORT $LN155@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN156@Getffld
$LN155@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN156@Getffld:
	cmp	eax, -1
	je	SHORT $LN149@Getffld
	mov	BYTE PTR [ebx+9], al
	jmp	SHORT $LN148@Getffld
$LN149@Getffld:
	mov	DWORD PTR [ebx+4], edi
$LN148@Getffld:
	mov	BYTE PTR [ebx+8], 1
$LN151@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, edi
	jne	SHORT $LN1346@Getffld
	cmp	DWORD PTR [ebx+4], edi
	je	$LN123@Getffld
	jmp	SHORT $LN122@Getffld
$LN1346@Getffld:
	cmp	DWORD PTR [ebx+4], edi
	jne	$LN123@Getffld
$LN122@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN177@Getffld
	test	ecx, ecx
	je	SHORT $LN175@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN181@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN181@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN182@Getffld
$LN181@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN182@Getffld:
	cmp	eax, -1
	je	SHORT $LN175@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN174@Getffld
$LN175@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN174@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN177@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jl	$LN123@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN203@Getffld
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN201@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN207@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN207@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN208@Getffld
$LN207@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN208@Getffld:
	cmp	eax, -1
	je	SHORT $LN201@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN200@Getffld
$LN201@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN200@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN203@Getffld:
	cmp	BYTE PTR [esi+9], 57			; 00000039H
	jg	$LN123@Getffld

; 705  : 				if (_MAX_SIG_DIG <= _Significant)

	mov	edi, DWORD PTR __Significant$[esp+124]
	cmp	edi, 36					; 00000024H
	jl	SHORT $LN58@Getffld

; 706  : 					++_Pten;	// just scale by 10

	add	DWORD PTR __Pten$[esp+124], 1
	mov	ecx, esi
	mov	BYTE PTR __Seendigit$[esp+124], 1
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
	xor	edi, edi
	jmp	$LN1355@Getffld
$LN58@Getffld:

; 707  : 				else if (*_First == _E0 && _Significant == 0)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN223@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN223@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jne	SHORT $LN56@Getffld
	test	edi, edi
	je	SHORT $LN60@Getffld
$LN56@Getffld:

; 708  : 					;	// drop leading zeros
; 709  : 				else
; 710  : 					{	// save a significant digit
; 711  : 					*_Ptr++ = (char)((*_First - _E0) + '0');

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN226@Getffld
	mov	ecx, esi
	call	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
$LN226@Getffld:
	mov	eax, DWORD PTR __Ptr$[esp+124]
	mov	cl, BYTE PTR [esi+9]
	mov	BYTE PTR [eax], cl
	add	eax, 1

; 712  : 					++_Significant;

	add	edi, 1
	mov	DWORD PTR __Ptr$[esp+124], eax
	mov	DWORD PTR __Significant$[esp+124], edi
$LN60@Getffld:
	mov	ecx, esi
	mov	BYTE PTR __Seendigit$[esp+124], 1
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
	xor	edi, edi
	jmp	$LN1355@Getffld

; 765  : 
; 766  : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

$LN474@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN475@Getffld:
	cmp	eax, -1
	je	SHORT $LN468@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN467@Getffld
$LN468@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN467@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN470@Getffld:
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
	cmp	BYTE PTR [edx+8], 0
	jne	SHORT $LN493@Getffld
	mov	ecx, DWORD PTR [edx+4]
	test	ecx, ecx
	je	SHORT $LN491@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN497@Getffld
	mov	edi, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edi], 0
	jle	SHORT $LN497@Getffld
	mov	ecx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [ecx]
	jmp	SHORT $LN498@Getffld
$LN497@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
$LN498@Getffld:
	cmp	eax, -1
	je	SHORT $LN491@Getffld
	mov	BYTE PTR [edx+9], al
	jmp	SHORT $LN490@Getffld
$LN491@Getffld:
	mov	DWORD PTR [edx+4], 0
$LN490@Getffld:
	mov	BYTE PTR [edx+8], 1
$LN493@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN1428@Getffld
	cmp	DWORD PTR [edx+4], ecx
	je	$LN543@Getffld
	test	ecx, ecx
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
	je	SHORT $LN464@Getffld
$LN1428@Getffld:
	cmp	DWORD PTR [edx+4], 0
	jne	$LN543@Getffld
$LN464@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN519@Getffld
	test	ecx, ecx
	je	SHORT $LN517@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN523@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN523@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN524@Getffld
$LN523@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN524@Getffld:
	cmp	eax, -1
	je	SHORT $LN517@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN516@Getffld
$LN517@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN516@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN519@Getffld:
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	bl, BYTE PTR [esi+9]
	mov	ecx, ebp
	call	eax
	cmp	bl, al
	jne	SHORT $LN543@Getffld

; 767  : 			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	// add .

	call	_localeconv
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp+124]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR [esi+4]
	add	eax, 1
	test	ecx, ecx
	mov	DWORD PTR __Ptr$[esp+124], eax
	je	SHORT $LN544@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN550@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN550@Getffld
	mov	eax, edx
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN551@Getffld
$LN550@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN551@Getffld:
	cmp	eax, -1
	je	SHORT $LN544@Getffld
	mov	BYTE PTR [esi+8], 0
	jmp	SHORT $LN543@Getffld
$LN544@Getffld:
	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 1
$LN543@Getffld:

; 768  : 
; 769  : 		if (_Significant == 0)

	xor	ebx, ebx
	cmp	DWORD PTR __Significant$[esp+124], ebx
	jne	$LN1366@Getffld
	mov	ebp, DWORD PTR __Last$GSCopy$[esp+124]
	mov	edi, DWORD PTR __Pten$[esp+124]
	npad	7

; 770  : 			{	// 0000. so far
; 771  : 			for (; _First != _Last && *_First == _E0;
; 772  : 				_Seendigit = true, ++_First)

$LL566@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN602@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN600@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN606@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN606@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN607@Getffld
$LN606@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN607@Getffld:
	cmp	eax, -1
	je	SHORT $LN600@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN599@Getffld
$LN600@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN599@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN602@Getffld:
	cmp	BYTE PTR [ebp+8], 0
	jne	SHORT $LN625@Getffld
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	SHORT $LN623@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN629@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN629@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN630@Getffld
$LN629@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN630@Getffld:
	cmp	eax, -1
	je	SHORT $LN623@Getffld
	mov	BYTE PTR [ebp+9], al
	jmp	SHORT $LN622@Getffld
$LN623@Getffld:
	mov	DWORD PTR [ebp+4], ebx
$LN622@Getffld:
	mov	BYTE PTR [ebp+8], 1
$LN625@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN1347@Getffld
	cmp	DWORD PTR [ebp+4], ebx
	jne	SHORT $LN596@Getffld
$LN1415@Getffld:

; 774  : 			if (_Pten < 0)

	cmp	edi, ebx

; 775  : 				*_Ptr++ = '0', ++_Pten;	// put one back

	mov	ebp, DWORD PTR __Ptr$[esp+124]
	mov	DWORD PTR __Pten$[esp+124], edi
	jge	$LN1357@Getffld
	mov	BYTE PTR [ebp], 48			; 00000030H
	add	ebp, 1
	add	edi, 1
	mov	DWORD PTR __Pten$[esp+124], edi
	jmp	$LN1357@Getffld
$LN1347@Getffld:

; 770  : 			{	// 0000. so far
; 771  : 			for (; _First != _Last && *_First == _E0;
; 772  : 				_Seendigit = true, ++_First)

	cmp	DWORD PTR [ebp+4], ebx
	jne	SHORT $LN1415@Getffld
$LN596@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN651@Getffld
	cmp	ecx, ebx
	je	SHORT $LN649@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN655@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN655@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN656@Getffld
$LN655@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN656@Getffld:
	cmp	eax, -1
	je	SHORT $LN649@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN648@Getffld
$LN649@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN648@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN651@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jne	SHORT $LN1415@Getffld
	mov	ecx, DWORD PTR [esi+4]

; 773  : 				--_Pten;	// just count leading fraction zeros

	sub	edi, 1
	cmp	ecx, ebx
	mov	BYTE PTR __Seendigit$[esp+124], 1
	je	SHORT $LN567@Getffld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN573@Getffld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN573@Getffld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN574@Getffld

; 770  : 			{	// 0000. so far
; 771  : 			for (; _First != _Last && *_First == _E0;
; 772  : 				_Seendigit = true, ++_First)

$LN573@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN574@Getffld:
	cmp	eax, -1
	je	SHORT $LN567@Getffld
	mov	BYTE PTR [esi+8], 0
	jmp	$LL566@Getffld
$LN567@Getffld:
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi+8], 1
	jmp	$LL566@Getffld
$LN1366@Getffld:

; 775  : 				*_Ptr++ = '0', ++_Pten;	// put one back

	mov	ebp, DWORD PTR __Ptr$[esp+124]
$LN1357@Getffld:
	mov	edi, DWORD PTR __Last$GSCopy$[esp+124]
	npad	3
$LL1352@Getffld:

; 776  : 			}
; 777  : 
; 778  : 		for (; _First != _Last
; 779  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 780  : 				_Seendigit = true, ++_First)

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN709@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN707@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN713@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN713@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN714@Getffld
$LN713@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN714@Getffld:
	cmp	eax, -1
	je	SHORT $LN707@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN706@Getffld
$LN707@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN706@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN709@Getffld:
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN732@Getffld
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, ebx
	je	SHORT $LN730@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN736@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN736@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN737@Getffld
$LN736@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN737@Getffld:
	cmp	eax, -1
	je	SHORT $LN730@Getffld
	mov	BYTE PTR [edi+9], al
	jmp	SHORT $LN729@Getffld
$LN730@Getffld:
	mov	DWORD PTR [edi+4], ebx
$LN729@Getffld:
	mov	BYTE PTR [edi+8], 1
$LN732@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN1348@Getffld
	cmp	DWORD PTR [edi+4], ebx
	jne	SHORT $LN703@Getffld
$LN1419@Getffld:

; 785  : 				}
; 786  : 
; 787  : 		if (_Seendigit && _First != _Last
; 788  : 			&& (*_First == _MAKLOCCHR(_Elem, 'e', _Cvt)
; 789  : 				|| *_First == _MAKLOCCHR(_Elem, 'E', _Cvt)))

	cmp	BYTE PTR __Seendigit$[esp+124], 0
	mov	DWORD PTR __Ptr$[esp+124], ebp
	je	$LN4@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	$LN845@Getffld
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	$LN843@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	$LN849@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	$LN849@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	$LN850@Getffld
$LN1348@Getffld:

; 776  : 			}
; 777  : 
; 778  : 		for (; _First != _Last
; 779  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 780  : 				_Seendigit = true, ++_First)

	cmp	DWORD PTR [edi+4], ebx
	jne	SHORT $LN1419@Getffld
$LN703@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN758@Getffld
	cmp	ecx, ebx
	je	SHORT $LN756@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN762@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN762@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN763@Getffld
$LN762@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN763@Getffld:
	cmp	eax, -1
	je	SHORT $LN756@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN755@Getffld
$LN756@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN755@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN758@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jl	$LN1419@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN784@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN782@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN788@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN788@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN789@Getffld
$LN788@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN789@Getffld:
	cmp	eax, -1
	je	SHORT $LN782@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN781@Getffld
$LN782@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN781@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN784@Getffld:
	cmp	BYTE PTR [esi+9], 57			; 00000039H
	jg	$LN1419@Getffld

; 781  : 			if (_Significant < _MAX_SIG_DIG)

	cmp	DWORD PTR __Significant$[esp+124], 36	; 00000024H
	jge	SHORT $LN19@Getffld

; 782  : 				{	// save a significant fraction digit
; 783  : 				*_Ptr++ = (char)((*_First - _E0) + '0');

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN810@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN808@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN814@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN814@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN815@Getffld
$LN814@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN815@Getffld:
	cmp	eax, -1
	je	SHORT $LN808@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN807@Getffld
$LN808@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN807@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN810@Getffld:
	mov	cl, BYTE PTR [esi+9]
	mov	BYTE PTR [ebp], cl
	add	ebp, 1

; 784  : 				++_Significant;

	add	DWORD PTR __Significant$[esp+124], 1
$LN19@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	mov	BYTE PTR __Seendigit$[esp+124], 1
	je	SHORT $LN674@Getffld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN680@Getffld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN680@Getffld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN681@Getffld

; 776  : 			}
; 777  : 
; 778  : 		for (; _First != _Last
; 779  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 780  : 				_Seendigit = true, ++_First)

$LN680@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN681@Getffld:
	cmp	eax, -1
	je	SHORT $LN674@Getffld
	mov	BYTE PTR [esi+8], 0
	jmp	$LL1352@Getffld
$LN674@Getffld:
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi+8], 1
	jmp	$LL1352@Getffld

; 785  : 				}
; 786  : 
; 787  : 		if (_Seendigit && _First != _Last
; 788  : 			&& (*_First == _MAKLOCCHR(_Elem, 'e', _Cvt)
; 789  : 				|| *_First == _MAKLOCCHR(_Elem, 'E', _Cvt)))

$LN849@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN850@Getffld:
	cmp	eax, -1
	je	SHORT $LN843@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN842@Getffld
$LN843@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN842@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN845@Getffld:
	cmp	BYTE PTR [edi+8], 0
	jne	SHORT $LN868@Getffld
	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	je	SHORT $LN866@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN872@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN872@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN873@Getffld
$LN872@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN873@Getffld:
	cmp	eax, -1
	je	SHORT $LN866@Getffld
	mov	BYTE PTR [edi+9], al
	jmp	SHORT $LN865@Getffld
$LN866@Getffld:
	mov	DWORD PTR [edi+4], 0
$LN865@Getffld:
	mov	BYTE PTR [edi+8], 1
$LN868@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN1430@Getffld
	cmp	DWORD PTR [edi+4], ecx
	je	$LN4@Getffld
	test	ecx, ecx
	je	SHORT $LN839@Getffld
$LN1430@Getffld:
	cmp	DWORD PTR [edi+4], 0
	jne	$LN4@Getffld
$LN839@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN894@Getffld
	test	ecx, ecx
	je	SHORT $LN892@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN898@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN898@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN899@Getffld
$LN898@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN899@Getffld:
	cmp	eax, -1
	je	SHORT $LN892@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN891@Getffld
$LN892@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN891@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN894@Getffld:
	cmp	BYTE PTR [esi+9], 101			; 00000065H
	je	SHORT $LN15@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN922@Getffld
	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN920@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN926@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN926@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN927@Getffld
$LN926@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN927@Getffld:
	cmp	eax, -1
	je	SHORT $LN920@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN919@Getffld
$LN920@Getffld:
	mov	DWORD PTR [esi+4], 0
$LN919@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN922@Getffld:
	cmp	BYTE PTR [esi+9], 69			; 00000045H
	jne	$LN4@Getffld
$LN15@Getffld:

; 790  : 			{	// 'e' or 'E', collect exponent
; 791  : 			*_Ptr++ = 'e', ++_First;

	mov	eax, DWORD PTR __Ptr$[esp+124]
	mov	BYTE PTR [eax], 101			; 00000065H
	mov	ecx, DWORD PTR [esi+4]
	add	eax, 1
	test	ecx, ecx
	mov	DWORD PTR __Ptr$[esp+124], eax
	je	SHORT $LN947@Getffld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN953@Getffld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN953@Getffld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN954@Getffld
$LN953@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN954@Getffld:
	cmp	eax, -1
	je	SHORT $LN947@Getffld
	mov	BYTE PTR [esi+8], 0
	jmp	SHORT $LN946@Getffld
$LN947@Getffld:
	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 1
$LN946@Getffld:

; 792  : 			_Seendigit = false, _Significant = 0;

	xor	ebx, ebx
	xor	edi, edi

; 793  : 
; 794  : 			if (_First == _Last)

	cmp	BYTE PTR [esi+8], 0
	mov	BYTE PTR __Seendigit$[esp+124], 0
	jne	SHORT $LN980@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN978@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN984@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN984@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN985@Getffld
$LN984@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN985@Getffld:
	cmp	eax, -1
	je	SHORT $LN978@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN977@Getffld
$LN978@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN977@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN980@Getffld:
	mov	ebp, DWORD PTR __Last$GSCopy$[esp+124]
	cmp	BYTE PTR [ebp+8], 0
	jne	SHORT $LN1003@Getffld
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, ebx
	je	SHORT $LN1001@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1007@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1007@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1008@Getffld
$LN1007@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1008@Getffld:
	cmp	eax, -1
	je	SHORT $LN1001@Getffld
	mov	BYTE PTR [ebp+9], al
	jmp	SHORT $LN1000@Getffld
$LN1001@Getffld:
	mov	DWORD PTR [ebp+4], ebx
$LN1000@Getffld:
	mov	BYTE PTR [ebp+8], 1
$LN1003@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN1432@Getffld
	cmp	DWORD PTR [ebp+4], ebx
	je	$LN1377@Getffld
	cmp	ecx, ebx
	je	SHORT $LN974@Getffld
$LN1432@Getffld:
	cmp	DWORD PTR [ebp+4], ebx
	jne	$LN1377@Getffld
$LN974@Getffld:

; 795  : 				;	// 'e' or 'E' is last element
; 796  : 			else if (*_First == _MAKLOCCHR(_Elem, '+', _Cvt))

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1029@Getffld
	cmp	ecx, ebx
	je	SHORT $LN1027@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1033@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1033@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1034@Getffld
$LN1033@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1034@Getffld:
	cmp	eax, -1
	je	SHORT $LN1027@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1026@Getffld
$LN1027@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1026@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1029@Getffld:
	cmp	BYTE PTR [esi+9], 43			; 0000002bH
	jne	SHORT $LN12@Getffld

; 797  : 				*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	ebp, DWORD PTR __Ptr$[esp+124]
	mov	BYTE PTR [ebp], 43			; 0000002bH
	mov	ecx, DWORD PTR [esi+4]
	add	ebp, 1
	cmp	ecx, ebx
	mov	DWORD PTR __Ptr$[esp+124], ebp
	je	SHORT $LN1054@Getffld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], ebx
	je	$LN1111@Getffld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], ebx
	jle	$LN1111@Getffld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	$LN1112@Getffld
$LN1054@Getffld:
	mov	DWORD PTR [esi+4], ebx
	mov	BYTE PTR [esi+8], 1
	jmp	$LL9@Getffld
$LN12@Getffld:

; 798  : 			else if (*_First == _MAKLOCCHR(_Elem, '-', _Cvt))

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1080@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN1078@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1084@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1084@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1085@Getffld
$LN1084@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1085@Getffld:
	cmp	eax, -1
	je	SHORT $LN1078@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1077@Getffld
$LN1078@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1077@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1080@Getffld:
	cmp	BYTE PTR [esi+9], 45			; 0000002dH
	jne	SHORT $LN1377@Getffld

; 799  : 				*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	ebp, DWORD PTR __Ptr$[esp+124]
	mov	BYTE PTR [ebp], 45			; 0000002dH
	mov	ecx, DWORD PTR [esi+4]
	add	ebp, 1
	cmp	ecx, ebx
	mov	DWORD PTR __Ptr$[esp+124], ebp
	je	SHORT $LN1054@Getffld
	mov	edx, DWORD PTR [ecx+32]
	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN1111@Getffld
	mov	eax, DWORD PTR [ecx+48]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN1111@Getffld
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1112@Getffld
$LN1111@Getffld:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+20]
	call	edx
$LN1112@Getffld:
	cmp	eax, -1
	je	$LN1054@Getffld
	mov	BYTE PTR [esi+8], 0
	jmp	SHORT $LL9@Getffld
$LN1377@Getffld:
	mov	ebp, DWORD PTR __Ptr$[esp+124]
	npad	1
$LL9@Getffld:

; 800  : 			for (; _First != _Last && *_First == _E0; )

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1140@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN1138@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1144@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1144@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1145@Getffld
$LN1144@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1145@Getffld:
	cmp	eax, -1
	je	SHORT $LN1138@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1137@Getffld
$LN1138@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1137@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1140@Getffld:
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
	cmp	BYTE PTR [edx+8], 0
	jne	SHORT $LN1163@Getffld
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, ebx
	je	SHORT $LN1161@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1167@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1167@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1168@Getffld
$LN1167@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1168@Getffld:
	cmp	eax, -1
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
	je	SHORT $LN1161@Getffld
	mov	BYTE PTR [edx+9], al
	jmp	SHORT $LN1160@Getffld
$LN1161@Getffld:
	mov	DWORD PTR [edx+4], ebx
$LN1160@Getffld:
	mov	BYTE PTR [edx+8], 1
$LN1163@Getffld:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	jne	SHORT $LN1349@Getffld
	cmp	DWORD PTR [edx+4], ebx
	jne	SHORT $LN1134@Getffld
$LN1135@Getffld:

; 802  : 			if (_Seendigit)

	cmp	BYTE PTR __Seendigit$[esp+124], 0
	je	SHORT $LN7@Getffld

; 803  : 				*_Ptr++ = '0';	// put one back

	mov	BYTE PTR [ebp], 48			; 00000030H
	add	ebp, 1
	mov	DWORD PTR __Ptr$[esp+124], ebp
$LN7@Getffld:

; 804  : 			for (; _First != _Last
; 805  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 806  : 				_Seendigit = true, ++_First)

	mov	ecx, DWORD PTR __Last$GSCopy$[esp+124]
	push	ecx
	push	esi
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	je	$LN4@Getffld
$LL1211@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	$LN1219@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	$LN1217@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1223@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1223@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1224@Getffld
$LN1349@Getffld:

; 800  : 			for (; _First != _Last && *_First == _E0; )

	cmp	DWORD PTR [edx+4], ebx
	jne	SHORT $LN1135@Getffld
$LN1134@Getffld:
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1189@Getffld
	cmp	ecx, ebx
	je	SHORT $LN1187@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1193@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1193@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1194@Getffld
$LN1193@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1194@Getffld:
	cmp	eax, -1
	je	SHORT $LN1187@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1186@Getffld
$LN1187@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1186@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1189@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jne	$LN1135@Getffld

; 801  : 				_Seendigit = true, ++_First;	// strip leading zeros

	mov	ecx, esi
	mov	BYTE PTR __Seendigit$[esp+124], 1
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
	jmp	$LL9@Getffld

; 804  : 			for (; _First != _Last
; 805  : 				&& _E0 <= *_First && *_First <= _E0 + 9;
; 806  : 				_Seendigit = true, ++_First)

$LN1223@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1224@Getffld:
	cmp	eax, -1
	je	SHORT $LN1217@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1216@Getffld
$LN1217@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1216@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1219@Getffld:
	cmp	BYTE PTR [esi+9], 48			; 00000030H
	jl	$LN1422@Getffld
	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1245@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN1243@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1249@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1249@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1250@Getffld
$LN1249@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1250@Getffld:
	cmp	eax, -1
	je	SHORT $LN1243@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1242@Getffld
$LN1243@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1242@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1245@Getffld:
	cmp	BYTE PTR [esi+9], 57			; 00000039H
	jg	SHORT $LN1422@Getffld

; 807  : 				if (_Significant < _MAX_EXP_DIG)

	cmp	edi, 8
	jge	SHORT $LN5@Getffld

; 808  : 					{	// save a significant exponent digit
; 809  : 					*_Ptr++ = (char)((*_First - _E0) + '0');

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN1271@Getffld
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, ebx
	je	SHORT $LN1269@Getffld
	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN1275@Getffld
	mov	edx, DWORD PTR [ecx+48]
	cmp	DWORD PTR [edx], ebx
	jle	SHORT $LN1275@Getffld
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN1276@Getffld
$LN1275@Getffld:
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN1276@Getffld:
	cmp	eax, -1
	je	SHORT $LN1269@Getffld
	mov	BYTE PTR [esi+9], al
	jmp	SHORT $LN1268@Getffld
$LN1269@Getffld:
	mov	DWORD PTR [esi+4], ebx
$LN1268@Getffld:
	mov	BYTE PTR [esi+8], 1
$LN1271@Getffld:
	mov	cl, BYTE PTR [esi+9]
	mov	BYTE PTR [ebp], cl
	add	ebp, 1

; 810  : 					++_Significant;

	add	edi, 1
$LN5@Getffld:
	mov	ecx, esi
	mov	BYTE PTR __Seendigit$[esp+124], 1
	call	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
	mov	edx, DWORD PTR __Last$GSCopy$[esp+124]
	push	edx
	push	esi
	call	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
	add	esp, 8
	test	al, al
	jne	$LL1211@Getffld
$LN1422@Getffld:

; 808  : 					{	// save a significant exponent digit
; 809  : 					*_Ptr++ = (char)((*_First - _E0) + '0');

	mov	DWORD PTR __Ptr$[esp+124], ebp
$LN4@Getffld:

; 811  : 					}
; 812  : 			}
; 813  : 
; 814  : 		if (_Bad || !_Seendigit)

	cmp	BYTE PTR __Bad$[esp+124], 0
	jne	SHORT $LN1@Getffld
	cmp	BYTE PTR __Seendigit$[esp+124], 0
	jne	SHORT $LN1378@Getffld
$LN1@Getffld:

; 815  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$GSCopy$[esp+124]
	jmp	SHORT $LN2@Getffld
$LN1378@Getffld:
	mov	eax, DWORD PTR __Ptr$[esp+124]
$LN2@Getffld:

; 816  : 		*_Ptr = '\0';
; 817  : 		return (_Pten);

	cmp	DWORD PTR __Grouping$[esp+148], 16	; 00000010H
	mov	BYTE PTR [eax], 0
	jb	SHORT $LN1360@Getffld
	mov	eax, DWORD PTR __Grouping$[esp+128]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1360@Getffld:
	mov	eax, DWORD PTR __Pten$[esp+124]

; 818  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 104				; 00000068H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z$1:
	lea	ecx, DWORD PTR __Groups$18030[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-108]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 738  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 739  : 	typedef char _Elem;
; 740  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 741  : 	ios_base::iostate _State = ios_base::goodbit;
; 742  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
	lea	edx, DWORD PTR [eax+1]
$LL133@operator@7:
	mov	cl, BYTE PTR [eax]
	add	eax, 1
	test	cl, cl
	jne	SHORT $LL133@operator@7

; 743  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 744  : 		? 0 : _Ostr.width() - _Count;

	mov	esi, DWORD PTR __Ostr$[ebp]
	sub	eax, edx
	mov	edi, eax
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	cmp	eax, ebx
	jle	SHORT $LN17@operator@7
	cmp	eax, edi
	jle	SHORT $LN17@operator@7
	sub	eax, edi
	mov	ebx, eax
	mov	DWORD PTR __Pad$[ebp], eax
	jmp	SHORT $LN18@operator@7
$LN17@operator@7:
	mov	DWORD PTR __Pad$[ebp], ebx
$LN18@operator@7:

; 745  : 	const typename _Myos::sentry _Ok(_Ostr);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 746  : 
; 747  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jne	SHORT $LN14@operator@7

; 748  : 		_State |= ios_base::badbit;

	mov	edx, 4

; 749  : 	else

	jmp	$LN22@operator@7
$LN14@operator@7:

; 750  : 		{	// state okay, insert
; 751  : 		_TRY_IO_BEGIN
; 752  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $LN131@operator@7
	npad	6
$LL10@operator@7:

; 753  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jle	SHORT $LN8@operator@7

; 754  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 755  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [edx+esi+48]
	lea	ecx, DWORD PTR [edx+esi]
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN42@operator@7
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN42@operator@7
	add	DWORD PTR [edx], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR __Pad$[ebp]
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN43@operator@7
$LN42@operator@7:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN43@operator@7:
	cmp	eax, -1
	jne	SHORT $LN9@operator@7

; 756  : 					{	// insertion failed, quit
; 757  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN8@operator@7:

; 758  : 					break;
; 759  : 					}
; 760  : 
; 761  : 		if (_State == ios_base::goodbit
; 762  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@7
$LN131@operator@7:
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+esi+40]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+32]
	push	edi
	push	DWORD PTR __Val$[ebp]
	call	edx
	cmp	eax, edi
	je	SHORT $LL132@operator@7

; 763  : 			_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN2@operator@7:

; 772  : 					}
; 773  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx

; 774  : 		_CATCH_IO_(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], ecx
$LN140@operator@7:
	mov	edx, DWORD PTR __State$[ebp]
$LN22@operator@7:

; 775  : 		}
; 776  : 
; 777  : 	_Ostr.setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN125@operator@7
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN127@operator@7
	or	eax, 4
$LN127@operator@7:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN125@operator@7:

; 778  : 	return (_Ostr);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 779  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@operator@7:

; 753  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	sub	ebx, 1
	mov	DWORD PTR __Pad$[ebp], ebx
	jmp	$LL10@operator@7
$LL132@operator@7:

; 764  : 
; 765  : 		if (_State == ios_base::goodbit)
; 766  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jle	SHORT $LN2@operator@7

; 767  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 768  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+esi+48]
	add	ecx, esi
	mov	ecx, DWORD PTR [ecx+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN68@operator@7
	mov	edx, DWORD PTR [ecx+52]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN68@operator@7
	add	DWORD PTR [edx], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	edx, DWORD PTR [ecx]
	lea	edi, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], edi
	mov	BYTE PTR [edx], al
	movzx	eax, al
	jmp	SHORT $LN69@operator@7
$LN68@operator@7:
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN69@operator@7:
	cmp	eax, -1
	jne	SHORT $LN3@operator@7

; 769  : 					{	// insertion failed, quit
; 770  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4

; 771  : 					break;

	jmp	$LN2@operator@7
$LN3@operator@7:

; 764  : 
; 765  : 		if (_State == ios_base::goodbit)
; 766  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	sub	ebx, 1
	jmp	SHORT $LL132@operator@7
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 774  : 		_CATCH_IO_(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN93@operator@7
	or	ecx, 4
$LN93@operator@7:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN102@operator@7
	mov	eax, $LN23@operator@7
	ret	0
$LN23@operator@7:
	mov	esi, DWORD PTR __Ostr$[ebp]
	jmp	$LN140@operator@7
$LN102@operator@7:
	push	0
	push	0
	call	__CxxThrowException@8
$LN139@operator@7:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 02H
	DD	02H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$10
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
$T36850 = -52						; size = 12
$T36849 = -52						; size = 12
__Ok$ = -40						; size = 8
$T36865 = -32						; size = 1
$T36846 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 1
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 189  : 		{	// insert a boolean

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 190  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 191  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 192  : 
; 193  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	je	$LN12@operator@8

; 194  : 			{	// state okay, use facet to insert
; 195  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T36846[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	lea	ecx, DWORD PTR $T36846[ebp]
	mov	edi, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 196  : 
; 197  : 			_TRY_IO_BEGIN
; 198  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 199  : 				_Myios::fill(), _Val).failed())

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [edx+esi]
	mov	dl, BYTE PTR [ecx+48]
	mov	ecx, DWORD PTR [ecx+40]
	mov	BYTE PTR $T36865[ebp], dl
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	edx, DWORD PTR $T36865[ebp]
	push	edx
	add	eax, esi
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR $T36849[ebp+4], bl
	mov	edx, DWORD PTR $T36849[ebp+4]
	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+32]
	mov	DWORD PTR [eax+8], ecx
	lea	eax, DWORD PTR $T36850[ebp]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	edx
	cmp	BYTE PTR $T36850[ebp+4], 0

; 200  : 				_State |= ios_base::badbit;

	mov	edi, 4
	jne	SHORT $LN1@operator@8
	mov	edi, DWORD PTR __State$[ebp]
$LN1@operator@8:

; 201  : 			_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@operator@8:

; 202  : 			}
; 203  : 
; 204  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN71@operator@8
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@8
	or	eax, 4
$LN73@operator@8:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@8:

; 205  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 206  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$0:

; 201  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN39@operator@8
	or	ecx, 4
$LN39@operator@8:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN48@operator@8
	mov	eax, $LN13@operator@8
	ret	0
$LN13@operator@8:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	jmp	SHORT $LN12@operator@8
$LN48@operator@8:
	push	0
	push	0
	call	__CxxThrowException@8
$LN78@operator@8:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z$3:
	lea	ecx, DWORD PTR $T36846[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z DD 02H
	DD	02H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$10
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
_TEXT	SEGMENT
$T37057 = -52						; size = 12
$T37056 = -52						; size = 12
__Ok$ = -40						; size = 8
$T37072 = -32						; size = 1
$T37053 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 307  : 		{	// insert a long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 308  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 309  : 		const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 310  : 
; 311  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	je	$LN12@operator@9

; 312  : 			{	// state okay, use facet to insert
; 313  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T37053[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	lea	ecx, DWORD PTR $T37053[ebp]
	mov	edi, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 314  : 
; 315  : 			_TRY_IO_BEGIN
; 316  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 317  : 				_Myios::fill(), _Val).failed())

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [edx+esi]
	mov	dl, BYTE PTR [ecx+48]
	mov	ecx, DWORD PTR [ecx+40]
	mov	BYTE PTR $T37072[ebp], dl
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	edx, DWORD PTR $T37072[ebp]
	push	edx
	add	eax, esi
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR $T37056[ebp+4], bl
	mov	edx, DWORD PTR $T37056[ebp+4]
	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ebx+28]
	mov	DWORD PTR [eax+8], ecx
	lea	eax, DWORD PTR $T37057[ebp]
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	edx
	cmp	BYTE PTR $T37057[ebp+4], 0

; 318  : 				_State |= ios_base::badbit;

	mov	edi, 4
	jne	SHORT $LN1@operator@9
	mov	edi, DWORD PTR __State$[ebp]
$LN1@operator@9:

; 319  : 			_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@operator@9:

; 320  : 			}
; 321  : 
; 322  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN71@operator@9
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN73@operator@9
	or	eax, 4
$LN73@operator@9:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN71@operator@9:

; 323  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, esi

; 324  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$0:

; 319  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN39@operator@9
	or	ecx, 4
$LN39@operator@9:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN48@operator@9
	mov	eax, $LN13@operator@9
	ret	0
$LN13@operator@9:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	jmp	SHORT $LN12@operator@9
$LN48@operator@9:
	push	0
	push	0
	call	__CxxThrowException@8
$LN78@operator@9:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z$3:
	lea	ecx, DWORD PTR $T37053[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\ios
xdata$x	SEGMENT
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 01H
	DD	01H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$9
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	02H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
xdata$x	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 506  : 		{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 507  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 508  : 		const sentry _Ok(*this);

	push	edi
	lea	ecx, DWORD PTR __Ok$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], esi
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 509  : 
; 510  : 		if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	jne	SHORT $LN4@put

; 511  : 			_State |= ios_base::badbit;

	mov	esi, 4

; 512  : 		else

	jmp	SHORT $LN11@put
$LN4@put:

; 513  : 			{	// state okay, insert character
; 514  : 			_TRY_IO_BEGIN
; 515  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 516  : 				_Myios::rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+edi+40]
	mov	edx, DWORD PTR [ecx+36]
	cmp	DWORD PTR [edx], ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $LN18@put
	mov	eax, DWORD PTR [ecx+52]
	cmp	DWORD PTR [eax], ebx
	jle	SHORT $LN18@put
	add	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx], edx
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	movzx	eax, cl
	jmp	SHORT $LN19@put
$LN18@put:
	movzx	eax, BYTE PTR __Ch$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN19@put:
	cmp	eax, -1
	jne	SHORT $LN1@put

; 517  : 				_State |= ios_base::badbit;

	mov	esi, 4
$LN1@put:

; 518  : 			_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	jmp	SHORT $LN11@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN41@put
	or	ecx, 4
$LN41@put:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN50@put
	mov	eax, $LN78@put
	ret	0
$LN78@put:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __State$[ebp]
$LN11@put:

; 519  : 			}
; 520  : 
; 521  : 		_Myios::setstate(_State);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
	test	esi, esi
	je	SHORT $LN73@put
	mov	eax, DWORD PTR [ecx+8]
	or	eax, esi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN75@put
	or	eax, 4
$LN75@put:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN73@put:

; 522  : 		return (*this);

	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, edi

; 523  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4

; 518  : 			_CATCH_IO_END

$LN50@put:
	push	0
	push	0
	call	__CxxThrowException@8
$LN80@put:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\streambuf
xdata$x	SEGMENT
__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$0
__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z DD 02H
	DD	02H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$11
__ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z
	DD	01H
	DD	FLAT:__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\istream
xdata$x	ENDS
;	COMDAT ??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z
_TEXT	SEGMENT
$T37474 = -60						; size = 12
$T37473 = -60						; size = 12
$T37472 = -48						; size = 12
__Ok$ = -36						; size = 8
$T37469 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z PROC ; std::basic_istream<char,std::char_traits<char> >::operator>>, COMDAT
; _this$ = ecx

; 292  : 		{	// extract a long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 293  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 294  : 		const sentry _Ok(*this);

	push	edi
	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry

; 295  : 
; 296  : 		if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+12], edi
	je	$LN11@operator@10

; 297  : 			{	// state okay, use facet to extract
; 298  : 			const _Nget& _Nget_fac = _USE(ios_base::getloc(), _Nget);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T37469[ebp]
	push	eax
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	bl, 1
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	call	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	lea	ecx, DWORD PTR $T37469[ebp]
	mov	edi, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 299  : 			_TRY_IO_BEGIN
; 300  : 			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
; 301  : 				*this, _State, _Val);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+40]
	add	eax, esi
	test	ecx, ecx
	sete	dl
	mov	BYTE PTR $T37473[ebp+8], dl
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	edx, DWORD PTR __State$[ebp]
	push	edx
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	BYTE PTR $T37472[ebp+8], bl
	mov	edx, DWORD PTR $T37472[ebp+8]
	mov	ebx, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], edx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	xor	edx, edx
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR $T37473[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR [ebx+32]
	lea	edx, DWORD PTR $T37474[ebp]
	push	edx
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	eax

; 302  : 			_CATCH_IO_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN11@operator@10:

; 303  : 			}
; 304  : 
; 305  : 		_Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __State$[ebp]
	add	ecx, esi
	test	edx, edx
	je	SHORT $LN70@operator@10
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edx
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN72@operator@10
	or	eax, 4
$LN72@operator@10:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN70@operator@10:

; 306  : 		return (*this);

	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	je	SHORT $LN84@operator@10
	lea	ecx, DWORD PTR [eax+4]
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock
$LN84@operator@10:
	mov	eax, esi

; 307  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$0:

; 302  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 4
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN38@operator@10
	or	ecx, 4
$LN38@operator@10:
	and	ecx, 23					; 00000017H
	test	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN47@operator@10
	mov	eax, $LN12@operator@10
	ret	0
$LN12@operator@10:
	mov	esi, DWORD PTR _this$[ebp]
	jmp	$LN11@operator@10
$LN47@operator@10:
	push	0
	push	0
	call	__CxxThrowException@8
$LN87@operator@10:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z$3:
	lea	ecx, DWORD PTR $T37469[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::operator>>
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	_sprintf_s:PROC
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 960  : 		{	// put formatted long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[esp+76]

; 961  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 962  : 		char _Buf[_Buf_size], _Fmt[6];
; 963  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 964  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "ld",
; 965  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR [ebx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Val$[esp+84]
	push	ecx
	push	eax
	push	OFFSET ??_C@_02EAOCLKAK@ld?$AA@
	lea	edx, DWORD PTR __Fmt$[esp+100]
	push	edx
	push	esi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	mov	edx, DWORD PTR __Fill$[esp+100]
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+92]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+100]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+120]
	push	edi
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 966  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+124]
	add	esp, 36					; 00000024H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 970  : 		{	// put formatted unsigned long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[esp+76]

; 971  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 972  : 		char _Buf[_Buf_size], _Fmt[6];
; 973  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 974  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "lu",
; 975  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR [ebx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Val$[esp+84]
	push	ecx
	push	eax
	push	OFFSET ??_C@_02BDDLJJBK@lu?$AA@
	lea	edx, DWORD PTR __Fmt$[esp+100]
	push	edx
	push	esi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	mov	edx, DWORD PTR __Fill$[esp+100]
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+92]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+92]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+100]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+120]
	push	edi
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 976  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+124]
	add	esp, 36					; 00000024H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 981  : 		{	// put formatted long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 982  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 983  : 		char _Buf[_Buf_size], _Fmt[8];
; 984  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 985  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Ld",
; 986  : 				_Iosbase.flags()), _Val)));

	mov	edx, DWORD PTR __Val$[esp+72]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[esp+76]
	mov	eax, DWORD PTR [ebx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Val$[esp+88]
	push	ecx
	push	edx
	push	eax
	push	OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+104]
	push	eax
	push	esi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Dest$[esp+104]
	add	esp, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+88]
	lea	edx, DWORD PTR __Buf$[esp+92]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+96]
	push	eax
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+120]
	push	edi
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 987  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+124]
	add	esp, 36					; 00000024H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\xiosbase
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 991  : 		{	// put formatted unsigned long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax

; 992  : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 993  : 		char _Buf[_Buf_size], _Fmt[8];
; 994  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 995  : 			::sprintf_s(_Buf, _Buf_size, _Ifmt(_Fmt, "Lu",
; 996  : 				_Iosbase.flags()), _Val)));

	mov	edx, DWORD PTR __Val$[esp+72]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[esp+76]
	mov	eax, DWORD PTR [ebx+16]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Val$[esp+88]
	push	ecx
	push	edx
	push	eax
	push	OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
	lea	eax, DWORD PTR __Fmt$[esp+104]
	push	eax
	push	esi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	ecx
	call	_sprintf_s
	mov	ecx, DWORD PTR __Dest$[esp+104]
	add	esp, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __Fill$[esp+88]
	lea	edx, DWORD PTR __Buf$[esp+92]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+96]
	push	eax
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+120]
	push	edi
	mov	DWORD PTR [eax+4], edx
	push	esi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 997  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+124]
	add	esp, 36					; 00000024H
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__real@38aa95a5b7f87a0f
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@4733426172c74d82
PUBLIC	__real@0000000000000000
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__fltused:DWORD
;	COMDAT __real@38aa95a5b7f87a0f
CONST	SEGMENT
__real@38aa95a5b7f87a0f DQ 038aa95a5b7f87a0fr	; 1e-035
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+010
CONST	ENDS
;	COMDAT __real@4733426172c74d82
CONST	SEGMENT
__real@4733426172c74d82 DQ 04733426172c74d82r	; 1e+035
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Signed$17457 = -129					; size = 1
_this$ = -128						; size = 4
___$ReturnUdt$GSCopy$ = -124				; size = 4
__Fmt$ = -120						; size = 8
__Buf$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1002 : 		{	// put formatted double to _Dest

	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+132], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+128]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Iosbase$[esp+136]

; 1033 : 			}
; 1034 : 
; 1035 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1036 : 			_Beforepoint, _Afterpoint, _Precision,
; 1037 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1038 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+140], eax
	mov	eax, DWORD PTR [ebp+20]
	test	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+148], ecx
	jg	SHORT $LN13@do_put@2

; 1003 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1004 : 		char _Buf[_Buf_size], _Fmt[8];
; 1005 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1006 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1007 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [ebp+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put@2
	mov	eax, 6
$LN13@do_put@2:
	mov	esi, eax

; 1008 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1009 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put@2
	mov	edx, esi
$LN16@do_put@2:

; 1010 : 		_Precision -= _Significance;
; 1011 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1012 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1013 : 
; 1014 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN41@do_put@2

; 1015 : 			{	// scale silly fixed-point value
; 1016 : 			bool _Signed = _Val < 0;

	fldz
	fld	QWORD PTR __Val$[esp+144]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@do_put@2
	mov	BYTE PTR __Signed$17457[esp+148], 1

; 1018 : 				_Val = -_Val;

	fchs
$LN9@do_put@2:

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fld	QWORD PTR __real@4733426172c74d82
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR __real@4202a05f20000000
	test	ah, 65					; 00000041H
	jnp	SHORT $LN8@do_put@2
$LN47@do_put@2:
	fstp	ST(1)
	jmp	SHORT $LN6@do_put@2
$LN17@do_put@2:

; 1015 : 			{	// scale silly fixed-point value
; 1016 : 			bool _Signed = _Val < 0;

	mov	BYTE PTR __Signed$17457[esp+148], bl

; 1017 : 			if (_Signed)

	jmp	SHORT $LN9@do_put@2
$LN53@do_put@2:

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fxch	ST(1)
$LN8@do_put@2:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN47@do_put@2

; 1021 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fdiv	ST(2), ST(0)
	add	ebx, 10					; 0000000aH
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN53@do_put@2

; 1019 : 
; 1020 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fstp	ST(0)
$LN6@do_put@2:

; 1022 : 
; 1023 : 			if (0 < _Val)

	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN55@do_put@2

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN55@do_put@2
	fld	QWORD PTR __real@38aa95a5b7f87a0f
	jmp	SHORT $LN4@do_put@2
$LN68@do_put@2:
	fxch	ST(1)
$LN4@do_put@2:
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN62@do_put@2
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN62@do_put@2

; 1026 : 					{	// drop 10 zeros after decimal point
; 1027 : 					_Val *= 1e10;
; 1028 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	fxch	ST(1)
	add	edi, 10					; 0000000aH
	fmul	ST(0), ST(2)
	cmp	esi, 10					; 0000000aH
	jge	SHORT $LN68@do_put@2

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(1)
$LN55@do_put@2:

; 1029 : 					}
; 1030 : 
; 1031 : 			if (_Signed)

	cmp	BYTE PTR __Signed$17457[esp+148], 0
	fstp	ST(1)
	je	SHORT $LN1@do_put@2

; 1032 : 				_Val = -_Val;

	fchs
	jmp	SHORT $LN1@do_put@2
$LN62@do_put@2:

; 1024 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1025 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(0)
	jmp	SHORT $LN55@do_put@2
$LN41@do_put@2:

; 1032 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[esp+144]
$LN1@do_put@2:

; 1033 : 			}
; 1034 : 
; 1035 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1036 : 			_Beforepoint, _Afterpoint, _Precision,
; 1037 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1038 : 					_Significance, _Val)));	// convert and put

	test	cl, 32					; 00000020H
	mov	BYTE PTR __Fmt$[esp+148], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+149]
	je	SHORT $LN31@do_put@2
	mov	BYTE PTR __Fmt$[esp+149], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+150]
$LN31@do_put@2:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put@2
	mov	BYTE PTR [eax], 35			; 00000023H
	add	eax, 1
$LN30@do_put@2:
	mov	BYTE PTR [eax], 46			; 0000002eH
	add	eax, 1
	mov	BYTE PTR [eax], 42			; 0000002aH
	and	ecx, 12288				; 00003000H
	add	eax, 1
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN34@do_put@2
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put@2
$LN34@do_put@2:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put@2:
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	BYTE PTR [eax], cl
	lea	ecx, DWORD PTR __Fmt$[esp+160]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+164]
	push	108					; 0000006cH
	push	edx
	mov	BYTE PTR [eax+1], 0
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[esp+168]
	mov	edx, DWORD PTR __Dest$[esp+168]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+156]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+164]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+172]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+192]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[esp+188]
	push	esi
	push	eax
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1039 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+196]
	add	esp, 48					; 00000030H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 132				; 00000084H
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtpy
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Signed$17485 = -129					; size = 1
_this$ = -128						; size = 4
___$ReturnUdt$GSCopy$ = -124				; size = 4
__Fmt$ = -120						; size = 8
__Buf$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1043 : 		{	// put formatted long double to _Dest

	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+132], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+128]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Iosbase$[esp+136]

; 1074 : 			}
; 1075 : 
; 1076 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1077 : 			_Beforepoint, _Afterpoint, _Precision,
; 1078 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1079 : 					_Significance, _Val)));	// convert and put

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+140], eax
	mov	eax, DWORD PTR [ebp+20]
	test	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+148], ecx
	jg	SHORT $LN13@do_put@3

; 1044 : 		const size_t _Buf_size = _MAX_EXP_DIG + _MAX_SIG_DIG + 64;
; 1045 : 		char _Buf[_Buf_size], _Fmt[8];
; 1046 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1047 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1048 : 				? 6 : _Iosbase.precision();	// desired precision

	test	DWORD PTR [ebp+16], 8192		; 00002000H
	jne	SHORT $LN13@do_put@3
	mov	eax, 6
$LN13@do_put@3:
	mov	esi, eax

; 1049 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1050 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	esi, 36					; 00000024H
	mov	edx, 36					; 00000024H
	jg	SHORT $LN16@do_put@3
	mov	edx, esi
$LN16@do_put@3:

; 1051 : 		_Precision -= _Significance;
; 1052 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1053 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1054 : 
; 1055 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, ecx
	and	eax, 12288				; 00003000H
	sub	esi, edx
	xor	ebx, ebx
	xor	edi, edi
	cmp	eax, 8192				; 00002000H
	jne	$LN41@do_put@3

; 1056 : 			{	// scale silly fixed-point value
; 1057 : 			bool _Signed = _Val < 0;

	fldz
	fld	QWORD PTR __Val$[esp+144]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@do_put@3
	mov	BYTE PTR __Signed$17485[esp+148], 1

; 1059 : 				_Val = -_Val;

	fchs
$LN9@do_put@3:

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fld	QWORD PTR __real@4733426172c74d82
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR __real@4202a05f20000000
	test	ah, 65					; 00000041H
	jnp	SHORT $LN8@do_put@3
$LN47@do_put@3:
	fstp	ST(1)
	jmp	SHORT $LN6@do_put@3
$LN17@do_put@3:

; 1056 : 			{	// scale silly fixed-point value
; 1057 : 			bool _Signed = _Val < 0;

	mov	BYTE PTR __Signed$17485[esp+148], bl

; 1058 : 			if (_Signed)

	jmp	SHORT $LN9@do_put@3
$LN53@do_put@3:

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fxch	ST(1)
$LN8@do_put@3:
	cmp	ebx, 5000				; 00001388H
	jae	SHORT $LN47@do_put@3

; 1062 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fdiv	ST(2), ST(0)
	add	ebx, 10					; 0000000aH
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN53@do_put@3

; 1060 : 
; 1061 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	fstp	ST(0)
$LN6@do_put@3:

; 1063 : 
; 1064 : 			if (0 < _Val)

	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN55@do_put@3

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	cmp	esi, 10					; 0000000aH
	jl	SHORT $LN55@do_put@3
	fld	QWORD PTR __real@38aa95a5b7f87a0f
	jmp	SHORT $LN4@do_put@3
$LN68@do_put@3:
	fxch	ST(1)
$LN4@do_put@3:
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN62@do_put@3
	cmp	edi, 5000				; 00001388H
	jae	SHORT $LN62@do_put@3

; 1067 : 					{	// drop 10 zeros after decimal point
; 1068 : 					_Val *= 1e10;
; 1069 : 					_Precision -= 10;

	sub	esi, 10					; 0000000aH
	fxch	ST(1)
	add	edi, 10					; 0000000aH
	fmul	ST(0), ST(2)
	cmp	esi, 10					; 0000000aH
	jge	SHORT $LN68@do_put@3

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(1)
$LN55@do_put@3:

; 1070 : 					}
; 1071 : 
; 1072 : 			if (_Signed)

	cmp	BYTE PTR __Signed$17485[esp+148], 0
	fstp	ST(1)
	je	SHORT $LN1@do_put@3

; 1073 : 				_Val = -_Val;

	fchs
	jmp	SHORT $LN1@do_put@3
$LN62@do_put@3:

; 1065 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1066 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	fstp	ST(0)
	jmp	SHORT $LN55@do_put@3
$LN41@do_put@3:

; 1073 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[esp+144]
$LN1@do_put@3:

; 1074 : 			}
; 1075 : 
; 1076 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1077 : 			_Beforepoint, _Afterpoint, _Precision,
; 1078 : 				::sprintf_s(_Buf, _Buf_size, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1079 : 					_Significance, _Val)));	// convert and put

	test	cl, 32					; 00000020H
	mov	BYTE PTR __Fmt$[esp+148], 37		; 00000025H
	lea	eax, DWORD PTR __Fmt$[esp+149]
	je	SHORT $LN31@do_put@3
	mov	BYTE PTR __Fmt$[esp+149], 43		; 0000002bH
	lea	eax, DWORD PTR __Fmt$[esp+150]
$LN31@do_put@3:
	test	cl, 16					; 00000010H
	je	SHORT $LN30@do_put@3
	mov	BYTE PTR [eax], 35			; 00000023H
	add	eax, 1
$LN30@do_put@3:
	mov	BYTE PTR [eax], 46			; 0000002eH
	add	eax, 1
	mov	BYTE PTR [eax], 42			; 0000002aH
	add	eax, 1
	mov	BYTE PTR [eax], 76			; 0000004cH
	and	ecx, 12288				; 00003000H
	add	eax, 1
	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN34@do_put@3
	mov	cl, 102					; 00000066H
	jmp	SHORT $LN35@do_put@3
$LN34@do_put@3:
	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx+ecx+101]
$LN35@do_put@3:
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	mov	BYTE PTR [eax], cl
	lea	ecx, DWORD PTR __Fmt$[esp+160]
	push	ecx
	lea	edx, DWORD PTR __Buf$[esp+164]
	push	108					; 0000006cH
	push	edx
	mov	BYTE PTR [eax+1], 0
	call	_sprintf_s
	mov	ecx, DWORD PTR __Fill$[esp+168]
	mov	edx, DWORD PTR __Dest$[esp+168]
	add	esp, 24					; 00000018H
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$[esp+156]
	push	edi
	push	ebx
	lea	eax, DWORD PTR __Buf$[esp+164]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+172]
	push	ebp
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR __Dest$[esp+192]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[esp+188]
	push	esi
	push	eax
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1080 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+196]
	add	esp, 48					; 00000030H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 132				; 00000084H
	ret	32					; 00000020H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 12
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Val$ = 32						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1084 : 		{	// put formatted void pointer to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	eax, DWORD PTR __Val$[esp+64]
	push	ebx
	mov	ebx, DWORD PTR __Iosbase$[esp+68]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	edi

; 1085 : 		const size_t _Buf_size = 2 * _MAX_INT_DIG;
; 1086 : 		char _Buf[_Buf_size];
; 1087 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1088 : 			::sprintf_s(_Buf, _Buf_size, "%p", _Val)));

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	eax, DWORD PTR __Buf$[esp+88]
	push	64					; 00000040H
	push	eax
	mov	edi, ecx
	call	_sprintf_s
	mov	edx, DWORD PTR __Fill$[esp+92]
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+84]
	push	ecx
	mov	ecx, DWORD PTR __Dest$[esp+84]
	push	edx
	mov	edx, DWORD PTR __Dest$[esp+92]
	push	ebx
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Dest$[esp+112]
	push	esi
	mov	DWORD PTR [eax+4], edx
	push	edi
	mov	DWORD PTR [eax+8], ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1089 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	add	esp, 36					; 00000024H
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__Stoulx:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
__State$GSCopy$ = -104					; size = 4
__Errno$17548 = -100					; size = 4
__Ep$17547 = -96					; size = 4
__Val$GSCopy$ = -92					; size = 4
___$ReturnUdt$GSCopy$ = -88				; size = 4
$T37943 = -84						; size = 4
$T37946 = -80						; size = 4
__Str$17532 = -76					; size = 28
__Ac$17546 = -48					; size = 32
$T37945 = -48						; size = 28
$T37944 = -48						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 342  : 		{	// get bool from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+104], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+120]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+116]
	mov	esi, DWORD PTR __Iosbase$[esp+116]
	mov	edx, DWORD PTR __Val$[esp+116]
	mov	edi, ecx
	mov	ecx, DWORD PTR __State$[esp+116]

; 372  : 			_Val = _Ans != 0;	// deliver value

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+120], eax
	mov	eax, DWORD PTR [esi+16]
	or	ebp, -1
	test	eax, 16384				; 00004000H
	mov	DWORD PTR __State$GSCopy$[esp+120], ecx
	mov	DWORD PTR __Val$GSCopy$[esp+120], edx
	mov	ecx, esi
	je	$LN6@do_get
	lea	eax, DWORD PTR $T37943[esp+120]
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[esp+132], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	lea	ecx, DWORD PTR $T37943[esp+120]
	mov	esi, eax
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	mov	ebp, 1
	mov	DWORD PTR __Str$17532[esp+144], 15	; 0000000fH
	mov	BYTE PTR __Str$17532[esp+124], 0
	mov	DWORD PTR __Str$17532[esp+140], ebp
	mov	BYTE PTR __Str$17532[esp+125], 0
	lea	ecx, DWORD PTR $T37944[esp+120]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+132], ebp
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$17532[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	edi, 16					; 00000010H
	cmp	DWORD PTR $T37944[esp+144], edi
	mov	BYTE PTR __$EHRec$[esp+128], 1
	jb	SHORT $LN146@do_get
	mov	edx, DWORD PTR $T37944[esp+124]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN146@do_get:
	push	0
	push	ebp
	lea	ecx, DWORD PTR __Str$17532[esp+128]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	lea	eax, DWORD PTR $T37945[esp+120]
	push	eax
	mov	ecx, esi
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$17532[esp+132]
	mov	BYTE PTR __$EHRec$[esp+140], 3
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T37945[esp+144], edi
	mov	BYTE PTR __$EHRec$[esp+128], 1
	jb	SHORT $LN178@do_get
	mov	ecx, DWORD PTR $T37945[esp+124]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN178@do_get:
	cmp	DWORD PTR __Str$17532[esp+144], edi
	mov	eax, DWORD PTR __Str$17532[esp+124]
	jae	SHORT $LN193@do_get

; 343  : 		_DEBUG_RANGE(_First, _Last);
; 344  : 		int _Ans = -1;	// negative answer indicates failure
; 345  : 
; 346  : 		if (_Iosbase.flags() & ios_base::boolalpha)
; 347  : 			{	// get false name or true name
; 348  : 			typedef typename _Mystr::size_type _Mystrsize;
; 349  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);
; 350  : 			_Mystr _Str((_Mystrsize)1, (char_type)0);
; 351  : 			_Str += _Punct_fac.falsename();
; 352  : 			_Str += (char_type)0;
; 353  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"
; 354  : 			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());

	lea	eax, DWORD PTR __Str$17532[esp+124]
$LN193@do_get:
	push	eax
	push	2
	lea	edx, DWORD PTR __Last$[esp+124]
	push	edx
	lea	eax, DWORD PTR __First$[esp+128]
	push	eax
	call	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 16					; 00000010H

; 355  : 			}

	cmp	DWORD PTR __Str$17532[esp+144], edi
	mov	ebp, eax
	mov	DWORD PTR __$EHRec$[esp+128], -1
	jb	$LN4@do_get
	mov	ecx, DWORD PTR __Str$17532[esp+124]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 356  : 		else

	jmp	$LN4@do_get
$LN6@do_get:

; 357  : 			{	// get zero or nonzero integer
; 358  : 			char _Ac[_MAX_INT_DIG], *_Ep;
; 359  : 			int _Errno = 0;
; 360  : 			const unsigned long _Ulo = ::_Stoulx(_Ac, &_Ep,
; 361  : 				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 362  : 					_Iosbase.getloc()), &_Errno);

	lea	edx, DWORD PTR $T37946[esp+120]
	push	edx
	mov	DWORD PTR __Errno$17548[esp+124], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR __Errno$17548[esp+120]
	push	ecx
	push	eax
	push	esi
	lea	edx, DWORD PTR __Last$[esp+128]
	push	edx
	lea	eax, DWORD PTR __First$[esp+132]
	push	eax
	lea	ecx, DWORD PTR __Ac$17546[esp+140]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+156], 4
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	edx, DWORD PTR __Ep$17547[esp+128]
	push	edx
	lea	eax, DWORD PTR __Ac$17546[esp+132]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T37946[esp+120]
	mov	esi, eax
	mov	DWORD PTR __$EHRec$[esp+128], -1
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 363  : 			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)

	lea	ecx, DWORD PTR __Ac$17546[esp+120]
	cmp	DWORD PTR __Ep$17547[esp+120], ecx
	je	SHORT $LN4@do_get
	cmp	DWORD PTR __Errno$17548[esp+120], 0
	jne	SHORT $LN4@do_get
	cmp	esi, 1
	ja	SHORT $LN4@do_get

; 364  : 				_Ans = _Ulo;

	mov	ebp, esi
$LN4@do_get:

; 365  : 			}
; 366  : 
; 367  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+124], 0
	mov	edi, DWORD PTR __First$[esp+120]
	jne	SHORT $LN235@do_get
	test	edi, edi
	je	SHORT $LN233@do_get
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN239@do_get
	mov	edx, DWORD PTR [edi+48]
	cmp	DWORD PTR [edx], 0
	jle	SHORT $LN239@do_get
	mov	eax, DWORD PTR [eax]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN240@do_get
$LN239@do_get:
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, edi
	call	eax
$LN240@do_get:
	cmp	eax, -1
	je	SHORT $LN233@do_get
	mov	BYTE PTR __First$[esp+125], al
	jmp	SHORT $LN232@do_get
$LN233@do_get:
	xor	edi, edi
$LN232@do_get:
	mov	BYTE PTR __First$[esp+124], 1
$LN235@do_get:
	cmp	BYTE PTR __Last$[esp+124], 0
	mov	esi, DWORD PTR __Last$[esp+120]
	jne	SHORT $LN255@do_get
	test	esi, esi
	je	SHORT $LN256@do_get
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN262@do_get
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN262@do_get
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN263@do_get
$LN262@do_get:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN263@do_get:
	cmp	eax, -1
	jne	SHORT $LN255@do_get
$LN256@do_get:
	xor	esi, esi
$LN255@do_get:
	test	edi, edi
	jne	SHORT $LN278@do_get
	test	esi, esi
	je	SHORT $LN279@do_get
$LN283@do_get:

; 368  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+120]
$LN3@do_get:

; 369  : 		if (_Ans < 0)

	test	ebp, ebp
	jge	SHORT $LN285@do_get

; 370  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2

; 371  : 		else

	jmp	SHORT $LN1@do_get
$LN278@do_get:

; 365  : 			}
; 366  : 
; 367  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN283@do_get
$LN279@do_get:

; 368  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+120]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN3@do_get
$LN285@do_get:

; 372  : 			_Val = _Ans != 0;	// deliver value

	mov	ecx, DWORD PTR __Val$GSCopy$[esp+120]
	setne	al
	mov	BYTE PTR [ecx], al
$LN1@do_get:

; 373  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+120]
	mov	edx, DWORD PTR __First$[esp+116]
	mov	ecx, DWORD PTR __First$[esp+124]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], ecx

; 374  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 104				; 00000068H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
	lea	ecx, DWORD PTR $T37943[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
	lea	ecx, DWORD PTR __Str$17532[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
	lea	ecx, DWORD PTR $T37944[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
	lea	ecx, DWORD PTR $T37945[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
	lea	ecx, DWORD PTR $T37946[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-104]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
__Ptr$ = -80						; size = 4
__State$GSCopy$ = -76					; size = 4
__Errno$ = -72						; size = 4
__Lock$39182 = -68					; size = 4
__Val$GSCopy$ = -64					; size = 4
$T39148 = -60						; size = 4
___$ReturnUdt$GSCopy$ = -56				; size = 4
__Ep$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 379  : 		{	// get unsigned short from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	mov	esi, DWORD PTR __Iosbase$[esp+92]
	mov	edx, DWORD PTR __Val$[esp+92]
	mov	edi, ecx
	mov	ecx, DWORD PTR __State$[esp+92]

; 391  : 		if (_Ep == _Ptr || _Errno != 0 || USHRT_MAX < _Ans)

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+96], eax
	lea	eax, DWORD PTR $T39148[esp+96]
	mov	DWORD PTR __State$GSCopy$[esp+96], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Val$GSCopy$[esp+100], edx
	mov	DWORD PTR __Errno$[esp+100], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR __Last$[esp+100]
	push	ecx
	lea	edx, DWORD PTR __First$[esp+104]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+112]
	push	eax
	push	edi
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	mov	ebp, eax
	mov	eax, DWORD PTR $T39148[esp+120]
	add	esp, 24					; 00000018H
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+104], -1
	je	SHORT $LN17@do_get@2
	push	0
	lea	ecx, DWORD PTR __Lock$39182[esp+100]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN19@do_get@2

; 380  : 		_DEBUG_RANGE(_First, _Last);
; 381  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 382  : 		int _Errno = 0;
; 383  : 		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 384  : 			_Iosbase.getloc());	// gather field into _Ac

	cmp	eax, -1
	jae	SHORT $LN19@do_get@2
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN19@do_get@2:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$39182[esp+96]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN17@do_get@2
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN17@do_get@2:

; 385  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	cmp	BYTE PTR __Ac$[esp+96], 45		; 0000002dH
	jne	SHORT $LN7@do_get@2
	lea	ecx, DWORD PTR __Ac$[esp+97]
	mov	DWORD PTR __Ptr$[esp+96], ecx
	jmp	SHORT $LN8@do_get@2
$LN7@do_get@2:
	lea	edx, DWORD PTR __Ac$[esp+96]
	mov	DWORD PTR __Ptr$[esp+96], edx
$LN8@do_get@2:

; 386  : 		const unsigned long _Ans =
; 387  : 			::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	edx, DWORD PTR __Ptr$[esp+96]
	lea	eax, DWORD PTR __Errno$[esp+96]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR __Ep$[esp+104]
	push	ecx
	push	edx
	call	__Stoulx

; 388  : 
; 389  : 		if (_First == _Last)

	mov	ebp, DWORD PTR __First$[esp+112]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR __First$[esp+100], 0
	mov	edi, eax
	jne	SHORT $LN36@do_get@2
	test	ebp, ebp
	je	SHORT $LN34@do_get@2
	mov	eax, DWORD PTR [ebp+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN40@do_get@2
	mov	ecx, DWORD PTR [ebp+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN40@do_get@2
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN41@do_get@2
$LN40@do_get@2:
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, ebp
	call	edx
$LN41@do_get@2:
	cmp	eax, -1
	je	SHORT $LN34@do_get@2
	mov	BYTE PTR __First$[esp+101], al
	jmp	SHORT $LN33@do_get@2
$LN34@do_get@2:
	xor	ebp, ebp
$LN33@do_get@2:
	mov	BYTE PTR __First$[esp+100], 1
$LN36@do_get@2:
	cmp	BYTE PTR __Last$[esp+100], 0
	mov	esi, DWORD PTR __Last$[esp+96]
	jne	SHORT $LN56@do_get@2
	test	esi, esi
	je	SHORT $LN57@do_get@2
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN63@do_get@2
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN63@do_get@2
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN64@do_get@2
$LN63@do_get@2:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN64@do_get@2:
	cmp	eax, -1
	jne	SHORT $LN56@do_get@2
$LN57@do_get@2:
	xor	esi, esi
$LN56@do_get@2:
	test	ebp, ebp
	jne	SHORT $LN79@do_get@2
	test	esi, esi
	je	SHORT $LN80@do_get@2
$LN85@do_get@2:

; 390  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+96]
$LN4@do_get@2:

; 391  : 		if (_Ep == _Ptr || _Errno != 0 || USHRT_MAX < _Ans)

	mov	ecx, DWORD PTR __Ptr$[esp+96]
	cmp	DWORD PTR __Ep$[esp+96], ecx
	je	SHORT $LN2@do_get@2
	cmp	DWORD PTR __Errno$[esp+96], 0
	jne	SHORT $LN2@do_get@2
	cmp	edi, 65535				; 0000ffffH
	ja	SHORT $LN2@do_get@2

; 393  : 		else
; 394  : 			_Val = (unsigned short)(_Ac[0] == '-'
; 395  : 				? 0 -_Ans : _Ans);	// deliver value

	cmp	BYTE PTR __Ac$[esp+96], 45		; 0000002dH
	jne	SHORT $LN9@do_get@2
	neg	edi
$LN9@do_get@2:
	mov	edx, DWORD PTR __Val$GSCopy$[esp+96]
	mov	eax, edi
	mov	WORD PTR [edx], ax
	jmp	SHORT $LN1@do_get@2
$LN79@do_get@2:

; 388  : 
; 389  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN85@do_get@2
$LN80@do_get@2:

; 390  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+96]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN4@do_get@2
$LN2@do_get@2:

; 392  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2
$LN1@do_get@2:

; 396  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+96]
	mov	ecx, DWORD PTR __First$[esp+92]
	mov	edx, DWORD PTR __First$[esp+100]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], edx

; 397  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
	lea	ecx, DWORD PTR $T39148[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-80]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
__Ptr$ = -80						; size = 4
__State$GSCopy$ = -76					; size = 4
__Errno$ = -72						; size = 4
__Lock$39495 = -68					; size = 4
__Val$GSCopy$ = -64					; size = 4
$T39461 = -60						; size = 4
___$ReturnUdt$GSCopy$ = -56				; size = 4
__Ep$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 402  : 		{	// get unsigned int from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	mov	esi, DWORD PTR __Iosbase$[esp+92]
	mov	edx, DWORD PTR __Val$[esp+92]
	mov	edi, ecx
	mov	ecx, DWORD PTR __State$[esp+92]

; 414  : 		if (_Ep == _Ptr || _Errno != 0 || UINT_MAX < _Ans)

	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+96], eax
	lea	eax, DWORD PTR $T39461[esp+96]
	mov	DWORD PTR __State$GSCopy$[esp+96], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Val$GSCopy$[esp+100], edx
	mov	DWORD PTR __Errno$[esp+100], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	ecx, DWORD PTR __Last$[esp+100]
	push	ecx
	lea	edx, DWORD PTR __First$[esp+104]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+112]
	push	eax
	push	edi
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	mov	ebp, eax
	mov	eax, DWORD PTR $T39461[esp+120]
	add	esp, 24					; 00000018H
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+104], -1
	je	SHORT $LN17@do_get@3
	push	0
	lea	ecx, DWORD PTR __Lock$39495[esp+100]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN19@do_get@3

; 403  : 		_DEBUG_RANGE(_First, _Last);
; 404  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 405  : 		int _Errno = 0;
; 406  : 		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 407  : 			_Iosbase.getloc());	// gather field into _Ac

	cmp	eax, -1
	jae	SHORT $LN19@do_get@3
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN19@do_get@3:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$39495[esp+96]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN17@do_get@3
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN17@do_get@3:

; 408  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	cmp	BYTE PTR __Ac$[esp+96], 45		; 0000002dH
	jne	SHORT $LN7@do_get@3
	lea	ecx, DWORD PTR __Ac$[esp+97]
	mov	DWORD PTR __Ptr$[esp+96], ecx
	jmp	SHORT $LN8@do_get@3
$LN7@do_get@3:
	lea	edx, DWORD PTR __Ac$[esp+96]
	mov	DWORD PTR __Ptr$[esp+96], edx
$LN8@do_get@3:

; 409  : 		const unsigned long _Ans =
; 410  : 			::_Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	edx, DWORD PTR __Ptr$[esp+96]
	lea	eax, DWORD PTR __Errno$[esp+96]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR __Ep$[esp+104]
	push	ecx
	push	edx
	call	__Stoulx

; 411  : 
; 412  : 		if (_First == _Last)

	mov	ebp, DWORD PTR __First$[esp+112]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR __First$[esp+100], 0
	mov	edi, eax
	jne	SHORT $LN36@do_get@3
	test	ebp, ebp
	je	SHORT $LN34@do_get@3
	mov	eax, DWORD PTR [ebp+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN40@do_get@3
	mov	ecx, DWORD PTR [ebp+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN40@do_get@3
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN41@do_get@3
$LN40@do_get@3:
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, ebp
	call	edx
$LN41@do_get@3:
	cmp	eax, -1
	je	SHORT $LN34@do_get@3
	mov	BYTE PTR __First$[esp+101], al
	jmp	SHORT $LN33@do_get@3
$LN34@do_get@3:
	xor	ebp, ebp
$LN33@do_get@3:
	mov	BYTE PTR __First$[esp+100], 1
$LN36@do_get@3:
	cmp	BYTE PTR __Last$[esp+100], 0
	mov	esi, DWORD PTR __Last$[esp+96]
	jne	SHORT $LN56@do_get@3
	test	esi, esi
	je	SHORT $LN57@do_get@3
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN63@do_get@3
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN63@do_get@3
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN64@do_get@3
$LN63@do_get@3:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN64@do_get@3:
	cmp	eax, -1
	jne	SHORT $LN56@do_get@3
$LN57@do_get@3:
	xor	esi, esi
$LN56@do_get@3:
	test	ebp, ebp
	jne	SHORT $LN79@do_get@3
	test	esi, esi
	je	SHORT $LN80@do_get@3
$LN86@do_get@3:

; 413  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+96]
$LN4@do_get@3:

; 414  : 		if (_Ep == _Ptr || _Errno != 0 || UINT_MAX < _Ans)

	mov	ecx, DWORD PTR __Ptr$[esp+96]
	cmp	DWORD PTR __Ep$[esp+96], ecx
	je	SHORT $LN2@do_get@3
	cmp	DWORD PTR __Errno$[esp+96], 0
	jne	SHORT $LN2@do_get@3
	cmp	edi, -1
	ja	SHORT $LN2@do_get@3

; 416  : 		else
; 417  : 			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	// deliver value

	cmp	BYTE PTR __Ac$[esp+96], 45		; 0000002dH
	jne	SHORT $LN9@do_get@3
	neg	edi
$LN9@do_get@3:
	mov	edx, DWORD PTR __Val$GSCopy$[esp+96]
	mov	eax, edi
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN1@do_get@3
$LN79@do_get@3:

; 411  : 
; 412  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN86@do_get@3
$LN80@do_get@3:

; 413  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+96]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN4@do_get@3
$LN2@do_get@3:

; 415  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2
$LN1@do_get@3:

; 418  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+96]
	mov	ecx, DWORD PTR __First$[esp+92]
	mov	edx, DWORD PTR __First$[esp+100]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], edx

; 419  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0:
	lea	ecx, DWORD PTR $T39461[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-80]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__Val$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__Stolx:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
__Errno$ = -76						; size = 4
__Ep$ = -72						; size = 4
__Ans$ = -68						; size = 4
__Val$GSCopy$ = -64					; size = 4
$T39775 = -60						; size = 4
___$ReturnUdt$GSCopy$ = -56				; size = 4
__Lock$39805 = -52					; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 424  : 		{	// get long from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	esi, DWORD PTR __Iosbase$[esp+88]
	mov	ebp, DWORD PTR __State$[esp+88]
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+88]

; 425  : 		_DEBUG_RANGE(_First, _Last);
; 426  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 427  : 		int _Errno = 0;
; 428  : 		const long _Ans = ::_Stolx(_Ac, &_Ep,
; 429  : 			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 430  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	lea	edx, DWORD PTR $T39775[esp+92]
	mov	DWORD PTR __Val$GSCopy$[esp+92], ecx
	push	edx
	mov	ecx, esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+96], eax
	mov	DWORD PTR __Errno$[esp+96], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR __Errno$[esp+92]
	push	ecx
	push	eax
	push	esi
	lea	edx, DWORD PTR __Last$[esp+100]
	push	edx
	lea	eax, DWORD PTR __First$[esp+104]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+112]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+100]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+104]
	push	eax
	call	__Stolx
	mov	DWORD PTR __Ans$[esp+108], eax
	mov	eax, DWORD PTR $T39775[esp+108]
	add	esp, 16					; 00000010H
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+100], -1
	je	SHORT $LN13@do_get@4
	push	0
	lea	ecx, DWORD PTR __Lock$39805[esp+96]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN15@do_get@4
	cmp	eax, -1
	jae	SHORT $LN15@do_get@4
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN15@do_get@4:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$39805[esp+92]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN13@do_get@4
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN13@do_get@4:

; 431  : 
; 432  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+96], 0
	mov	edi, DWORD PTR __First$[esp+92]
	jne	SHORT $LN32@do_get@4
	test	edi, edi
	je	SHORT $LN30@do_get@4
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@do_get@4
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN36@do_get@4
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN37@do_get@4
$LN36@do_get@4:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN37@do_get@4:
	cmp	eax, -1
	je	SHORT $LN30@do_get@4
	mov	BYTE PTR __First$[esp+97], al
	jmp	SHORT $LN29@do_get@4
$LN30@do_get@4:
	xor	edi, edi
$LN29@do_get@4:
	mov	BYTE PTR __First$[esp+96], 1
$LN32@do_get@4:
	cmp	BYTE PTR __Last$[esp+96], 0
	mov	esi, DWORD PTR __Last$[esp+92]
	jne	SHORT $LN52@do_get@4
	test	esi, esi
	je	SHORT $LN53@do_get@4
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@do_get@4
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN59@do_get@4
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN60@do_get@4
$LN59@do_get@4:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN60@do_get@4:
	cmp	eax, -1
	jne	SHORT $LN52@do_get@4
$LN53@do_get@4:
	xor	esi, esi
$LN52@do_get@4:
	test	edi, edi
	jne	SHORT $LN75@do_get@4
	test	esi, esi
	je	SHORT $LN76@do_get@4
	jmp	SHORT $LN4@do_get@4
$LN75@do_get@4:
	test	esi, esi
	je	SHORT $LN4@do_get@4
$LN76@do_get@4:

; 433  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebp], 1
$LN4@do_get@4:

; 434  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+92]
	cmp	DWORD PTR __Ep$[esp+92], eax
	je	SHORT $LN2@do_get@4
	cmp	DWORD PTR __Errno$[esp+92], 0
	jne	SHORT $LN2@do_get@4

; 436  : 		else
; 437  : 			_Val = _Ans;	// deliver value

	mov	ecx, DWORD PTR __Ans$[esp+92]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+92]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN1@do_get@4
$LN2@do_get@4:

; 435  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebp], 2
$LN1@do_get@4:

; 438  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+92]
	mov	ecx, DWORD PTR __First$[esp+88]
	mov	edx, DWORD PTR __First$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edx

; 439  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
	lea	ecx, DWORD PTR $T39775[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__Val$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
__Errno$ = -76						; size = 4
__Ep$ = -72						; size = 4
__Ans$ = -68						; size = 4
__Val$GSCopy$ = -64					; size = 4
$T40083 = -60						; size = 4
___$ReturnUdt$GSCopy$ = -56				; size = 4
__Lock$40113 = -52					; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 444  : 		{	// get unsigned long from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	esi, DWORD PTR __Iosbase$[esp+88]
	mov	ebp, DWORD PTR __State$[esp+88]
	mov	edi, ecx
	mov	ecx, DWORD PTR __Val$[esp+88]

; 445  : 		_DEBUG_RANGE(_First, _Last);
; 446  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 447  : 		int _Errno = 0;
; 448  : 		const unsigned long _Ans = ::_Stoulx(_Ac, &_Ep,
; 449  : 			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 450  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	lea	edx, DWORD PTR $T40083[esp+92]
	mov	DWORD PTR __Val$GSCopy$[esp+92], ecx
	push	edx
	mov	ecx, esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+96], eax
	mov	DWORD PTR __Errno$[esp+96], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR __Errno$[esp+92]
	push	ecx
	push	eax
	push	esi
	lea	edx, DWORD PTR __Last$[esp+100]
	push	edx
	lea	eax, DWORD PTR __First$[esp+104]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+112]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+100]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+104]
	push	eax
	call	__Stoulx
	mov	DWORD PTR __Ans$[esp+108], eax
	mov	eax, DWORD PTR $T40083[esp+108]
	add	esp, 16					; 00000010H
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+100], -1
	je	SHORT $LN13@do_get@5
	push	0
	lea	ecx, DWORD PTR __Lock$40113[esp+96]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN15@do_get@5
	cmp	eax, -1
	jae	SHORT $LN15@do_get@5
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN15@do_get@5:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$40113[esp+92]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN13@do_get@5
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN13@do_get@5:

; 451  : 
; 452  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+96], 0
	mov	edi, DWORD PTR __First$[esp+92]
	jne	SHORT $LN32@do_get@5
	test	edi, edi
	je	SHORT $LN30@do_get@5
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@do_get@5
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN36@do_get@5
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN37@do_get@5
$LN36@do_get@5:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN37@do_get@5:
	cmp	eax, -1
	je	SHORT $LN30@do_get@5
	mov	BYTE PTR __First$[esp+97], al
	jmp	SHORT $LN29@do_get@5
$LN30@do_get@5:
	xor	edi, edi
$LN29@do_get@5:
	mov	BYTE PTR __First$[esp+96], 1
$LN32@do_get@5:
	cmp	BYTE PTR __Last$[esp+96], 0
	mov	esi, DWORD PTR __Last$[esp+92]
	jne	SHORT $LN52@do_get@5
	test	esi, esi
	je	SHORT $LN53@do_get@5
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@do_get@5
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN59@do_get@5
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN60@do_get@5
$LN59@do_get@5:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN60@do_get@5:
	cmp	eax, -1
	jne	SHORT $LN52@do_get@5
$LN53@do_get@5:
	xor	esi, esi
$LN52@do_get@5:
	test	edi, edi
	jne	SHORT $LN75@do_get@5
	test	esi, esi
	je	SHORT $LN76@do_get@5
	jmp	SHORT $LN4@do_get@5
$LN75@do_get@5:
	test	esi, esi
	je	SHORT $LN4@do_get@5
$LN76@do_get@5:

; 453  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebp], 1
$LN4@do_get@5:

; 454  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+92]
	cmp	DWORD PTR __Ep$[esp+92], eax
	je	SHORT $LN2@do_get@5
	cmp	DWORD PTR __Errno$[esp+92], 0
	jne	SHORT $LN2@do_get@5

; 456  : 		else
; 457  : 			_Val = _Ans;	// deliver value

	mov	ecx, DWORD PTR __Ans$[esp+92]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+92]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN1@do_get@5
$LN2@do_get@5:

; 455  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebp], 2
$LN1@do_get@5:

; 458  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+92]
	mov	ecx, DWORD PTR __First$[esp+88]
	mov	edx, DWORD PTR __First$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edx

; 459  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+76]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
	lea	ecx, DWORD PTR $T40083[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__strtoi64:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
__Ep$ = -72						; size = 4
__Val$GSCopy$ = -68					; size = 4
__Lock$40421 = -64					; size = 4
__Ans$ = -60						; size = 8
$T40391 = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 465  : 		{	// get long long from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+72], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR __Iosbase$[esp+88]
	mov	eax, DWORD PTR __Val$[esp+88]
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	ebx, DWORD PTR __State$[esp+88]
	mov	edi, ecx

; 466  : 		_DEBUG_RANGE(_First, _Last);
; 467  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 468  : 		int _Errno = 0;
; 469  : 		const _LONGLONG _Ans = ::_STOLL(_Ac, &_Ep,

	lea	ecx, DWORD PTR $T40391[esp+92]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Val$GSCopy$[esp+96], eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	edx, DWORD PTR __Last$[esp+96]
	push	edx
	lea	eax, DWORD PTR __First$[esp+100]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+108]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+120]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+124]
	push	eax
	call	__strtoi64
	mov	DWORD PTR __Ans$[esp+128], eax
	mov	eax, DWORD PTR $T40391[esp+128]
	add	esp, 36					; 00000024H
	test	eax, eax
	mov	DWORD PTR __Ans$[esp+96], edx
	mov	DWORD PTR __$EHRec$[esp+100], -1
	je	SHORT $LN13@do_get@6
	push	0
	lea	ecx, DWORD PTR __Lock$40421[esp+96]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN15@do_get@6
	cmp	eax, -1
	jae	SHORT $LN15@do_get@6
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN15@do_get@6:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$40421[esp+92]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN13@do_get@6
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN13@do_get@6:

; 470  : 			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 471  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert
; 472  : 
; 473  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+96], 0
	mov	edi, DWORD PTR __First$[esp+92]
	jne	SHORT $LN32@do_get@6
	test	edi, edi
	je	SHORT $LN30@do_get@6
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@do_get@6
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN36@do_get@6
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN37@do_get@6
$LN36@do_get@6:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN37@do_get@6:
	cmp	eax, -1
	je	SHORT $LN30@do_get@6
	mov	BYTE PTR __First$[esp+97], al
	jmp	SHORT $LN29@do_get@6
$LN30@do_get@6:
	xor	edi, edi
$LN29@do_get@6:
	mov	BYTE PTR __First$[esp+96], 1
$LN32@do_get@6:
	cmp	BYTE PTR __Last$[esp+96], 0
	mov	esi, DWORD PTR __Last$[esp+92]
	jne	SHORT $LN52@do_get@6
	test	esi, esi
	je	SHORT $LN53@do_get@6
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@do_get@6
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN59@do_get@6
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN60@do_get@6
$LN59@do_get@6:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN60@do_get@6:
	cmp	eax, -1
	jne	SHORT $LN52@do_get@6
$LN53@do_get@6:
	xor	esi, esi
$LN52@do_get@6:
	test	edi, edi
	jne	SHORT $LN75@do_get@6
	test	esi, esi
	je	SHORT $LN76@do_get@6
	jmp	SHORT $LN4@do_get@6
$LN75@do_get@6:
	test	esi, esi
	je	SHORT $LN4@do_get@6
$LN76@do_get@6:

; 474  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get@6:

; 475  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+92]
	cmp	DWORD PTR __Ep$[esp+92], eax
	je	SHORT $LN2@do_get@6

; 477  : 		else
; 478  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$[esp+92]
	mov	ecx, DWORD PTR __Ans$[esp+92]
	mov	edx, DWORD PTR __Ans$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN1@do_get@6
$LN2@do_get@6:

; 476  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get@6:

; 479  : 		return (_First);

	mov	eax, DWORD PTR __First$[esp+88]
	mov	ecx, DWORD PTR __First$[esp+96]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], ecx
	mov	eax, ebp

; 480  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+72]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 72					; 00000048H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
	lea	ecx, DWORD PTR $T40391[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__strtoui64:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
__Ep$ = -72						; size = 4
__Val$GSCopy$ = -68					; size = 4
__Lock$40730 = -64					; size = 4
__Ans$ = -60						; size = 8
$T40700 = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 485  : 		{	// get unsigned long long from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+72], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR __Iosbase$[esp+88]
	mov	eax, DWORD PTR __Val$[esp+88]
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	ebx, DWORD PTR __State$[esp+88]
	mov	edi, ecx

; 486  : 		_DEBUG_RANGE(_First, _Last);
; 487  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 488  : 		int _Errno = 0;
; 489  : 		const _ULONGLONG _Ans = ::_STOULL(_Ac, &_Ep,

	lea	ecx, DWORD PTR $T40700[esp+92]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Val$GSCopy$[esp+96], eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	esi, DWORD PTR [esi+16]
	push	eax
	push	esi
	lea	edx, DWORD PTR __Last$[esp+96]
	push	edx
	lea	eax, DWORD PTR __First$[esp+100]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+108]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[esp+124], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+120]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+124]
	push	eax
	call	__strtoui64
	mov	DWORD PTR __Ans$[esp+128], eax
	mov	eax, DWORD PTR $T40700[esp+128]
	add	esp, 36					; 00000024H
	test	eax, eax
	mov	DWORD PTR __Ans$[esp+96], edx
	mov	DWORD PTR __$EHRec$[esp+100], -1
	je	SHORT $LN13@do_get@7
	push	0
	lea	ecx, DWORD PTR __Lock$40730[esp+96]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN15@do_get@7
	cmp	eax, -1
	jae	SHORT $LN15@do_get@7
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN15@do_get@7:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$40730[esp+92]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN13@do_get@7
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN13@do_get@7:

; 490  : 			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
; 491  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert
; 492  : 
; 493  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+96], 0
	mov	edi, DWORD PTR __First$[esp+92]
	jne	SHORT $LN32@do_get@7
	test	edi, edi
	je	SHORT $LN30@do_get@7
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@do_get@7
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN36@do_get@7
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN37@do_get@7
$LN36@do_get@7:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN37@do_get@7:
	cmp	eax, -1
	je	SHORT $LN30@do_get@7
	mov	BYTE PTR __First$[esp+97], al
	jmp	SHORT $LN29@do_get@7
$LN30@do_get@7:
	xor	edi, edi
$LN29@do_get@7:
	mov	BYTE PTR __First$[esp+96], 1
$LN32@do_get@7:
	cmp	BYTE PTR __Last$[esp+96], 0
	mov	esi, DWORD PTR __Last$[esp+92]
	jne	SHORT $LN52@do_get@7
	test	esi, esi
	je	SHORT $LN53@do_get@7
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@do_get@7
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN59@do_get@7
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN60@do_get@7
$LN59@do_get@7:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN60@do_get@7:
	cmp	eax, -1
	jne	SHORT $LN52@do_get@7
$LN53@do_get@7:
	xor	esi, esi
$LN52@do_get@7:
	test	edi, edi
	jne	SHORT $LN75@do_get@7
	test	esi, esi
	je	SHORT $LN76@do_get@7
	jmp	SHORT $LN4@do_get@7
$LN75@do_get@7:
	test	esi, esi
	je	SHORT $LN4@do_get@7
$LN76@do_get@7:

; 494  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get@7:

; 495  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+92]
	cmp	DWORD PTR __Ep$[esp+92], eax
	je	SHORT $LN2@do_get@7

; 497  : 		else
; 498  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$[esp+92]
	mov	ecx, DWORD PTR __Ans$[esp+92]
	mov	edx, DWORD PTR __Ans$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN1@do_get@7
$LN2@do_get@7:

; 496  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get@7:

; 499  : 		return (_First);

	mov	eax, DWORD PTR __First$[esp+88]
	mov	ecx, DWORD PTR __First$[esp+96]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], ecx
	mov	eax, ebp

; 500  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+72]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 72					; 00000048H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
	lea	ecx, DWORD PTR $T40700[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-76]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__Stofx:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
__State$GSCopy$ = -104					; size = 4
__Errno$ = -100						; size = 4
__Lock$41035 = -96					; size = 4
__Ans$ = -92						; size = 4
$T41009 = -88						; size = 4
__Val$GSCopy$ = -84					; size = 4
__Ep$ = -80						; size = 4
__Ac$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 506  : 		{	// get float from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+104], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+120]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __State$[esp+116]
	mov	edx, DWORD PTR __Val$[esp+116]
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+116]

; 520  : 		return (_First);

	mov	DWORD PTR __State$GSCopy$[esp+120], eax
	lea	eax, DWORD PTR $T41009[esp+120]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Iosbase$[esp+116]
	push	eax
	mov	DWORD PTR __Val$GSCopy$[esp+124], edx
	mov	DWORD PTR __Errno$[esp+124], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[esp+120]
	push	ecx
	push	eax
	lea	edx, DWORD PTR __Last$[esp+124]
	push	edx
	lea	eax, DWORD PTR __First$[esp+128]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+136]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+152], 0
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+128]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+132]
	push	eax
	call	__Stofx
	fstp	DWORD PTR __Ans$[esp+136]
	mov	edi, DWORD PTR $T41009[esp+136]
	add	esp, 16					; 00000010H
	test	edi, edi
	mov	DWORD PTR __$EHRec$[esp+128], -1
	je	SHORT $LN11@do_get@8
	push	0
	lea	ecx, DWORD PTR __Lock$41035[esp+124]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN13@do_get@8

; 507  : 		_DEBUG_RANGE(_First, _Last);
; 508  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 509  : 		int _Errno = 0;
; 510  : 		const float _Ans = ::_Stofx(_Ac, &_Ep,
; 511  : 			_Getffld(_Ac, _First, _Last,
; 512  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	cmp	eax, -1
	jae	SHORT $LN13@do_get@8
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN13@do_get@8:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$41035[esp+120]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN11@do_get@8
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN11@do_get@8:

; 513  : 
; 514  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+124], 0
	mov	edi, DWORD PTR __First$[esp+120]
	jne	SHORT $LN30@do_get@8
	test	edi, edi
	je	SHORT $LN28@do_get@8
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN34@do_get@8
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN34@do_get@8
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN35@do_get@8
$LN34@do_get@8:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN35@do_get@8:
	cmp	eax, -1
	je	SHORT $LN28@do_get@8
	mov	BYTE PTR __First$[esp+125], al
	jmp	SHORT $LN27@do_get@8
$LN28@do_get@8:
	xor	edi, edi
$LN27@do_get@8:
	mov	BYTE PTR __First$[esp+124], 1
$LN30@do_get@8:
	cmp	BYTE PTR __Last$[esp+124], 0
	mov	esi, DWORD PTR __Last$[esp+120]
	jne	SHORT $LN50@do_get@8
	test	esi, esi
	je	SHORT $LN51@do_get@8
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@do_get@8
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN57@do_get@8
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN58@do_get@8
$LN57@do_get@8:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN58@do_get@8:
	cmp	eax, -1
	jne	SHORT $LN50@do_get@8
$LN51@do_get@8:
	xor	esi, esi
$LN50@do_get@8:
	test	edi, edi
	jne	SHORT $LN73@do_get@8
	test	esi, esi
	je	SHORT $LN74@do_get@8
$LN79@do_get@8:

; 515  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+120]
$LN4@do_get@8:

; 516  : 		if (_Ep == _Ac || _Errno != 0)

	lea	ecx, DWORD PTR __Ac$[esp+120]
	cmp	DWORD PTR __Ep$[esp+120], ecx
	je	SHORT $LN2@do_get@8
	cmp	DWORD PTR __Errno$[esp+120], 0
	jne	SHORT $LN2@do_get@8

; 518  : 		else
; 519  : 			_Val = _Ans;	// deliver value

	fld	DWORD PTR __Ans$[esp+120]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+120]
	fstp	DWORD PTR [edx]
	jmp	SHORT $LN1@do_get@8
$LN73@do_get@8:

; 513  : 
; 514  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN79@do_get@8
$LN74@do_get@8:

; 515  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+120]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN4@do_get@8
$LN2@do_get@8:

; 517  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2
$LN1@do_get@8:

; 520  : 		return (_First);

	mov	eax, DWORD PTR __First$[esp+116]
	mov	ecx, DWORD PTR __First$[esp+124]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], ecx
	mov	eax, ebp

; 521  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+120]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+104]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 104				; 00000068H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z$0:
	lea	ecx, DWORD PTR $T41009[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-104]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__Stodx:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
__State$GSCopy$ = -108					; size = 4
__Errno$ = -104						; size = 4
__Lock$41340 = -100					; size = 4
__Val$GSCopy$ = -96					; size = 4
$T41314 = -92						; size = 4
__Ep$ = -88						; size = 4
__Ans$ = -84						; size = 8
__Ac$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 526  : 		{	// get double from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+108], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __State$[esp+120]
	mov	edx, DWORD PTR __Val$[esp+120]
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+120]

; 540  : 		return (_First);

	mov	DWORD PTR __State$GSCopy$[esp+124], eax
	lea	eax, DWORD PTR $T41314[esp+124]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Iosbase$[esp+120]
	push	eax
	mov	DWORD PTR __Val$GSCopy$[esp+128], edx
	mov	DWORD PTR __Errno$[esp+128], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[esp+124]
	push	ecx
	push	eax
	lea	edx, DWORD PTR __Last$[esp+128]
	push	edx
	lea	eax, DWORD PTR __First$[esp+132]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+140]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+156], 0
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+132]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+136]
	push	eax
	call	__Stodx
	fstp	QWORD PTR __Ans$[esp+140]
	mov	edi, DWORD PTR $T41314[esp+140]
	add	esp, 16					; 00000010H
	test	edi, edi
	mov	DWORD PTR __$EHRec$[esp+132], -1
	je	SHORT $LN11@do_get@9
	push	0
	lea	ecx, DWORD PTR __Lock$41340[esp+128]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN13@do_get@9

; 527  : 		_DEBUG_RANGE(_First, _Last);
; 528  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 529  : 		int _Errno = 0;
; 530  : 		const double _Ans = ::_Stodx(_Ac, &_Ep,
; 531  : 			_Getffld(_Ac, _First, _Last,
; 532  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	cmp	eax, -1
	jae	SHORT $LN13@do_get@9
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN13@do_get@9:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$41340[esp+124]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN11@do_get@9
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN11@do_get@9:

; 533  : 
; 534  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+128], 0
	mov	edi, DWORD PTR __First$[esp+124]
	jne	SHORT $LN30@do_get@9
	test	edi, edi
	je	SHORT $LN28@do_get@9
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN34@do_get@9
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN34@do_get@9
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN35@do_get@9
$LN34@do_get@9:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN35@do_get@9:
	cmp	eax, -1
	je	SHORT $LN28@do_get@9
	mov	BYTE PTR __First$[esp+129], al
	jmp	SHORT $LN27@do_get@9
$LN28@do_get@9:
	xor	edi, edi
$LN27@do_get@9:
	mov	BYTE PTR __First$[esp+128], 1
$LN30@do_get@9:
	cmp	BYTE PTR __Last$[esp+128], 0
	mov	esi, DWORD PTR __Last$[esp+124]
	jne	SHORT $LN50@do_get@9
	test	esi, esi
	je	SHORT $LN51@do_get@9
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@do_get@9
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN57@do_get@9
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN58@do_get@9
$LN57@do_get@9:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN58@do_get@9:
	cmp	eax, -1
	jne	SHORT $LN50@do_get@9
$LN51@do_get@9:
	xor	esi, esi
$LN50@do_get@9:
	test	edi, edi
	jne	SHORT $LN73@do_get@9
	test	esi, esi
	je	SHORT $LN74@do_get@9
$LN79@do_get@9:

; 535  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+124]
$LN4@do_get@9:

; 536  : 		if (_Ep == _Ac || _Errno != 0)

	lea	ecx, DWORD PTR __Ac$[esp+124]
	cmp	DWORD PTR __Ep$[esp+124], ecx
	je	SHORT $LN2@do_get@9
	cmp	DWORD PTR __Errno$[esp+124], 0
	jne	SHORT $LN2@do_get@9

; 538  : 		else
; 539  : 			_Val = _Ans;	// deliver value

	fld	QWORD PTR __Ans$[esp+124]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+124]
	fstp	QWORD PTR [edx]
	jmp	SHORT $LN1@do_get@9
$LN73@do_get@9:

; 533  : 
; 534  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN79@do_get@9
$LN74@do_get@9:

; 535  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+124]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN4@do_get@9
$LN2@do_get@9:

; 537  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2
$LN1@do_get@9:

; 540  : 		return (_First);

	mov	eax, DWORD PTR __First$[esp+120]
	mov	ecx, DWORD PTR __First$[esp+128]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], ecx
	mov	eax, ebp

; 541  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 108				; 0000006cH
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z$0:
	lea	ecx, DWORD PTR $T41314[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-108]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	__$ArrayPad$
EXTRN	__Stoldx:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
__State$GSCopy$ = -108					; size = 4
__Errno$ = -104						; size = 4
__Lock$41645 = -100					; size = 4
__Val$GSCopy$ = -96					; size = 4
$T41619 = -92						; size = 4
__Ep$ = -88						; size = 4
__Ans$ = -84						; size = 8
__Ac$ = -76						; size = 60
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 546  : 		{	// get long double from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+108], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __State$[esp+120]
	mov	edx, DWORD PTR __Val$[esp+120]
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+120]

; 560  : 		return (_First);

	mov	DWORD PTR __State$GSCopy$[esp+124], eax
	lea	eax, DWORD PTR $T41619[esp+124]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Iosbase$[esp+120]
	push	eax
	mov	DWORD PTR __Val$GSCopy$[esp+128], edx
	mov	DWORD PTR __Errno$[esp+128], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[esp+124]
	push	ecx
	push	eax
	lea	edx, DWORD PTR __Last$[esp+128]
	push	edx
	lea	eax, DWORD PTR __First$[esp+132]
	push	eax
	lea	ecx, DWORD PTR __Ac$[esp+140]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[esp+156], 0
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 20					; 00000014H
	push	eax
	lea	edx, DWORD PTR __Ep$[esp+132]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+136]
	push	eax
	call	__Stoldx
	fstp	QWORD PTR __Ans$[esp+140]
	mov	edi, DWORD PTR $T41619[esp+140]
	add	esp, 16					; 00000010H
	test	edi, edi
	mov	DWORD PTR __$EHRec$[esp+132], -1
	je	SHORT $LN11@do_get@10
	push	0
	lea	ecx, DWORD PTR __Lock$41645[esp+128]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN13@do_get@10

; 547  : 		_DEBUG_RANGE(_First, _Last);
; 548  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 549  : 		int _Errno = 0;
; 550  : 		const long double _Ans = ::_Stoldx(_Ac, &_Ep,
; 551  : 			_Getffld(_Ac, _First, _Last,
; 552  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	cmp	eax, -1
	jae	SHORT $LN13@do_get@10
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN13@do_get@10:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$41645[esp+124]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN11@do_get@10
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN11@do_get@10:

; 553  : 
; 554  : 		if (_First == _Last)

	cmp	BYTE PTR __First$[esp+128], 0
	mov	edi, DWORD PTR __First$[esp+124]
	jne	SHORT $LN30@do_get@10
	test	edi, edi
	je	SHORT $LN28@do_get@10
	mov	eax, DWORD PTR [edi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN34@do_get@10
	mov	ecx, DWORD PTR [edi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN34@do_get@10
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN35@do_get@10
$LN34@do_get@10:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, edi
	call	edx
$LN35@do_get@10:
	cmp	eax, -1
	je	SHORT $LN28@do_get@10
	mov	BYTE PTR __First$[esp+129], al
	jmp	SHORT $LN27@do_get@10
$LN28@do_get@10:
	xor	edi, edi
$LN27@do_get@10:
	mov	BYTE PTR __First$[esp+128], 1
$LN30@do_get@10:
	cmp	BYTE PTR __Last$[esp+128], 0
	mov	esi, DWORD PTR __Last$[esp+124]
	jne	SHORT $LN50@do_get@10
	test	esi, esi
	je	SHORT $LN51@do_get@10
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@do_get@10
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN57@do_get@10
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN58@do_get@10
$LN57@do_get@10:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN58@do_get@10:
	cmp	eax, -1
	jne	SHORT $LN50@do_get@10
$LN51@do_get@10:
	xor	esi, esi
$LN50@do_get@10:
	test	edi, edi
	jne	SHORT $LN73@do_get@10
	test	esi, esi
	je	SHORT $LN74@do_get@10
$LN79@do_get@10:

; 555  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+124]
$LN4@do_get@10:

; 556  : 		if (_Ep == _Ac || _Errno != 0)

	lea	ecx, DWORD PTR __Ac$[esp+124]
	cmp	DWORD PTR __Ep$[esp+124], ecx
	je	SHORT $LN2@do_get@10
	cmp	DWORD PTR __Errno$[esp+124], 0
	jne	SHORT $LN2@do_get@10

; 558  : 		else
; 559  : 			_Val = _Ans;	// deliver value

	fld	QWORD PTR __Ans$[esp+124]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+124]
	fstp	QWORD PTR [edx]
	jmp	SHORT $LN1@do_get@10
$LN73@do_get@10:

; 553  : 
; 554  : 		if (_First == _Last)

	test	esi, esi
	je	SHORT $LN79@do_get@10
$LN74@do_get@10:

; 555  : 			_State |= ios_base::eofbit;

	mov	eax, DWORD PTR __State$GSCopy$[esp+124]
	or	DWORD PTR [eax], 1
	jmp	SHORT $LN4@do_get@10
$LN2@do_get@10:

; 557  : 			_State |= ios_base::failbit;

	or	DWORD PTR [eax], 2
$LN1@do_get@10:

; 560  : 		return (_First);

	mov	eax, DWORD PTR __First$[esp+120]
	mov	ecx, DWORD PTR __First$[esp+128]
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], edi
	mov	DWORD PTR [ebp+8], ecx
	mov	eax, ebp

; 561  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 108				; 0000006cH
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z$0:
	lea	ecx, DWORD PTR $T41619[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-108]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	__Val$GSCopy$
PUBLIC	__State$GSCopy$
PUBLIC	___$ReturnUdt$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 8\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\xlocnum
xdata$x	ENDS
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
__State$GSCopy$ = -80					; size = 4
__Ans$ = -80						; size = 8
__Errno$ = -72						; size = 4
__Lock$41952 = -68					; size = 4
__Val$GSCopy$ = -64					; size = 4
$T41924 = -60						; size = 4
___$ReturnUdt$GSCopy$ = -56				; size = 4
__Ep$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Iosbase$ = 36						; size = 4
__State$ = 40						; size = 4
__Val$ = 44						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 566  : 		{	// get void pointer from [_First, _Last) into _Val

	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+80], eax
	push	ebp
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, eax

; 591  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	mov	edx, DWORD PTR __Val$[esp+92]
	mov	edi, DWORD PTR __State$[esp+92]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[esp+96], eax
	lea	eax, DWORD PTR $T41924[esp+96]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Iosbase$[esp+92]
	push	eax
	mov	DWORD PTR __State$GSCopy$[esp+100], edi
	mov	DWORD PTR __Val$GSCopy$[esp+100], edx
	mov	DWORD PTR __Errno$[esp+100], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	push	2048					; 00000800H
	lea	ecx, DWORD PTR __Last$[esp+100]
	push	ecx
	lea	edx, DWORD PTR __First$[esp+104]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+112]
	push	eax
	push	esi
	mov	DWORD PTR __$EHRec$[esp+128], 0
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	mov	ebp, eax
	mov	eax, DWORD PTR $T41924[esp+120]
	add	esp, 24					; 00000018H
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+104], -1
	je	SHORT $LN13@do_get@11
	push	0
	lea	ecx, DWORD PTR __Lock$41952[esp+100]
	mov	edi, eax
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jbe	SHORT $LN15@do_get@11

; 567  : 		_DEBUG_RANGE(_First, _Last);
; 568  : 		char _Ac[_MAX_INT_DIG], *_Ep;
; 569  : 		int _Errno = 0;
; 570  : 
; 571  :  #ifdef _LONGLONG
; 572  : 		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
; 573  : 			_Iosbase.getloc());	// gather field

	cmp	eax, -1
	jae	SHORT $LN15@do_get@11
	add	eax, -1
	mov	DWORD PTR [edi+4], eax
$LN15@do_get@11:
	mov	esi, DWORD PTR [edi+4]
	neg	esi
	sbb	esi, esi
	not	esi
	lea	ecx, DWORD PTR __Lock$41952[esp+96]
	and	esi, edi
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	test	esi, esi
	je	SHORT $LN79@do_get@11
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	push	1
	mov	ecx, esi
	call	eax
$LN79@do_get@11:
	mov	edi, DWORD PTR __State$GSCopy$[esp+96]
$LN13@do_get@11:

; 574  : 		const _ULONGLONG _Ans =
; 575  : 			(sizeof (void *) == sizeof (unsigned long))
; 576  : 				? (_ULONGLONG)::_Stoulx(_Ac, &_Ep, _Base, &_Errno)
; 577  : 				: ::_STOULL(_Ac, &_Ep, _Base, &_Errno);

	lea	ecx, DWORD PTR __Errno$[esp+96]
	push	ecx
	push	ebp
	lea	edx, DWORD PTR __Ep$[esp+104]
	push	edx
	lea	eax, DWORD PTR __Ac$[esp+108]
	push	eax
	call	__Stoulx

; 578  : 
; 579  :  #else /* _LONGLONG */
; 580  : 		const unsigned long _Ans = ::_Stoulx(_Ac, &_Ep,
; 581  : 			_Getifld(_Ac, _First, _Last, ios_base::hex,
; 582  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert
; 583  :  #endif /* _LONGLONG */
; 584  : 
; 585  : 		if (_First == _Last)

	mov	ebp, DWORD PTR __First$[esp+112]
	add	esp, 16					; 00000010H
	cmp	BYTE PTR __First$[esp+100], 0
	mov	DWORD PTR __Ans$[esp+96], eax
	mov	DWORD PTR __Ans$[esp+100], 0
	jne	SHORT $LN32@do_get@11
	test	ebp, ebp
	je	SHORT $LN30@do_get@11
	mov	eax, DWORD PTR [ebp+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@do_get@11
	mov	ecx, DWORD PTR [ebp+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN36@do_get@11
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN37@do_get@11
$LN36@do_get@11:
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, ebp
	call	edx
$LN37@do_get@11:
	cmp	eax, -1
	je	SHORT $LN30@do_get@11
	mov	BYTE PTR __First$[esp+101], al
	jmp	SHORT $LN29@do_get@11
$LN30@do_get@11:
	xor	ebp, ebp
$LN29@do_get@11:
	mov	BYTE PTR __First$[esp+100], 1
$LN32@do_get@11:
	cmp	BYTE PTR __Last$[esp+100], 0
	mov	esi, DWORD PTR __Last$[esp+96]
	jne	SHORT $LN52@do_get@11
	test	esi, esi
	je	SHORT $LN53@do_get@11
	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN59@do_get@11
	mov	ecx, DWORD PTR [esi+48]
	cmp	DWORD PTR [ecx], 0
	jle	SHORT $LN59@do_get@11
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	jmp	SHORT $LN60@do_get@11
$LN59@do_get@11:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, esi
	call	edx
$LN60@do_get@11:
	cmp	eax, -1
	jne	SHORT $LN52@do_get@11
$LN53@do_get@11:
	xor	esi, esi
$LN52@do_get@11:
	test	ebp, ebp
	jne	SHORT $LN75@do_get@11
	test	esi, esi
	je	SHORT $LN76@do_get@11
	jmp	SHORT $LN4@do_get@11
$LN75@do_get@11:
	test	esi, esi
	je	SHORT $LN4@do_get@11
$LN76@do_get@11:

; 586  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [edi], 1
$LN4@do_get@11:

; 587  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+96]
	cmp	DWORD PTR __Ep$[esp+96], eax
	je	SHORT $LN2@do_get@11
	cmp	DWORD PTR __Errno$[esp+96], 0
	jne	SHORT $LN2@do_get@11

; 589  : 		else
; 590  : 			_Val = (void *)(uintptr_t)_Ans;	// deliver value

	mov	ecx, DWORD PTR __Ans$[esp+96]
	mov	edx, DWORD PTR __Val$GSCopy$[esp+96]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN1@do_get@11
$LN2@do_get@11:

; 588  : 			_State |= ios_base::failbit;

	or	DWORD PTR [edi], 2
$LN1@do_get@11:

; 591  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$[esp+96]
	mov	ecx, DWORD PTR __First$[esp+92]
	mov	edx, DWORD PTR __First$[esp+100]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], edx

; 592  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebp
	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 80					; 00000050H
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
	lea	ecx, DWORD PTR $T41924[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-80]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 8\vc\include\ostream
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z PROC ; std::endl, COMDAT

; 964  : 	{	// insert newline and flush byte stream

	push	esi

; 965  : 	_Ostr.put('\n');

	mov	esi, DWORD PTR __Ostr$[esp]
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 966  : 	_Ostr.flush();

	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 967  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 968  : 	}

	ret	0
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ENDP ; std::endl
_TEXT	ENDS
PUBLIC	??_C@_0BD@DKPGNEEM@Elapsed?5ASM?5time?3?5?$AA@	; `string'
PUBLIC	??_C@_0BD@NECCHDKI@Elapsed?5CPP?5time?3?5?$AA@	; `string'
PUBLIC	??_C@_0BD@LNNMOGKN@?5seconds?4?5Found?5?$DN?5?$AA@ ; `string'
PUBLIC	??_C@_0DK@GPFFNIHC@Please?5wait?4?5This?5will?5take?5betw@ ; `string'
PUBLIC	??_C@_0BG@HMMAFGON@Enter?5value?5to?5find?3?5?$AA@ ; `string'
PUBLIC	_main
EXTRN	_AsmFindArray:PROC
EXTRN	_FindArray:PROC
EXTRN	?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cin
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	_rand:PROC
EXTRN	__chkstk:PROC
;	COMDAT ??_C@_0BD@DKPGNEEM@Elapsed?5ASM?5time?3?5?$AA@
; File c:\program files\microsoft visual studio 8\vc\include\ios
CONST	SEGMENT
??_C@_0BD@DKPGNEEM@Elapsed?5ASM?5time?3?5?$AA@ DB 'Elapsed ASM time: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NECCHDKI@Elapsed?5CPP?5time?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@NECCHDKI@Elapsed?5CPP?5time?3?5?$AA@ DB 'Elapsed CPP time: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LNNMOGKN@?5seconds?4?5Found?5?$DN?5?$AA@
CONST	SEGMENT
??_C@_0BD@LNNMOGKN@?5seconds?4?5Found?5?$DN?5?$AA@ DB ' seconds. Found = '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GPFFNIHC@Please?5wait?4?5This?5will?5take?5betw@
CONST	SEGMENT
??_C@_0DK@GPFFNIHC@Please?5wait?4?5This?5will?5take?5betw@ DB 'Please wai'
	DB	't. This will take between 10 and 30 seconds...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HMMAFGON@Enter?5value?5to?5find?3?5?$AA@
CONST	SEGMENT
??_C@_0BG@HMMAFGON@Enter?5value?5to?5find?3?5?$AA@ DB 'Enter value to fin'
	DB	'd: ', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\data\asmbook5\examples\ch12\visualcpp\findarray\main.cpp
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_found$ = -40024					; size = 1
_searchVal$ = -40020					; size = 4
_endTime$ = -40016					; size = 8
_startTime$ = -40008					; size = 8
_array$ = -40000					; size = 40000
_main	PROC						; COMDAT

; 9    : {

	mov	eax, 40024				; 00009c58H
	call	__chkstk
	push	esi
	push	edi

; 10   : 	// Fill an array with pseudorandom integers.
; 11   : 	const unsigned ARRAY_SIZE = 10000; 
; 12   : 	const unsigned LOOP_SIZE = 1000000;
; 13   : 
; 14   : 	long array[ARRAY_SIZE]; 
; 15   : 	for(unsigned i = 0; i < ARRAY_SIZE; i++)

	xor	esi, esi
	npad	2
$LL9@main:

; 16   :      array[i] = rand();

	call	_rand
	mov	DWORD PTR _array$[esp+esi*4+40032], eax
	add	esi, 1
	cmp	esi, 10000				; 00002710H
	jb	SHORT $LL9@main

; 17   : 
; 18   : 	long searchVal;
; 19   : 	time_t startTime, endTime;
; 20   : 	cout << "Enter value to find: ";

	push	OFFSET ??_C@_0BG@HMMAFGON@Enter?5value?5to?5find?3?5?$AA@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 21   : 	cin >> searchVal;

	lea	eax, DWORD PTR _searchVal$[esp+40032]
	push	eax
	mov	ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAJ@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>

; 22   : 	cout << "Please wait. This will take between 10 and 30 seconds...\n";

	push	OFFSET ??_C@_0DK@GPFFNIHC@Please?5wait?4?5This?5will?5take?5betw@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 23   : 
; 24   : 
; 25   : // Test the C++ function:
; 26   : 
; 27   : 	time( &startTime );

	lea	ecx, DWORD PTR _startTime$[esp+40040]
	push	ecx
	call	__time64
	add	esp, 12					; 0000000cH
	mov	esi, 1000000				; 000f4240H
	npad	10
$LL6@main:

; 28   : 	bool found = false;
; 29   : 
; 30   : 	for( int n = 0; n < LOOP_SIZE; n++)
; 31   : 		found = FindArray( searchVal, array, ARRAY_SIZE );

	mov	eax, DWORD PTR _searchVal$[esp+40032]
	push	10000					; 00002710H
	lea	edx, DWORD PTR _array$[esp+40036]
	push	edx
	push	eax
	call	_FindArray
	add	esp, 12					; 0000000cH
	sub	esi, 1
	mov	BYTE PTR _found$[esp+40032], al
	jne	SHORT $LL6@main

; 32   : 
; 33   : 	time( &endTime );

	lea	ecx, DWORD PTR _endTime$[esp+40032]
	push	ecx
	call	__time64

; 34   : 	cout << "Elapsed CPP time: " << long(endTime - startTime) 
; 35   : 		<< " seconds. Found = " << found << endl;

	mov	edx, DWORD PTR _found$[esp+40036]
	mov	eax, DWORD PTR _endTime$[esp+40036]
	sub	eax, DWORD PTR _startTime$[esp+40036]
	add	esp, 4
	push	edx
	push	OFFSET ??_C@_0BD@LNNMOGKN@?5seconds?4?5Found?5?$DN?5?$AA@
	push	eax
	push	OFFSET ??_C@_0BD@NECCHDKI@Elapsed?5CPP?5time?3?5?$AA@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN20@main
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN20@main
	mov	edi, 4
$LN20@main:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN36@main
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN38@main
	or	eax, 4
$LN38@main:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN36@main:

; 36   : 
; 37   : // Test the Assembly language procedure:
; 38   : 
; 39   : 	time( &startTime );

	lea	edx, DWORD PTR _startTime$[esp+40032]
	push	edx
	call	__time64
	add	esp, 4
	mov	esi, 1000000				; 000f4240H
	npad	3
$LL3@main:

; 40   : 	found = false;
; 41   : 
; 42   : 	for( int n = 0; n < LOOP_SIZE; n++)
; 43   : 		found = AsmFindArray( searchVal, array, ARRAY_SIZE );

	mov	ecx, DWORD PTR _searchVal$[esp+40032]
	push	10000					; 00002710H
	lea	eax, DWORD PTR _array$[esp+40036]
	push	eax
	push	ecx
	call	_AsmFindArray
	add	esp, 12					; 0000000cH
	sub	esi, 1
	mov	BYTE PTR _found$[esp+40032], al
	jne	SHORT $LL3@main

; 44   : 
; 45   : 	time( &endTime );

	lea	edx, DWORD PTR _endTime$[esp+40032]
	push	edx
	call	__time64

; 46   : 	cout << "Elapsed ASM time: " << long(endTime - startTime) 
; 47   : 		  << " seconds. Found = " << found << endl;

	mov	eax, DWORD PTR _found$[esp+40036]
	mov	ecx, DWORD PTR _endTime$[esp+40036]
	sub	ecx, DWORD PTR _startTime$[esp+40036]
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BD@LNNMOGKN@?5seconds?4?5Found?5?$DN?5?$AA@
	push	ecx
	push	OFFSET ??_C@_0BD@DKPGNEEM@Elapsed?5ASM?5time?3?5?$AA@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	esi, eax
	push	10					; 0000000aH
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	edi, edi
	test	BYTE PTR [eax+8], 6
	jne	SHORT $LN48@main
	mov	eax, DWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, -1
	jne	SHORT $LN48@main
	mov	edi, 4
$LN48@main:
	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi
	test	edi, edi
	je	SHORT $LN74@main
	mov	eax, DWORD PTR [ecx+8]
	or	eax, edi
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN66@main
	or	eax, 4
$LN66@main:
	push	0
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN74@main:
	pop	edi

; 48   : 
; 49   : 	return 0;

	xor	eax, eax
	pop	esi

; 50   : }

	add	esp, 40024				; 00009c58H
	ret	0
_main	ENDP
_TEXT	ENDS
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
; File c:\program files\microsoft visual studio 8\vc\include\xlocale
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
END
